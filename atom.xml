<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zyq2652192993zyq.github.io/</id>
    <title>Kylin</title>
    <updated>2020-05-18T11:15:29.796Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zyq2652192993zyq.github.io/"/>
    <link rel="self" href="https://zyq2652192993zyq.github.io/atom.xml"/>
    <subtitle>Talk is cheap, show me the code.</subtitle>
    <logo>https://zyq2652192993zyq.github.io/images/avatar.png</logo>
    <icon>https://zyq2652192993zyq.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Kylin</rights>
    <entry>
        <title type="html"><![CDATA[1451.Rearrange Words in a Sentence]]></title>
        <id>https://zyq2652192993zyq.github.io/post/1451rearrange-words-in-a-sentence/</id>
        <link href="https://zyq2652192993zyq.github.io/post/1451rearrange-words-in-a-sentence/">
        </link>
        <updated>2020-05-18T04:51:16.000Z</updated>
        <content type="html"><![CDATA[<p><strong>文中提到的题目可在我GitHub的<a href="https://github.com/zyq2652192993zyq/LeetCode">LeetCode</a>, <a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge">SJTU OJ</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Algorithm%20Analysis">Algorithm Analysis</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Problem%20Solution">Problem Solution</a>找到解答。</strong></p>
<p>Tags: <code>Medium</code> <code>String</code> <code>Sort</code></p>
<p>Links: https://leetcode.com/problems/rearrange-words-in-a-sentence/</p>
<hr>
<p>Given a sentence <code>text</code> (A <em>sentence</em> is a string of space-separated words) in the following format:</p>
<ul>
<li>First letter is in upper case.</li>
<li>Each word in <code>text</code> are separated by a single space.</li>
</ul>
<p>Your task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order.</p>
<p>Return the new text following the format shown above.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: text = &quot;Leetcode is cool&quot;
Output: &quot;Is cool leetcode&quot;
Explanation: There are 3 words, &quot;Leetcode&quot; of length 8, &quot;is&quot; of length 2 and &quot;cool&quot; of length 4.
Output is ordered by length and the new first word starts with capital letter.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: text = &quot;Keep calm and code on&quot;
Output: &quot;On and keep calm code&quot;
Explanation: Output is ordered as follows:
&quot;On&quot; 2 letters.
&quot;and&quot; 3 letters.
&quot;keep&quot; 4 letters in case of tie order by position in original text.
&quot;calm&quot; 4 letters.
&quot;code&quot; 4 letters.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: text = &quot;To be or not to be&quot;
Output: &quot;To be or to be not&quot;
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>text</code> begins with a capital letter and then contains lowercase letters and single space between words.</li>
<li><code>1 &lt;= text.length &lt;= 10^5</code></li>
</ul>
<hr>
<p>核心思路是字符串切割，如果说一定要找类似的话，那么HDU 1062 Text Reverse和UIUC的System Programming的Extreme_Edge_Cases Lab会有一定程度的接近。</p>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="language-c++">class Solution {
	struct Node
	{
		string str;
		int seq;
		Node(string s, int num): str(s), seq(num) {}
		bool operator&lt;(const Node &amp; obj) const 
		{
			return (str.size() &lt; obj.str.size()) 
				|| (str.size() == obj.str.size() &amp;&amp; seq &lt; obj.seq);
		}
	};

public:
    string arrangeWords(string text) {
    	std::ios_base::sync_with_stdio(false);
		cin.tie(NULL);
		cout.tie(NULL);

		text[0] = tolower(text[0]);
		vector&lt;Node&gt; word;
		split(text, word);
		sort(word.begin(), word.end());
		string res;

		int n = word.size();
		word[0].str[0] = toupper(word[0].str[0]);
		for (int i = 0; i &lt; n; ++i) {
			res += word[i].str;
			if (i != n - 1) res.push_back(' ');
		}

		return res;
    }

    void split(string &amp; text, vector&lt;Node&gt; &amp; word)
    {
    	int cnt = 1;
    	int loc = 0;
    	while (text.find(&quot; &quot;, loc) != string::npos) {
    		int pos = text.find(&quot; &quot;, loc);
    		word.push_back(Node(text.substr(loc, pos - loc), cnt++));
    		loc = pos + 1;
    	}
    	word.push_back(Node(text.substr(loc), cnt));
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1452.People Whose List of Favorite Companies Is Not a Subset of Another List]]></title>
        <id>https://zyq2652192993zyq.github.io/post/1452people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/</id>
        <link href="https://zyq2652192993zyq.github.io/post/1452people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/">
        </link>
        <updated>2020-05-18T04:38:35.000Z</updated>
        <content type="html"><![CDATA[<p><strong>文中提到的题目可在我GitHub的<a href="https://github.com/zyq2652192993zyq/LeetCode">LeetCode</a>, <a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge">SJTU OJ</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Algorithm%20Analysis">Algorithm Analysis</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Problem%20Solution">Problem Solution</a>找到解答。</strong></p>
<p>Tags: <code>Medium</code> <code>String</code> <code>Sort</code> <code>Set</code></p>
<p>Links: https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/</p>
<hr>
<p>Given the array <code>favoriteCompanies</code> where <code>favoriteCompanies[i]</code> is the list of favorites companies for the <code>ith</code> person (<strong>indexed from 0</strong>).</p>
<p><em>Return the indices of people whose list of favorite companies is not a <strong>subset</strong> of any other list of favorites companies</em>. You must return the indices in increasing order.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: favoriteCompanies = [[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;],[&quot;google&quot;,&quot;microsoft&quot;],[&quot;google&quot;,&quot;facebook&quot;],[&quot;google&quot;],[&quot;amazon&quot;]]
Output: [0,1,4] 
Explanation: 
Person with index=2 has favoriteCompanies[2]=[&quot;google&quot;,&quot;facebook&quot;] which is a subset of favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;] corresponding to the person with index 0. 
Person with index=3 has favoriteCompanies[3]=[&quot;google&quot;] which is a subset of favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;] and favoriteCompanies[1]=[&quot;google&quot;,&quot;microsoft&quot;]. 
Other lists of favorite companies are not a subset of another list, therefore, the answer is [0,1,4].
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: favoriteCompanies = [[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;],[&quot;leetcode&quot;,&quot;amazon&quot;],[&quot;facebook&quot;,&quot;google&quot;]]
Output: [0,1] 
Explanation: In this case favoriteCompanies[2]=[&quot;facebook&quot;,&quot;google&quot;] is a subset of favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;], therefore, the answer is [0,1].
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: favoriteCompanies = [[&quot;leetcode&quot;],[&quot;google&quot;],[&quot;facebook&quot;],[&quot;amazon&quot;]]
Output: [0,1,2,3]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= favoriteCompanies.length &lt;= 100</code></li>
<li><code>1 &lt;= favoriteCompanies[i].length &lt;= 500</code></li>
<li><code>1 &lt;= favoriteCompanies[i][j].length &lt;= 20</code></li>
<li>All strings in <code>favoriteCompanies[i]</code> are <strong>distinct</strong>.</li>
<li>All lists of favorite companies are <strong>distinct</strong>, that is, If we sort alphabetically each list then <code>favoriteCompanies[i] != favoriteCompanies[j].</code></li>
<li>All strings consist of lowercase English letters only.</li>
</ul>
<hr>
<p>如果把每一个字符串的组合看成一个集合，那么这道题就是判断一个集合是否是其他集合的子集。如果一个集合是别的集合的子集，那么它的集合大小一定不能超过其他集合的最大长度，所以我们可以按照集合的长度进行排序，然后从头开始检验。</p>
<p>检验的过程中，使用<code>set</code>加快检验一个元素是否在另一个集合中存在。如果一个元素在某一个集合中不存在，那么就无需在检验当前集合，转而检验是否是下一个集合的子集。</p>
<pre><code class="language-c++">class Solution {
	struct Node
	{
		int originNum, len;
		unordered_set&lt;string&gt; us;

		bool operator&lt;(const Node &amp; obj) const
		{
			return len &lt; obj.len;
		}
	};

public:
    vector&lt;int&gt; peopleIndexes(vector&lt;vector&lt;string&gt;&gt;&amp; favoriteCompanies) {
    	std::ios_base::sync_with_stdio(false);
		cin.tie(NULL);
		cout.tie(NULL);

		int n = favoriteCompanies.size();
		vector&lt;Node&gt; seq(n);
		for (int i = 0; i &lt; n; ++i) {
			seq[i].originNum = i;
			seq[i].len = favoriteCompanies[i].size();
			for (int j = 0; j &lt; seq[i].len; ++j) {
				seq[i].us.emplace(favoriteCompanies[i][j]);
			}
		}
		sort(seq.begin(), seq.end());

		vector&lt;int&gt; res;
		for (int i = 0; i &lt; n; ++i) {
			auto &amp; tmp = seq[i].us;
			bool isSub = false;
			for (int j = i + 1; j &lt; n; ++j) {
				bool allCanFind = true;
				for (auto &amp;e : tmp) {
					if (seq[j].us.find(e) == seq[j].us.end()) { allCanFind = false; break; }
				}
				if (allCanFind) { isSub = true; break; }
			}
			if (!isSub) res.push_back(seq[i].originNum);
		}

		sort(res.begin(), res.end());
		return res;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1453.Maximum Number of Darts Inside of a Circular Dartboard]]></title>
        <id>https://zyq2652192993zyq.github.io/post/1453maximum-number-of-darts-inside-of-a-circular-dartboard/</id>
        <link href="https://zyq2652192993zyq.github.io/post/1453maximum-number-of-darts-inside-of-a-circular-dartboard/">
        </link>
        <updated>2020-05-18T04:19:58.000Z</updated>
        <content type="html"><![CDATA[<p><strong>文中提到的题目可在我GitHub的<a href="https://github.com/zyq2652192993zyq/LeetCode">LeetCode</a>, <a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge">SJTU OJ</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Algorithm%20Analysis">Algorithm Analysis</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Problem%20Solution">Problem Solution</a>找到解答。</strong></p>
<p>Tags: <code>Hard</code> <code>Geometry</code></p>
<p>Links: https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/</p>
<hr>
<p>You have a very large square wall and a circular dartboard placed on the wall. You have been challenged to throw darts into the board blindfolded. Darts thrown at the wall are represented as an array of <code>points</code> on a 2D plane.</p>
<p>Return the maximum number of points that are within or lie on <strong>any</strong> circular dartboard of radius <code>r</code>.</p>
<p><strong>Example 1:</strong></p>
<figure data-type="image" tabindex="1"><img src="https://assets.leetcode.com/uploads/2020/04/29/sample_1_1806.png" alt="img" loading="lazy"></figure>
<pre><code>Input: points = [[-2,0],[2,0],[0,2],[0,-2]], r = 2
Output: 4
Explanation: Circle dartboard with center in (0,0) and radius = 2 contain all points.
</code></pre>
<p><strong>Example 2:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2020/04/29/sample_2_1806.png" alt="img" loading="lazy"></strong></p>
<pre><code>Input: points = [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], r = 5
Output: 5
Explanation: Circle dartboard with center in (0,4) and radius = 5 contain all points except the point (7,8).
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: points = [[-2,0],[2,0],[0,2],[0,-2]], r = 1
Output: 1
</code></pre>
<p><strong>Example 4:</strong></p>
<pre><code>Input: points = [[1,2],[3,5],[1,-1],[2,3],[4,1],[1,3]], r = 2
Output: 4
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= points.length &lt;= 100</code></li>
<li><code>points[i].length == 2</code></li>
<li><code>-10^4 &lt;= points[i][0], points[i][1] &lt;= 10^4</code></li>
<li><code>1 &lt;= r &lt;= 5000</code></li>
</ul>
<hr>
<p>解法一：暴力搜索，时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<p>卡掉的办法就是让数据范围<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n \leq 10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>。</p>
<p>解法二：扫描线：</p>
<p>以每一个点做为圆心画一个圆，枚举与其相交的其他圆，保存交点和角度，按角度排序，再次扫描一遍。时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2 \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2020/05/18/fSg4PVDayrk3qwc.png" alt="" loading="lazy"></figure>
<p>假设我们选取圆A作为分析的起点，以半径<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>做圆，圆A和圆E相交于点K和点J，如果圆心放在弧JK上，那么必然保证点A和点E可以被圆覆盖。所以问题转化成，求与圆A相交的圆中，圆A的某一段弧被最多的圆包含，上图中，弧OJ就被圆H和圆E包含，那么圆心放在弧OJ上，必然保证点A，点E和点H被圆覆盖。</p>
<p>接下来是如何去描述这个弧，过点J做AE的中垂线，交点为P，显然<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>E</mi><mo>=</mo><mfrac><mrow><mi>A</mi><mi>E</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">PE = \frac{AE}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，其中AS所在的直线为水平线，我们设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∠</mi><mi>A</mi><mi>E</mi><mi>J</mi><mo>=</mo><mi>ϕ</mi><mo separator="true">,</mo><mi mathvariant="normal">∠</mi><mi>S</mi><mi>A</mi><mi>E</mi><mo>=</mo><mi>θ</mi></mrow><annotation encoding="application/x-tex">\angle AEJ = \phi, \angle SAE = \theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mord">∠</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∠</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>，我们把极坐标的原点建立在点A，因为弧在圆A上，半径是固定的，那么只需要弧对应的圆心角的起始角度和终止角度即可唯一确定一段弧。</p>
<p>比如描述弧JK，我们只需要求出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∠</mi><mi>K</mi><mi>A</mi><mi>S</mi><mo separator="true">,</mo><mi mathvariant="normal">∠</mi><mi>S</mi><mi>A</mi><mi>J</mi></mrow><annotation encoding="application/x-tex">\angle KAS, \angle SAJ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8866799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∠</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∠</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span></span></span></span>即可，显然<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∠</mi><mi>K</mi><mi>A</mi><mi>S</mi><mo>=</mo><mi>θ</mi><mo>−</mo><mi>ϕ</mi><mo separator="true">,</mo><mi mathvariant="normal">∠</mi><mi>S</mi><mi>A</mi><mi>J</mi><mo>=</mo><mi>θ</mi><mo>+</mo><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\angle KAS = \theta - \phi, \angle SAJ = \theta + \phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mord">∠</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∠</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span></span></span></span>，那么根据几何关系求出两个角度就不难了。</p>
<p>现在考虑当E在过A的水平线下方的情况：</p>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2020/05/18/Uy8MF5QN39rbXSL.png" alt="" loading="lazy"></figure>
<p>发现起始角度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi><mo>−</mo><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\theta- \phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span></span></span></span>，终止角度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi><mo>+</mo><mi>θ</mi></mrow><annotation encoding="application/x-tex">\phi + \theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>。</p>
<p>另外两种情况只需要转换参考系，起始角度和终止角度的表达形式都不变。在计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>的时候用到了函数</p>
<pre><code class="language-c++">double atan2(double y, double x);
</code></pre>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">atan</mi><mo>⁡</mo><mn>2</mn><mo>(</mo><mi>y</mi><mo separator="true">,</mo><mi>x</mi><mo>)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>arctan</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mfrac><mi>y</mi><mi>x</mi></mfrac><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>&gt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>arctan</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mfrac><mi>y</mi><mi>x</mi></mfrac><mo fence="true">)</mo></mrow><mo>+</mo><mi>π</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>y</mi><mo>≥</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo>&lt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>arctan</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mfrac><mi>y</mi><mi>x</mi></mfrac><mo fence="true">)</mo></mrow><mo>−</mo><mi>π</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>y</mi><mo>&lt;</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo>&lt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>+</mo><mfrac><mi>π</mi><mn>2</mn></mfrac></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>y</mi><mo>&gt;</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mfrac><mi>π</mi><mn>2</mn></mfrac></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>y</mi><mo>&lt;</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext> undefined </mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>y</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\operatorname{atan} 2(y, x)=\left\{\begin{array}{ll}
\arctan \left(\frac{y}{x}\right) &amp; x&gt;0 \\
\arctan \left(\frac{y}{x}\right)+\pi &amp; y \geq 0, x&lt;0 \\
\arctan \left(\frac{y}{x}\right)-\pi &amp; y&lt;0, x&lt;0 \\
+\frac{\pi}{2} &amp; y&gt;0, x=0 \\
-\frac{\pi}{2} &amp; y&lt;0, x=0 \\
\text { undefined } &amp; y=0, x=0
\end{array}\right.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">a</span><span class="mord mathrm">t</span><span class="mord mathrm">a</span><span class="mord mathrm">n</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:7.23em;vertical-align:-3.3649999999999998em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.8500199999999998em;"><span style="top:-0.6999900000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-0.6999900000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-0.9999899999999999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.29999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.59999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.89999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.90001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.200010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.50001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.80001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-6.100019999999999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.3500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.865em;"><span style="top:-6.015000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">arctan</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span><span style="top:-4.805000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">arctan</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.595em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">arctan</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.3950000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">+</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-1.1950000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:0.004999999999999727em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> undefined </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.3649999999999998em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.865em;"><span style="top:-6.015000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-4.805000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-3.595em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.3950000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-1.1950000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:0.004999999999999727em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.3649999999999998em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>现在问题是如何找出哪一段弧被最多的圆包含，这就变成了一个扫描线问题。</p>
<p>一个小细节就是在排序的时候需要考虑当角度相同的情况，第一个样例就是一个很好的例子，假设考虑第一个点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(-2,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，那么与其相交的三段弧的范围是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mfrac><mi>π</mi><mn>2</mn></mfrac><mo separator="true">,</mo><mn>0</mn><mo>]</mo><mo separator="true">,</mo><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo>]</mo><mo separator="true">,</mo><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mfrac><mi>π</mi><mn>2</mn></mfrac><mo>]</mo></mrow><annotation encoding="application/x-tex">[\frac{\pi}{2}, 0], [0,0], [0, \frac{\pi}{2}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">[</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span></span></span></span>，很容易看出原点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>就是结果。在排序的过程中，会有4个0存在，但是从实际角度来看，在角度相同的情况，最先应该扫描起点，所以在排序的过程中增加了一个判断。</p>
<pre><code class="language-c++">class Solution {
	struct Node
	{
		double angle;
		bool isStartPoint;

		bool operator&lt;(const Node &amp; obj) const
		{
			return (angle &lt; obj.angle) || (angle == obj.angle &amp;&amp; isStartPoint);
		}
	};

public:
    int numPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, int r) {
    	std::ios_base::sync_with_stdio(false);
		cin.tie(NULL);
		cout.tie(NULL);

		int n = points.size();
		int res = 1;
		vector&lt;Node&gt; seq(n * n);

		for (int i = 0; i &lt; n; ++i) {
			int m = 0;
			for (int j = 0; j &lt; n; ++j) {
				double d = dis(points[i], points[j]);
				if (i != j &amp;&amp; d &lt;= 2.0 * r) {
					double phi = acos(d / 2 / r);
					double theta = atan2(points[j][1] * 1.0 - points[i][1], points[j][0] * 1.0 - points[i][0]);
					seq[m].angle = theta - phi; seq[m++].isStartPoint = true;
					seq[m].angle = theta + phi; seq[m++].isStartPoint = false;
				}
			}

			sort(seq.begin(), seq.begin() + m);

			int cnt = 1;
			for (int j = 0; j &lt; m; ++j) {
				if (seq[j].isStartPoint) ++cnt;
				else --cnt;
				res = max(res, cnt);
			}
		}

		return res;
    }

    inline double dis(vector&lt;int&gt; &amp; p1, vector&lt;int&gt; &amp; p2)
    {
    	return sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) * 1.0 
    		+ (p1[1] - p2[1]) * (p1[1] - p2[1]) * 1.0);
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[洛谷-P6033 合并果子 加强版（输入输出外挂+基数排序+队列）]]></title>
        <id>https://zyq2652192993zyq.github.io/post/luo-gu-p6033-he-bing-guo-zi-jia-qiang-ban-shu-ru-shu-chu-wai-gua-ji-shu-pai-xu-dui-lie/</id>
        <link href="https://zyq2652192993zyq.github.io/post/luo-gu-p6033-he-bing-guo-zi-jia-qiang-ban-shu-ru-shu-chu-wai-gua-ji-shu-pai-xu-dui-lie/">
        </link>
        <updated>2020-05-15T14:25:02.000Z</updated>
        <content type="html"><![CDATA[<p><strong>文中提到的题目可在我GitHub的<a href="https://github.com/zyq2652192993zyq/LeetCode">LeetCode</a>, <a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge">SJTU OJ</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Algorithm%20Analysis">Algorithm Analysis</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Problem%20Solution">Problem Solution</a>找到解答。</strong></p>
<h2 id="题目背景">题目背景</h2>
<p>本题除【数据范围与约定】外与 <a href="https://www.luogu.com.cn/problem/P1090">P1090</a> <strong>完 全 一 致</strong>。</p>
<h2 id="题目描述">题目描述</h2>
<p>在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。</p>
<p>每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 (n - 1) 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。</p>
<p>因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。</p>
<p>例如有 3 堆果子，数目依次为 1,2,9。可以先将 1、2 堆合并，新堆数目为 3，耗费体力为 3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12，耗费体力为 12。所以多多总共耗费体力为 3+12=15。可以证明 15为最小的体力耗费值。</p>
<h2 id="输入格式">输入格式</h2>
<p>输入的第一行是一个整数 n，代表果子的堆数。<br>
输入的第二行有 n个用空格隔开的整数，第 i个整数代表第 i堆果子的个数 a_i​。</p>
<h2 id="输出格式">输出格式</h2>
<p>输出一行一个整数，表示最小耗费的体力值。</p>
<h2 id="输入输出样例">输入输出样例</h2>
<p><strong>输入 #1</strong></p>
<pre><code>3 
1 2 9 
</code></pre>
<p><strong>输出 #1</strong></p>
<pre><code>15
</code></pre>
<h2 id="说明提示">说明/提示</h2>
<p><strong>【数据规模与约定】</strong></p>
<p><strong>本题采用多测试点捆绑测试，共有四个子任务</strong>。</p>
<ul>
<li>Subtask 1（10 points）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">1 \leq n \leq 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>。</li>
<li>Subtask 2（20 points）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq n \leq 10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>。</li>
<li>Subtask 3（30 points）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq n \leq 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>。</li>
<li>Subtask 4（40 points）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq n \leq 10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span>。</li>
</ul>
<p>对于全部的测试点，保证 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq a_i \leq 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>。</p>
<p><strong>【提示】</strong></p>
<ul>
<li>请注意常数因子对程序效率造成的影响。</li>
<li>请使用类型合适的变量来存储本题的结果。</li>
<li>本题输入规模较大，请注意数据读入对程序效率造成的影响。</li>
</ul>
<hr>
<p>这道题目是一个很典型，考察的点也比较多，首先在提示部分已经指明了，数据量很大，而且可以根据数据范围知道，结果有可能会超过<code>int</code>范围，所以需要使用<code>long long</code>，同时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span>的数据提示我们不能使用优先级队列了，因为时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>不能用优先级队列了，那么还必须对数据排序，因为每次要取出最小的两个，所以需要考虑<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的排序方法，桶排序，基数排序，计数排序，其中计数排序和桶排序相差无几（在《挑战程序设计竞赛2——数据结构》里认为这两个是同一种算法），在洛谷的题解里面，排名最高的解答指出，虽然本题给出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">a_i \leq 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>，可以使用桶排序，但是存在卡掉桶排序和计数排序的办法，比如让数据范围<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">a_i \leq 10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>，这样就不能开一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>的数组了，所以使用基数排序是最保险的。</p>
<p>数据排序完成后，这里可以重复利用基数排序的辅助数组<code>tmp</code>，让数组<code>tmp</code>充当队列的作用，用一个<code>head</code>和<code>tail</code>指针模拟队列，每次比较队列头部和数组的元素的大小，选择出最小的两个。因为数组长度为<code>n</code>，最后要只剩下一个元素，那么就需要进行<code>n - 1</code>次。</p>
<p>另外这道题经过尝试，在核心算法不改变的情况下，使用<code>scanf()</code>和关闭同步的<code>cin</code>都会在最后三个测试点超时，所以需要使用快读、快写。（注释的部分也展现了尝试过的输入输出改进办法）</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

template &lt;typename T&gt;
inline T read()
{
	T res = 0, sign = 1;
	char ch = 0;
	while (!isdigit(ch)) {
		if (ch == '-') sign = -1;
		ch = getchar();
	}

	while (isdigit(ch)) {
		res = res * 10 + (ch - '0');
		ch = getchar();
	}

	return res * sign;
}

template &lt;typename T&gt;
inline void write(T x)
{
	static int myStack[35];
	int top = 0;
	do {
		myStack[top++] = x % 10;
		x /= 10;
	} while (x);

	while (top) putchar(myStack[--top] + '0');
}


int n;
vector&lt;long long&gt; seq(1e7 + 5), tmp(1e7 + 5);
vector&lt;int&gt; countNum(256);

void radixSort()
{
	for (int i = 0; i &lt; 17; i += 8) {
		fill(countNum.begin(), countNum.end(), 0);
		for (int j = 0; j &lt; n; ++j) ++countNum[(seq[j] &gt;&gt; i) &amp; 255];
		for (int j = 1; j &lt; 256; ++j) countNum[j] += countNum[j - 1];
		for (int j = n - 1; j &gt;= 0; --j) tmp[--countNum[(seq[j] &gt;&gt; i) &amp; 255]] = seq[j];
		for (int j = 0; j &lt; n; ++j) seq[j] = tmp[j];
	} 
}

long long solve()
{
	int head = 0, tail = 0;
	int k = 0;
	long long res = 0;
	for (int i = 1; i &lt; n; ++i) {
		long long tmp1, tmp2;
		if (head == tail || (k &lt; n &amp;&amp; seq[k] &lt; tmp[head]))
			tmp1 = seq[k++];
		else tmp1 = tmp[head++];

		if (head == tail || (k &lt; n &amp;&amp; seq[k] &lt; tmp[head]))
			tmp2 = seq[k++];
		else tmp2 = tmp[head++];

		tmp[tail++] = tmp1 + tmp2;
		res += tmp[tail - 1];
	}

	return res;
}

int main()
{
	// std::ios_base::sync_with_stdio(false);
	// cin.tie(NULL);
	// cout.tie(NULL);

	//cin &gt;&gt; n;
	//scanf(&quot;%d&quot;, &amp;n);
	n = read&lt;int&gt;();
	for (int i = 0; i &lt; n; ++i) //scanf(&quot;%ld&quot;, &amp;seq[i]); /* cin &gt;&gt; seq[i]; */
		seq[i] = read&lt;long long&gt;();
	radixSort();
	//cout &lt;&lt; solve() &lt;&lt; endl;
	write&lt;long long&gt;(solve());

	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一本通-1363：小球(drop)（满二叉树性质应用）]]></title>
        <id>https://zyq2652192993zyq.github.io/post/yi-ben-tong-1363xiao-qiu-dropman-er-cha-shu-xing-zhi-ying-yong/</id>
        <link href="https://zyq2652192993zyq.github.io/post/yi-ben-tong-1363xiao-qiu-dropman-er-cha-shu-xing-zhi-ying-yong/">
        </link>
        <updated>2020-05-12T09:25:45.000Z</updated>
        <content type="html"><![CDATA[<p>【题目描述】<br>
许多的小球一个一个的从一棵满二叉树上掉下来组成FBT（Full Binary Tree，满二叉树），每一时间，一个正在下降的球第一个访问的是非叶子节点。然后继续下降时，或者走右子树，或者走左子树，直到访问到叶子节点。决定球运动方向的是每个节点的布尔值。最初，所有的节点都是false，当访问到一个节点时，如果这个节点是false，则这个球把它变成true，然后从左子树走，继续它的旅程。如果节点是true，则球也会改变它为false，而接下来从右子树走。满二叉树的标记方法如下图:</p>
<figure data-type="image" tabindex="1"><img src="http://ybt.ssoier.cn:8088/pic/1363.gif" alt="img" loading="lazy"></figure>
<p>因为所有的节点最初为false，所以第一个球将会访问节点1，节点2和节点4，转变节点的布尔值后在在节点8停止。第二个球将会访问节点1、3、6,在节点12停止。明显地，第三个球在它停止之前，会访问节点1、2、5，在节点10停止。</p>
<p>现在你的任务是，给定FBT的深度D，和I，表示第I个小球下落，你可以假定I不超过给定的FBT的叶子数，写一个程序求小球停止时的叶子序号。</p>
<p>【输入】<br>
一行包含两个用空格隔开的整数D和I。其中2≤D≤20，1≤I≤524288。</p>
<p>【输出】<br>
对应输出第I个小球下落停止时的叶子序号。</p>
<p>【输入样例】<br>
4 2</p>
<p>【输出样例】<br>
12</p>
<hr>
<p>这道题同时还是《算法竞赛入门经典》的6.3二叉树中的题目。</p>
<p>首先来估算数据范围，其中深度最大是20，那么意味着节点的数目是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup><mo>≈</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}\approx 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，所以如果是模拟的化，开这么大的数组也是没问题的，由于每个小球都要走二叉树的深度的次数，所以时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup><mo>×</mo><mn>20</mn><mo>=</mo><mn>1.2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">6 \times 10^ 6 \times 20 = 1.2 \times 10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span>，所以还是在时间限制范围内的。</p>
<p>模拟的方法：由于题目指明是满二叉树，满二叉树一个很重要的性质是左右子节点和父节点存在对应关系，设父节点下标为<code>k</code>，左子节点下标为<code>2k</code>，右子节点下标为<code>2k+1</code>。</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

vector&lt;bool&gt; node(2 * 1e6, false);
int n;

int solve(int num)
{
	int curPos = 1, prePos = 1;
	for (int i = 1; i &lt;= num; ++i) {
		curPos = 1, prePos = 1;
		while (curPos &lt;= n) {
			if (node[curPos]) {
				node[curPos] = false;
				prePos = curPos;
				curPos = curPos * 2 + 1;
			}
			else {
				node[curPos] = true;
				prePos = curPos;
				curPos &lt;&lt;= 1;
			}
		}
	}

	return prePos;
}

int main()
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int depth, num; cin &gt;&gt; depth &gt;&gt; num;
	n = (1 &lt;&lt; depth) - 1; //满二叉树全部节点的个数

	cout &lt;&lt; solve(num) &lt;&lt; endl;

	return 0;
}

</code></pre>
<p>第二种方法：在《算法竞赛入门经典》里面，给出了一种很巧妙的实现，非常类似于约瑟夫环这种类型，往往存在着简单的解法。我们发现对于根节点，也就是标号为1的节点，它为<code>true</code>还是<code>false</code>只和奇偶有关，也就是第一个小球时是<code>false</code>，第三个小球是<code>false</code>。然后类似递归的去解决，比如标号为2的节点，很显然，只有标号为奇数的小球才会落在左子树2，然后我们对这些小球“重新编号”，那么第一个小球是1，第三个小球是2，相当于递归的去解决问题了。这样做的一个好处是根本不需要去开一个大数组去存储树上每个节点的状态，也不需要去做一些没有用处的模拟。另外如果是多组输入的情况下，很显然第二种方法更能节省时间。</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;



int main()
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int depth, num;
	cin &gt;&gt; depth &gt;&gt; num;

	int k = 1;
	for (int i = 0; i &lt; depth - 1; ++i) {
		if (num &amp; 1) { //小球标号为奇数
			k &lt;&lt;= 1; num = ((num + 1) &gt;&gt; 1);
		}
		else { //小球标号为偶数
			k = k * 2 + 1; num &gt;&gt;= 1;
		}
	}
	cout &lt;&lt; k &lt;&lt; endl;

	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1246.Palindrome Removal]]></title>
        <id>https://zyq2652192993zyq.github.io/post/1246palindrome-removal/</id>
        <link href="https://zyq2652192993zyq.github.io/post/1246palindrome-removal/">
        </link>
        <updated>2020-05-10T08:21:00.000Z</updated>
        <content type="html"><![CDATA[<p><strong>文中提到的题目可在我GitHub的<a href="https://github.com/zyq2652192993zyq/LeetCode">LeetCode</a>, <a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge">SJTU OJ</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Algorithm%20Analysis">Algorithm Analysis</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Problem%20Solution">Problem Solution</a>找到解答。</strong></p>
<p>Tags: <code>Hard</code> <code>Dynamic Programming</code></p>
<p>Links: https://leetcode-cn.com/problems/palindrome-removal/</p>
<hr>
<p>Given an integer array <code>arr</code>, in one move you can select a palindromic subarray <code>arr[i], arr[i+1], ..., arr[j]</code> where <code>i &lt;= j</code>, and remove that subarray from the given array. Note that after removing a subarray, the elements on the left and on the right of that subarray move to fill the gap left by the removal.</p>
<p>Return the minimum number of moves needed to remove all numbers from the array.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: arr = [1,2]
Output: 2
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: arr = [1,3,4,1,5]
Output: 3
Explanation: Remove [4] then remove [1,3,1] then remove [5].
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 100</code></li>
<li><code>1 &lt;= arr[i] &lt;= 20</code></li>
</ul>
<hr>
<pre><code class="language-c++">class Solution {
public:
    int minimumMoves(vector&lt;int&gt;&amp; arr) {
        std::ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout.tie(NULL);

        int n = arr.size();
        vector&lt;vector&lt;int&gt;&gt; d(n + 1, vector&lt;int&gt;(n + 1, INT_MAX - 1000));
        //每个字母单独删除需要1次
        d[0][0] = 0;
        for (int i = 1; i &lt;= n; ++i) d[i][i] = 1; 
        for (int i = 1; i &lt;= n; ++i) d[i][i - 1] = 0;

        for (int len = 2; len &lt;= n; ++len) {
            for (int i = 0; i &lt; n - len + 1; ++i) {
                int j = i + len - 1;
                //第i个字母单独删除
                d[i][j] = 1 + d[i + 1][j];
                if (arr[i] == arr[i + 1]) 
                    d[i][j] = min(d[i][j], 1 + d[i + 2][j]);

                for (int k = i + 2; k &lt;= j; ++k) {
                    if (arr[i] == arr[k])
                        d[i][j] = min(d[i][j], d[i + 1][k - 1] + d[k + 1][j]);
                }
            }
        }

        return d[0][n - 1];
    }
};
</code></pre>
<p>数组长度小于100，意味着可能存在多重循环。</p>
<p>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">d[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>代表删除区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[i,j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>的字符的最少操作数。初始<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d[i][i] = 1, d[i][i - 1] = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。其余为较大数值。</p>
<ul>
<li>删除字符的方式可以单独删除，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mo>(</mo><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo separator="true">,</mo><mn>1</mn><mo>+</mo><mi>d</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">d[i][j] = \min (d[i][j], 1 + d[i + 1][j])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></li>
<li>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mo>=</mo><mi>a</mi><mi>r</mi><mi>r</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">arr[i] == arr[i + 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，意味着构成回文串，可以一起删除：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mo>(</mo><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo separator="true">,</mo><mn>1</mn><mo>+</mo><mi>d</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>2</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">d[i][j] = \min (d[i][j], 1 + d[i + 2][j])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>。</li>
<li>另外如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>≥</mo><mi>i</mi><mo>+</mo><mn>2</mn><mo separator="true">,</mo><mi>a</mi><mi>r</mi><mi>r</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mo>=</mo><mi>a</mi><mi>r</mi><mi>r</mi><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">k \geq i + 2, arr[i] == arr[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>，那么意味着<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo separator="true">,</mo><mi>a</mi><mi>r</mi><mi>r</mi><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">arr[i], arr[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>可以和区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[i + 1, k - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>一起删除，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mo>(</mo><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>+</mo><mi>d</mi><mo>[</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">d[i][j] = \min (d[i][j], d[i + 1][k - 1] + d[k + 1][j])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>。</li>
</ul>
<p>注意以下边界条件即可。</p>
<p>另外这道题还是微软的笔试题，可以变化的形式比如改成字符串，方法一样，引起重视。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1443.Minimum Time to Collect All Apples in a Tree]]></title>
        <id>https://zyq2652192993zyq.github.io/post/1443minimum-time-to-collect-all-apples-in-a-tree/</id>
        <link href="https://zyq2652192993zyq.github.io/post/1443minimum-time-to-collect-all-apples-in-a-tree/">
        </link>
        <updated>2020-05-10T08:19:20.000Z</updated>
        <content type="html"><![CDATA[<p><strong>文中提到的题目可在我GitHub的<a href="https://github.com/zyq2652192993zyq/LeetCode">LeetCode</a>, <a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge">SJTU OJ</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Algorithm%20Analysis">Algorithm Analysis</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Problem%20Solution">Problem Solution</a>找到解答。</strong></p>
<p>Tags: <code>Medium</code> <code>Depth-first Search</code></p>
<p>Links: https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/</p>
<hr>
<p>Given an undirected tree consisting of <code>n</code> vertices numbered from 0 to <code>n-1</code>, which has some apples in their vertices. You spend 1 second to walk over one edge of the tree. <em>Return the minimum time in seconds you have to spend in order to collect all apples in the tree starting at <strong>vertex 0</strong> and coming back to this vertex.</em></p>
<p>The edges of the undirected tree are given in the array <code>edges</code>, where <code>edges[i] = [fromi, toi]</code> means that exists an edge connecting the vertices <code>fromi</code> and <code>toi</code>. Additionally, there is a boolean array <code>hasApple</code>, where <code>hasApple[i] = true</code> means that vertex <code>i</code> has an apple, otherwise, it does not have any apple.</p>
<p><strong>Example 1:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2020/04/23/min_time_collect_apple_1.png" alt="img" loading="lazy"></strong></p>
<pre><code>Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]
Output: 8 
Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  
</code></pre>
<p><strong>Example 2:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2020/04/23/min_time_collect_apple_2.png" alt="img" loading="lazy"></strong></p>
<pre><code>Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]
Output: 6
Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]
Output: 0
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>edges.length == n-1</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>0 &lt;= fromi, toi &lt;= n-1</code></li>
<li><code>fromi &lt; toi</code></li>
<li><code>hasApple.length == n</code></li>
</ul>
<hr>
<p>用一个哈希表记录从与<code>from</code>节点直接相连的<code>to</code>节点。函数<code>solve</code>用来计算从<code>startPoint</code>开始采摘苹果所需的时间。递归的终止条件是当前节点的出度为0，也就是到了叶节点。</p>
<p>每个节点遍历一次，时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<pre><code class="language-c++">class Solution {
	unordered_map&lt;int, vector&lt;int&gt;&gt; um;

public:
    int minTime(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;bool&gt;&amp; hasApple) {
    	std::ios_base::sync_with_stdio(false);
		cin.tie(NULL);
		cout.tie(NULL);

		for (auto &amp;e : edges) {
			int from = e[0], to = e[1];
			um[from].push_back(to);
		}

		return solve(hasApple, 0);
    }

    int solve(vector&lt;bool&gt; &amp; hasApple, int startPoint)
    {
    	if (um[startPoint].size() == 0) return 0;

    	int sum = 0;
    	auto &amp; v = um[startPoint];
    	int len = v.size();
    	for (int i = 0; i &lt; len; ++i) {
    		int tmp = solve(hasApple, v[i]);
    		if (tmp || (tmp == 0 &amp;&amp; hasApple[v[i]])) sum += 2 + tmp;
    	}

    	return sum;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1444.Number of Ways of Cutting a Pizza]]></title>
        <id>https://zyq2652192993zyq.github.io/post/1444number-of-ways-of-cutting-a-pizza/</id>
        <link href="https://zyq2652192993zyq.github.io/post/1444number-of-ways-of-cutting-a-pizza/">
        </link>
        <updated>2020-05-10T08:18:31.000Z</updated>
        <content type="html"><![CDATA[<p><strong>文中提到的题目可在我GitHub的<a href="https://github.com/zyq2652192993zyq/LeetCode">LeetCode</a>, <a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge">SJTU OJ</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Algorithm%20Analysis">Algorithm Analysis</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Problem%20Solution">Problem Solution</a>找到解答。</strong></p>
<p>Tags: <code>Hard</code> <code>Dynamic Programming</code></p>
<p>Links: https://leetcode.com/problems/number-of-ways-of-cutting-a-pizza/</p>
<hr>
<p>Given a rectangular pizza represented as a <code>rows x cols</code> matrix containing the following characters: <code>'A'</code> (an apple) and <code>'.'</code> (empty cell) and given the integer <code>k</code>. You have to cut the pizza into <code>k</code> pieces using <code>k-1</code> cuts.</p>
<p>For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.</p>
<p><em>Return the number of ways of cutting the pizza such that each piece contains <strong>at least</strong> one apple.</em> Since the answer can be a huge number, return this modulo 10^9 + 7.</p>
<p><strong>Example 1:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2020/04/23/ways_to_cut_apple_1.png" alt="img" loading="lazy"></strong></p>
<pre><code>Input: pizza = [&quot;A..&quot;,&quot;AAA&quot;,&quot;...&quot;], k = 3
Output: 3 
Explanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: pizza = [&quot;A..&quot;,&quot;AA.&quot;,&quot;...&quot;], k = 3
Output: 1
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: pizza = [&quot;A..&quot;,&quot;A..&quot;,&quot;...&quot;], k = 1
Output: 1
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= rows, cols &lt;= 50</code></li>
<li><code>rows == pizza.length</code></li>
<li><code>cols == pizza[i].length</code></li>
<li><code>1 &lt;= k &lt;= 10</code></li>
<li><code>pizza</code> consists of characters <code>'A'</code> and <code>'.'</code> only.</li>
</ul>
<hr>
<p>无论横切还是竖切，每次都需要统计右下角剩余部分的苹果数，所以需要进行预处理，用二维数组<code>appleNum</code>记录左上角的苹果数，询问右下角的苹果数时通过函数<code>calculate</code><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>得到。如果对于这种方法有疑问，可以通过LeetCode 304.Range Sum Query 2D - Immutable体会。</p>
<p>深搜遍历所有可能的切割方案，用数组<code>d[i][j][k]</code>表示从右下角向上<code>i</code>行，向前<code>j</code>列，切成<code>k</code>块的方案数。初始化为-1，如果搜索中发现<code>d[i][j][k]</code>不为-1，代表此种情况已经计算过了。</p>
<pre><code class="language-c++">class Solution {
    vector&lt;vector&lt;int&gt;&gt; appleNum;
    static const int MODE = 1e9 + 7;
    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; d;
    int m, n; //行数和列数


public:
    int ways(vector&lt;string&gt;&amp; pizza, int k) {
        std::ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout.tie(NULL);

        appleNum.resize(55, vector&lt;int&gt;(55, 0));
        d.resize(55, vector&lt;vector&lt;int&gt;&gt;(55, vector&lt;int&gt;(15, -1)));
        m = pizza.size(), n = pizza[0].size();
        prePorcess(pizza);

        return DFS(m, n, k);
    }

    //预处理计算当前点到矩阵左上角的苹果数量
    void prePorcess(vector&lt;string&gt;&amp; pizza)
    {
        for (int i = 1; i &lt;= m; ++i) {
            for (int j = 1; j &lt;= n; ++j) {
                appleNum[i][j] = appleNum[i - 1][j] + appleNum[i][j - 1] - appleNum[i - 1][j - 1];
                if (pizza[i - 1][j - 1] == 'A') ++appleNum[i][j];
            }
        }
    }

    //计算从右下角向上rowNum行，向前colNum列的苹果数量
    inline int calculate(int rowNum, int colNum)
    {
        return appleNum[m][n] - appleNum[m - rowNum][n] - appleNum[m][n - colNum] + appleNum[m - rowNum][n - colNum];
    }

    //深搜右下角向上rowNum行，向前colNum列，分成k份的方案数
    int DFS(int rowNum, int colNum, int k)
    {
        //如果剩余的情况已经计算过了
        if (d[rowNum][colNum][k] != -1) return d[rowNum][colNum][k];

        //计算右下角剩余的苹果数
        int cnt = calculate(rowNum, colNum);
        //剩余苹果不够k个，无法继续划分
        if (cnt &lt; k) return d[rowNum][colNum][k] = 0;
        //剩余部分划分成1份，只有一种方案
        if (k == 1) return d[rowNum][colNum][k] = 1;

        d[rowNum][colNum][k] = 0;
        //横着切
        for (int i = 1; i &lt; rowNum; ++i) {
            //必须保证切分的上半部分有苹果
            if (cnt == calculate(rowNum - i, colNum)) continue;
            d[rowNum][colNum][k] = (d[rowNum][colNum][k] + DFS(rowNum - i, colNum, k - 1)) % MODE;
        }

        //竖着切
        for (int i = 1; i &lt; colNum; ++i) {
            //必须保证切分的左半部分有苹果
            if (cnt == calculate(rowNum, colNum - i)) continue;
            d[rowNum][colNum][k] = (d[rowNum][colNum][k] + DFS(rowNum, colNum - i, k - 1)) % MODE;
        }

        return d[rowNum][colNum][k];
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1437.Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit]]></title>
        <id>https://zyq2652192993zyq.github.io/post/1437longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/</id>
        <link href="https://zyq2652192993zyq.github.io/post/1437longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">
        </link>
        <updated>2020-05-03T07:28:31.000Z</updated>
        <content type="html"><![CDATA[<p><strong>文中提到的题目可在我GitHub的<a href="https://github.com/zyq2652192993zyq/LeetCode">LeetCode</a>, <a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge">SJTU OJ</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Algorithm%20Analysis">Algorithm Analysis</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Problem%20Solution">Problem Solution</a>找到解答。</strong></p>
<p>Tags: <code>Medium</code>  <code>Array</code> <code>Sliding Window</code></p>
<p>Links: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/</p>
<hr>
<p>Given an array of integers <code>nums</code> and an integer <code>limit</code>, return the size of the longest continuous subarray such that the absolute difference between any two elements is less than or equal to <code>limit</code><em>.</em></p>
<p>In case there is no subarray satisfying the given condition return 0.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [8,2,4,7], limit = 4
Output: 2 
Explanation: All subarrays are: 
[8] with maximum absolute diff |8-8| = 0 &lt;= 4.
[8,2] with maximum absolute diff |8-2| = 6 &gt; 4. 
[8,2,4] with maximum absolute diff |8-2| = 6 &gt; 4.
[8,2,4,7] with maximum absolute diff |8-2| = 6 &gt; 4.
[2] with maximum absolute diff |2-2| = 0 &lt;= 4.
[2,4] with maximum absolute diff |2-4| = 2 &lt;= 4.
[2,4,7] with maximum absolute diff |2-7| = 5 &gt; 4.
[4] with maximum absolute diff |4-4| = 0 &lt;= 4.
[4,7] with maximum absolute diff |4-7| = 3 &lt;= 4.
[7] with maximum absolute diff |7-7| = 0 &lt;= 4. 
Therefore, the size of the longest subarray is 2.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: nums = [10,1,2,4,7,2], limit = 5
Output: 4 
Explanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 &lt;= 5.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: nums = [4,2,2,2,4,4,2,2], limit = 0
Output: 3
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>
<li><code>0 &lt;= limit &lt;= 10^9</code></li>
</ul>
<hr>
<p>用两个双端队列记录区间<code>[pos, i]</code>之间的最大值和最小值，如果区间的最大值和最小值的差值大于<code>limit</code>，那么<code>pos</code>位置右移一个单位，同时去检验最大值队列和最小值队列的首元素的下标是否小于<code>pos</code>，小于<code>pos</code>意味着已经不在窗口<code>[pos, i]</code>之间了，需要删除。</p>
<p>每个元素进队和出队，最多遍历两次，时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>， 空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<pre><code class="language-c++">class Solution {
public:
    int longestSubarray(vector&lt;int&gt;&amp; nums, int limit) {
    	std::ios_base::sync_with_stdio(false);
    	cin.tie(NULL);
    	cout.tie(NULL);

    	int n = nums.size();
    	int pos = 0;
    	deque&lt;int&gt; maxQueue, minQueue;
    	int res = 0;
    	for (int i = 0; i &lt; n; ++i) {
    		while (!maxQueue.empty() &amp;&amp; nums[maxQueue.back()] &lt; nums[i]) maxQueue.pop_back();
    		maxQueue.push_back(i);

    		while (!minQueue.empty() &amp;&amp; nums[minQueue.back()] &gt; nums[i]) minQueue.pop_back();
    		minQueue.push_back(i);

    		while (!maxQueue.empty() &amp;&amp; !minQueue.empty() &amp;&amp; 
    			nums[maxQueue.front()] - nums[minQueue.front()] &gt; limit) {
    			++pos;
    			while (!maxQueue.empty() &amp;&amp; maxQueue.front() &lt; pos) maxQueue.pop_front();
    			while (!minQueue.empty() &amp;&amp; minQueue.front() &lt; pos) minQueue.pop_front();
    		}
    		res = max(res, i - pos + 1);
    	}
    	
    	return res;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1430.Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree]]></title>
        <id>https://zyq2652192993zyq.github.io/post/check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree/</id>
        <link href="https://zyq2652192993zyq.github.io/post/check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree/">
        </link>
        <updated>2020-04-30T10:01:56.000Z</updated>
        <content type="html"><![CDATA[<p><strong>文中提到的题目可在我GitHub的<a href="https://github.com/zyq2652192993zyq/LeetCode">LeetCode</a>, <a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge">SJTU OJ</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Algorithm%20Analysis">Algorithm Analysis</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Problem%20Solution">Problem Solution</a>找到解答。</strong></p>
<p>Tags: <code>Tree</code></p>
<p>Links: https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/532/week-5/3315/</p>
<hr>
<p>Given a binary tree where each path going from the root to any leaf form a <strong>valid sequence</strong>, check if a given string is a <strong>valid sequence</strong> in such binary tree.</p>
<p>We get the given string from the concatenation of an array of integers <code>arr</code> and the concatenation of all values of the nodes along a path results in a <strong>sequence</strong> in the given binary tree.</p>
<p><strong>Example 1:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2019/12/18/leetcode_testcase_1.png" alt="img" style="zoom:50%;" /></strong></p>
<pre><code>Input: root = [0,1,0,0,1,0,null,null,1,0,0], arr = [0,1,0,1]
Output: true
Explanation: 
The path 0 -&gt; 1 -&gt; 0 -&gt; 1 is a valid sequence (green color in the figure). 
Other valid sequences are: 
0 -&gt; 1 -&gt; 1 -&gt; 0 
0 -&gt; 0 -&gt; 0
</code></pre>
<p><strong>Example 2:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2019/12/18/leetcode_testcase_2.png" alt="img" style="zoom:50%;" /></strong></p>
<pre><code>Input: root = [0,1,0,0,1,0,null,null,1,0,0], arr = [0,0,1]
Output: false 
Explanation: The path 0 -&gt; 0 -&gt; 1 does not exist, therefore it is not even a sequence.
</code></pre>
<p><strong>Example 3:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2019/12/18/leetcode_testcase_3.png" alt="img" style="zoom:50%;" /></strong></p>
<pre><code>Input: root = [0,1,0,0,1,0,null,null,1,0,0], arr = [0,1,1]
Output: false
Explanation: The path 0 -&gt; 1 -&gt; 1 is a sequence, but it is not a valid sequence.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 5000</code></li>
<li><code>0 &lt;= arr[i] &lt;= 9</code></li>
<li>Each node's value is between [0 - 9].</li>
</ul>
<hr>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isValidSequence(TreeNode* root, vector&lt;int&gt;&amp; arr) {
        std::ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout.tie(NULL);
        
        int n = arr.size();
        return isValid(root, 0, n - 1, arr);
    }
    
    bool isValid(TreeNode *root, int start, int end, vector&lt;int&gt; &amp; arr)
    {
    	if (start == end &amp;&amp; root &amp;&amp; !root -&gt; left &amp;&amp; !root -&gt; right)
    		return root -&gt; val == arr[start];
        if ((!root &amp;&amp; start &lt;= end) || (root &amp;&amp; start &gt; end)) return false;
        if (root -&gt; val != arr[start]) return false;
        
        bool left = start &lt; end ? isValid(root -&gt; left, start + 1, end, arr) : false;
        bool right = start &lt; end ? isValid(root -&gt; right, start + 1, end, arr) : false;
        return left || right;
    }
};
</code></pre>
<p>数据范围表明序列不为空，并且始终保证<code>start &lt;= end</code>，一种很直接的思路就是检验当前点是否等于数组里对应的元素，于是我们用<code>start</code>来记录检验到数组的哪个位置，<code>end</code>是数组的边界。然后递归的检验树的左右节点。</p>
<p>既然涉及到递归，首先应该考虑递归的终止条件，终止的情况可能有：</p>
<ul>
<li>树遍历到了叶节点（描述叶节点就是检验左右子树是否为空），数组也遍历到了最后一个元素，那么只需检验叶节点的值和数组元素值是否相等</li>
<li>树还没有到叶节点，但是数组已经到了末尾，为<code>false</code></li>
<li>树到了叶节点，但是数组还没有到末尾，为<code>false</code></li>
</ul>
<p>考虑递归中可能存在的问题，因为终止情况已经检验了树节点为空的情况，那么此时树的节点不为空，只需要检验元素是否对应相等即可。最后递归遍历左右子树，结果取或即可。</p>
]]></content>
    </entry>
</feed>