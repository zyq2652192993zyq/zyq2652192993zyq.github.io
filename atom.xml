<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zyq2652192993zyq.github.io/</id>
    <title>Kylin</title>
    <updated>2020-04-28T11:13:57.877Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zyq2652192993zyq.github.io/"/>
    <link rel="self" href="https://zyq2652192993zyq.github.io/atom.xml"/>
    <subtitle>Talk is cheap, show me the code.</subtitle>
    <logo>https://zyq2652192993zyq.github.io/images/avatar.png</logo>
    <icon>https://zyq2652192993zyq.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Kylin</rights>
    <entry>
        <title type="html"><![CDATA[1424.Diagonal Traverse II]]></title>
        <id>https://zyq2652192993zyq.github.io/post/1424diagonal-traverse-ii/</id>
        <link href="https://zyq2652192993zyq.github.io/post/1424diagonal-traverse-ii/">
        </link>
        <updated>2020-04-28T11:13:34.000Z</updated>
        <content type="html"><![CDATA[<p><strong>文中提到的题目可在我GitHub的<a href="https://github.com/zyq2652192993zyq/LeetCode">LeetCode</a>, <a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge">SJTU OJ</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Algorithm%20Analysis">Algorithm Analysis</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Problem%20Solution">Problem Solution</a>找到解答。</strong></p>
<p>Tags: <code>Medium</code> <code>Array</code> <code>Sort</code></p>
<p>Links: https://leetcode.com/problems/diagonal-traverse-ii/</p>
<hr>
<p>Given a list of lists of integers, <code>nums</code>, return all elements of <code>nums</code> in diagonal order as shown in the below images.</p>
<p><strong>Example 1:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2020/04/08/sample_1_1784.png" alt="img" loading="lazy"></strong></p>
<pre><code>Input: nums = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,4,2,7,5,3,8,6,9]
</code></pre>
<p><strong>Example 2:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2020/04/08/sample_2_1784.png" alt="img" loading="lazy"></strong></p>
<pre><code>Input: nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]
Output: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]]
Output: [1,4,2,5,3,8,6,9,7,10,11]
</code></pre>
<p><strong>Example 4:</strong></p>
<pre><code>Input: nums = [[1,2,3,4,5,6]]
Output: [1,2,3,4,5,6]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i].length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i][j] &lt;= 10^9</code></li>
<li>There at most <code>10^5</code> elements in <code>nums</code>.</li>
</ul>
<hr>
<p>一看到对角线，我的第一反应是八皇后问题。在八皇后问题里，判断是否在同一主对角线还是同一次对角线时，主对角线上满足<code>行号 - 列号</code>差值相同，次对角线上满足<code>行号 + 列号</code>总和相同。</p>
<p>本题仅仅涉及次对角线，所以在同意对角线上的元素，必然满足<code>i+j</code>的值相同，其中<code>i</code>是行号，<code>j</code>是列号。那么只需要用一个<code>unordered_map</code>统计<code>i+j</code>对应的元素有哪些，注意点是输出的顺序是从左下到右上，那么就需要每个数组逆序输出。如果题目变化一下，从右上到左下输出，就每个数组正序输出即可，灵活掌握。</p>
<p>数组里的每个元素遍历两遍，设元素总数是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>，时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt;&gt;&amp; nums) {
        std::ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout.tie(NULL);

        int n = nums.size();
        unordered_map&lt;int, vector&lt;int&gt;&gt; um;
        int maxSum = 0;
        for (int i = 0; i &lt; n; ++i) {
        	for (int j = 0; j &lt; nums[i].size(); ++j) {
        		um[i + j].push_back(nums[i][j]);
        		maxSum = max(maxSum, i + j);
        	}
        }

        vector&lt;int&gt; res;
        for (int i = 0; i &lt;= maxSum; ++i) {
        	for (int j = (int)um[i].size() - 1; j &gt;= 0; --j) {
        		res.push_back(um[i][j]);
        	}
        }

        return res;
    }	
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1423.Maximum Points You Can Obtain from Cards]]></title>
        <id>https://zyq2652192993zyq.github.io/post/1423maximum-points-you-can-obtain-from-cards/</id>
        <link href="https://zyq2652192993zyq.github.io/post/1423maximum-points-you-can-obtain-from-cards/">
        </link>
        <updated>2020-04-28T11:11:56.000Z</updated>
        <content type="html"><![CDATA[<p><strong>文中提到的题目可在我GitHub的<a href="https://github.com/zyq2652192993zyq/LeetCode">LeetCode</a>, <a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge">SJTU OJ</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Algorithm%20Analysis">Algorithm Analysis</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Problem%20Solution">Problem Solution</a>找到解答。</strong></p>
<p>Tags: <code>Medium</code> <code>Sliding Windows</code> <code>Dynamic Programming</code></p>
<p>Links: https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/</p>
<hr>
<p>There are several cards <strong>arranged in a row</strong>, and each card has an associated number of points The points are given in the integer array <code>cardPoints</code>.</p>
<p>In one step, you can take one card from the beginning or from the end of the row. You have to take exactly <code>k</code> cards.</p>
<p>Your score is the sum of the points of the cards you have taken.</p>
<p>Given the integer array <code>cardPoints</code> and the integer <code>k</code>, return the <em>maximum score</em> you can obtain.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: cardPoints = [1,2,3,4,5,6,1], k = 3
Output: 12
Explanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: cardPoints = [2,2,2], k = 2
Output: 4
Explanation: Regardless of which two cards you take, your score will always be 4.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: cardPoints = [9,7,7,9,7,7,9], k = 7
Output: 55
Explanation: You have to take all the cards. Your score is the sum of points of all cards.
</code></pre>
<p><strong>Example 4:</strong></p>
<pre><code>Input: cardPoints = [1,1000,1], k = 1
Output: 1
Explanation: You cannot take the card in the middle. Your best score is 1. 
</code></pre>
<p><strong>Example 5:</strong></p>
<pre><code>Input: cardPoints = [1,79,80,1,1,1,200,1], k = 3
Output: 202
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= cardPoints.length &lt;= 10^5</code></li>
<li><code>1 &lt;= cardPoints[i] &lt;= 10^4</code></li>
<li><code>1 &lt;= k &lt;= cardPoints.length</code></li>
</ul>
<hr>
<p>第一眼看到这个题，联想到了《挑战程序设计竞赛》2.2.3字典序最小问题的例题，POJ 3617 Best Cow Line，贪心的方法，但是很容易举出测试用例来否定贪心的方法：</p>
<pre><code>3 2 1 100 1
k = 2
</code></pre>
<p>那么换一种思路，究竟在在<code>i</code>次选择（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">1 \leq i \leq k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>）从需要首部取还是尾部取得顺序，对于最终结果无影响，但是必须满足假如从首部取走<code>n</code>张卡片，那么这<code>n</code>张必须是连续的。连续的子数组，就可以联想到双指针的解法。</p>
<p>第一次遍历，从头开始计算前<code>k</code>个数的和，然后用一个指针<code>end</code>指向序列尾端的后一个位置，代表最开始全部从首部选择，然后<code>end</code>逐渐向首部移动，每次移动一个单位，当<code>end</code>移动<code>k</code>个单位的时候，代表此时全部从尾部取。</p>
<p>那么其实只需要用一个变量<code>sum</code>来维护从首部取得元素得总和，每次减去一个元素，再用<code>tail</code>维护尾部的元素总和，每次增加一个元素。</p>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>.</p>
<pre><code class="language-c++">class Solution {
public:
    int maxScore(vector&lt;int&gt;&amp; cardPoints, int k) {
    	std::ios_base::sync_with_stdio(false);
    	cin.tie(NULL);
    	cout.tie(NULL);

    	int n = cardPoints.size();
    	int sum = 0;
    	for (int i = 0; i &lt; k; ++i) sum += cardPoints[i];
    	int maxVal = sum;

    	int end = n;
    	int tail = 0;
    	for (int i = k - 1; i &gt;= 0; --i) {
    		sum -= cardPoints[i];
    		tail += cardPoints[--end];

    		maxVal = max(maxVal, sum + tail);
    	}

    	return maxVal;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1419.Minimum Number of Frogs Croaking]]></title>
        <id>https://zyq2652192993zyq.github.io/post/1419minimum-number-of-frogs-croaking/</id>
        <link href="https://zyq2652192993zyq.github.io/post/1419minimum-number-of-frogs-croaking/">
        </link>
        <updated>2020-04-28T11:11:15.000Z</updated>
        <content type="html"><![CDATA[<p><strong>文中提到的题目可在我GitHub的<a href="https://github.com/zyq2652192993zyq/LeetCode">LeetCode</a>, <a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge">SJTU OJ</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Algorithm%20Analysis">Algorithm Analysis</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Problem%20Solution">Problem Solution</a>找到解答。</strong></p>
<p>Tags: <code>Medium</code> <code>String</code></p>
<p>Links: https://leetcode.com/problems/minimum-number-of-frogs-croaking/</p>
<hr>
<p>Given the string <code>croakOfFrogs</code>, which represents a combination of the string &quot;croak&quot; from different frogs, that is, multiple frogs can croak at the same time, so multiple “croak” are mixed. <em>Return the minimum number of</em> different <em>frogs to finish all the croak in the given string.</em></p>
<p>A valid &quot;croak&quot; means a frog is printing 5 letters ‘c’, ’r’, ’o’, ’a’, ’k’ <strong>sequentially</strong>. The frogs have to print all five l</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: croakOfFrogs = &quot;croakcroak&quot;
Output: 1 
Explanation: One frog yelling &quot;croak&quot; twice.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: croakOfFrogs = &quot;crcoakroak&quot;
Output: 2 
Explanation: The minimum number of frogs is two. 
The first frog could yell &quot;crcoakroak&quot;.
The second frog could yell later &quot;crcoakroak&quot;.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: croakOfFrogs = &quot;croakcrook&quot;
Output: -1
Explanation: The given string is an invalid combination of &quot;croak&quot; from different frogs.
</code></pre>
<p><strong>Example 4:</strong></p>
<pre><code>Input: croakOfFrogs = &quot;croakcroa&quot;
Output: -1
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= croakOfFrogs.length &lt;= 10^5</code></li>
<li>All characters in the string are: <code>'c'</code>, <code>'r'</code>, <code>'o'</code>, <code>'a'</code> or <code>'k'</code>.</li>
</ul>
<hr>
<pre><code class="language-c++">class Solution {
	unordered_map&lt;char, int&gt; um;
public:
    int minNumberOfFrogs(string croakOfFrogs) {
    	std::ios_base::sync_with_stdio(false);
    	cin.tie(NULL);
    	cout.tie(NULL);

    	um['c'] = 0; um['r'] = 1; um['o'] = 2; um['a'] = 3; um['k'] = 4;
    	unordered_map&lt;int, stack&lt;string&gt;&gt; hashTable;
    	int n = croakOfFrogs.size();

    	for (int i = 0; i &lt; n; ++i) {
    		if (croakOfFrogs[i] == 'c') {
    			if (hashTable[4].empty()) hashTable[0].push(&quot;c&quot;);
    			else {
    				hashTable[4].top().push_back('c');
    				hashTable[0].push(hashTable[4].top());
    				hashTable[4].pop();
    			}
    		}
    		else {
    			char ch = croakOfFrogs[i];
    			int k = um[ch] - 1;
    			if (hashTable[k].empty()) return -1;
    			else {
    				hashTable[k].top().push_back(ch);
    				hashTable[um[ch]].push(hashTable[k].top());
    				hashTable[k].pop();
    			}
    		}
    	}

    	for (int i = 0; i &lt; 4; ++i) if (hashTable[i].size() != 0) return -1;

    	return hashTable[4].size();
    }
};
</code></pre>
<p>这道题目最初的思路是利用递归去解决，比如题目里的样例：<code>crcoakroak</code></p>
<p>利用一个字符串变量<code>s</code>保存合法的结果，<code>tmp</code>保存剩余的部分，运行规则就是：</p>
<pre><code>crcoakroak
cr 放入 s
c 放入 tmp
oak 放入 s
roak 放入 tmp
最后s = croak, tmp = croak
首先检验s的长度是否是5的倍数，然后递归去处理tmp
</code></pre>
<p>这种思路符合人为处理的思路，但是考虑特殊情况，比如<code>ccccrrrrooooaaaakkkk</code>，每一次处理都需要把整个字符串遍历一次，数据范围是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>，不出意外会超时。所以考虑对其进行优化。</p>
<p>发现字符串的拼接规则其实之和对应字母的前一个字母有关，比如我处理到字符<code>r</code>，那么就应该把它拼接到任何一个以<code>c</code>结尾的字符串后面（如果这个字符串存在的话，不存在直接返回-1），那么如何描述这种前后拼接的关系？于是想到可以利用哈希表来将字符和数字进行映射，所以用<code>um</code>来建立这种映射关系。</p>
<p>接着建立一个哈希表，键是以字符串结尾的字符对应的数字：</p>
<pre><code>0 对应以c结尾的字符串
1 对应以r结尾的字符串
2 对应以o结尾的字符串
3 对应以c结尾的字符串
4 对应以k结尾的字符串
</code></pre>
<p>哈希表的值利用一个栈来存储以对应字符结尾的字符串。然后对题目中的样例来处理，展示算法的运行逻辑。</p>
<p>比如<code>crcoakroak</code>：</p>
<pre><code>处理'c'，发现0对应的栈为空，直接推入

处理'r'，应该接到以'c'结尾的字符串后面，于是把最初的'c'后面拼接'r'，然后放入到键为1的栈内

处理'c'，发现0对应的栈为空，直接推入

处理'o'，应该接到以'r'结尾的字符串，于是取出1对应的栈内的字符串，放入2对应的栈内
.....
</code></pre>
<p>最后需要先检验序号为0，1，2，3内的栈是否为空，不为空意味着还是存在有的字符串没有拼接，于是返回<code>-1</code>；如果都为空，那么就只需返回栈4内字符串的数量即可。</p>
<p>看了大佬<code>wzc1995</code>的解答，发现其实还可以进一步优化程序，并不需要真正的完成字符串的拼接，完全可以用一个计数器来进行模拟。</p>
<p>优化后的程序：</p>
<pre><code class="language-c++">class Solution {
	unordered_map&lt;char, int&gt; um;
public:
    int minNumberOfFrogs(string croakOfFrogs) {
    	std::ios_base::sync_with_stdio(false);
    	cin.tie(NULL);
    	cout.tie(NULL);

    	um['c'] = 0; um['r'] = 1; um['o'] = 2; um['a'] = 3; um['k'] = 4;
    	unordered_map&lt;int, int&gt; hashTable;
    	int n = croakOfFrogs.size();

    	for (int i = 0; i &lt; n; ++i) {
    		if (croakOfFrogs[i] == 'c') {
    			if (hashTable[4] == 0) ++hashTable[0];
    			else {
    				++hashTable[0];
    				--hashTable[4];
    			}
    		}
    		else {
    			char ch = croakOfFrogs[i];
    			int k = um[ch] - 1;
    			if (hashTable[k] == 0) return -1;
    			else {
    				++hashTable[um[ch]];
    				--hashTable[k];
    			}
    		}
    	}

    	for (int i = 0; i &lt; 4; ++i) if (hashTable[i] != 0) return -1;

    	return hashTable[4];
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1411.Number of Ways to Paint N × 3 Grid]]></title>
        <id>https://zyq2652192993zyq.github.io/post/1411number-of-ways-to-paint-n-x-3-grid/</id>
        <link href="https://zyq2652192993zyq.github.io/post/1411number-of-ways-to-paint-n-x-3-grid/">
        </link>
        <updated>2020-04-28T11:09:06.000Z</updated>
        <content type="html"><![CDATA[<p><strong>文中提到的题目可在我GitHub的<a href="https://github.com/zyq2652192993zyq/LeetCode">LeetCode</a>, <a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge">SJTU OJ</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Algorithm%20Analysis">Algorithm Analysis</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Problem%20Solution">Problem Solution</a>找到解答。</strong></p>
<p>Tags: <code>Hard</code> <code>Dynamic Programming</code> <code>Math</code></p>
<p>Links: https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid/</p>
<hr>
<p>You have a <code>grid</code> of size <code>n x 3</code> and you want to paint each cell of the grid with exactly one of the three colours: <strong>Red</strong>, <strong>Yellow</strong> or <strong>Green</strong> while making sure that no two adjacent cells have the same colour (i.e no two cells that share vertical or horizontal sides have the same colour).</p>
<p>You are given <code>n</code> the number of rows of the grid.</p>
<p>Return <em>the number of ways</em> you can paint this <code>grid</code>. As the answer may grow large, the answer <strong>must be</strong> computed modulo <code>10^9 + 7</code>.</p>
<p>![img](F:\Project\LeetCode\Dynamica Programming\e1.png)</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: n = 1
Output: 12
Explanation: There are 12 possible way to paint the grid as shown:
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: n = 2
Output: 54
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: n = 3
Output: 246
</code></pre>
<p><strong>Example 4:</strong></p>
<pre><code>Input: n = 7
Output: 106494
</code></pre>
<p><strong>Example 5:</strong></p>
<pre><code>Input: n = 5000
Output: 30228214
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>n == grid.length</code></li>
<li><code>grid[i].length == 3</code></li>
<li><code>1 &lt;= n &lt;= 5000</code></li>
</ul>
<hr>
<pre><code class="language-c++">class Solution {
public:
    int numOfWays(int n) {
        std::ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout.tie(NULL);
        
        const long long MODE = 1e9 + 7;
        
        long long equal = 6, notEqual = 6;
        if (n == 1) return 12;
        long long res;
        for (int i = 2; i &lt;= n; ++i) {
            res = (equal * 5 % MODE + notEqual * 4 % MODE) % MODE;
            long long a = equal, b = notEqual;
            equal = (a * 3 % MODE + b * 2 % MODE) % MODE;
            notEqual = (a * 2 % MODE + b * 2 % MODE) % MODE;
        }

        return res;
    }
};
</code></pre>
<p>假设三种颜色用ABC分别表示，那么当<code>n = 1</code>的时候，有<code>3 * 2 * 2 = 12</code>种，当<code>n = 2</code>的时候，前一种的排列方式会对后面产生影响，仅仅以假设第一行的前两个染色为<code>AB</code>，考察后面的染色：</p>
<pre><code>如果第一行最后一个和第一行第一个同色，即ABA
那么第二行可能的染色方案是：
BAB	BAC	CAB	CAC	BCB

如果第一行最后一个的染色和第一行第一个不是同色，
那么第二行可能的染色方案是：
BCA	BCB BAB CAB
</code></pre>
<p>这时候发现规律，如果第二行出现<code>BAB</code>，那么和第一行出现<code>ABA</code>所得结果种类是一样的，于是发现，<code>n+1</code>的染色方案和第<code>n</code>行最后一个和第<code>n</code>行第一个染色是否同色有关，于是找到规律，每一个同色的方案会产生5种方案，其中3种同色方案和2种不同色方案；每一个不同色方案会产生2种同色方案和2种非同色方案。</p>
<p>经过上面的分析，发现只需要维护每一行同色的方案数量和不同色的方案数量，分别用变量<code>equal</code>和<code>notEqual</code>来维护，则<code>n + 1</code>的方案数是<code>equal * 5 + notEqual * 4</code>，记得更新<code>equal</code>和<code>notEqual</code>的数值，以及可能产生的溢出问题。</p>
<p>另外以染色为背景的题目还有：</p>
<ul>
<li>HDU 2045 不容易系列之(3)—— LELE的RPG难题（染色类型问题）</li>
<li>UVA 11916 - Emoogle Grid（虽然是染色背景，但是考察的是数论）可以和前面两个染色问题关联起来思考。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1410.HTML Entity Parser]]></title>
        <id>https://zyq2652192993zyq.github.io/post/1410html-entity-parser/</id>
        <link href="https://zyq2652192993zyq.github.io/post/1410html-entity-parser/">
        </link>
        <updated>2020-04-28T11:08:25.000Z</updated>
        <content type="html"><![CDATA[<p><strong>文中提到的题目可在我GitHub的<a href="https://github.com/zyq2652192993zyq/LeetCode">LeetCode</a>, <a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge">SJTU OJ</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Algorithm%20Analysis">Algorithm Analysis</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Problem%20Solution">Problem Solution</a>找到解答。</strong></p>
<p>Tags: <code>Medium</code> <code>String</code> <code>Stack</code></p>
<p>Links: https://leetcode.com/problems/html-entity-parser/</p>
<hr>
<p><strong>HTML entity parser</strong> is the parser that takes HTML code as input and replace all the entities of the special characters by the characters itself.</p>
<p>The special characters and their entities for HTML are:</p>
<ul>
<li><strong>Quotation Mark:</strong> the entity is <code>&quot;</code> and symbol character is <code>&quot;</code>.</li>
<li><strong>Single Quote Mark:</strong> the entity is <code>'</code> and symbol character is <code>'</code>.</li>
<li><strong>Ampersand:</strong> the entity is <code>&amp;</code> and symbol character is <code>&amp;</code>.</li>
<li><strong>Greater Than Sign:</strong> the entity is <code>&gt;</code> and symbol character is <code>&gt;</code>.</li>
<li><strong>Less Than Sign:</strong> the entity is <code>&lt;</code> and symbol character is <code>&lt;</code>.</li>
<li><strong>Slash:</strong> the entity is <code>⁄</code> and symbol character is <code>/</code>.</li>
</ul>
<p>Given the input <code>text</code> string to the HTML parser, you have to implement the entity parser.</p>
<p>Return <em>the text</em> after replacing the entities by the special characters.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: text = &quot;&amp;amp; is an HTML entity but &amp;ambassador; is not.&quot;
Output: &quot;&amp; is an HTML entity but &amp;ambassador; is not.&quot;
Explanation: The parser will replace the &amp;amp; entity by &amp;
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: text = &quot;and I quote: &amp;quot;...&amp;quot;&quot;
Output: &quot;and I quote: \&quot;...\&quot;&quot;
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: text = &quot;Stay home! Practice on Leetcode :)&quot;
Output: &quot;Stay home! Practice on Leetcode :)&quot;
</code></pre>
<p><strong>Example 4:</strong></p>
<pre><code>Input: text = &quot;x &amp;gt; y &amp;amp;&amp;amp; x &amp;lt; y is always false&quot;
Output: &quot;x &gt; y &amp;&amp; x &lt; y is always false&quot;
</code></pre>
<p><strong>Example 5:</strong></p>
<pre><code>Input: text = &quot;leetcode.com&amp;frasl;problemset&amp;frasl;all&quot;
Output: &quot;leetcode.com/problemset/all&quot;
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= text.length &lt;= 10^5</code></li>
<li>The string may contain any possible characters out of all the 256 ASCII characters.</li>
</ul>
<hr>
<pre><code class="language-c++">class Solution {
public:
    string entityParser(string text) {
        std::ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout.tie(NULL);

        string res;
        int n = text.size();
        int pos = 0; 
        while (pos &lt; n) {
            if (text[pos] == '&amp;') {
                if (text.substr(pos, 6) == &quot;&amp;quot;&quot;) {
                    res += &quot;\&quot;&quot;;
                    pos += 6;
                }
                else if (text.substr(pos, 6) == &quot;&amp;apos;&quot;) {
                    res += &quot;'&quot;;
                    pos += 6;
                }
                else if (text.substr(pos, 5) == &quot;&amp;amp;&quot;) {
                    res.push_back('&amp;');
                    pos += 5;
                }
                else if (text.substr(pos, 4) == &quot;&amp;gt;&quot;) {
                    res.push_back('&gt;');
                    pos += 4;
                }
                else if (text.substr(pos, 4) == &quot;&amp;lt;&quot;) {
                    res.push_back('&lt;'); pos += 4;
                }
                else if (text.substr(pos, 7) == &quot;&amp;frasl;&quot;) {
                    res.push_back('/'); pos += 7;
                }
                else {
                    res.push_back('&amp;'); ++pos;
                }
            }
            else {
                res.push_back(text[pos]);
                ++pos;
            }
        }

        return res;
    }
};
</code></pre>
<p>如果之前关注过《C++ Primer》校审的叶劲峰老师的GitHub，其中就有一个关于<code>json parser</code>的小练习，接触过再来看这道题就不会觉得很陌生。</p>
<p>这个非常类似于写一个<code>json parser</code>的思路，写<code>json parser</code>每次只需要根据字符串的首字母就可以很方便的确定后续内容，这个题目同理，发现每一个特殊字符的第一个字符的开头都是<code>&amp;</code>，所以就可以据此判断。另外为什么不选取<code>&amp;</code>后一个字符作为进一步判断，因为比如<code>&amp;apos;</code>和<code>&amp;amp;</code>，就需要额外判断两个字符，代码写起来不是很优雅，所以直接<code>substr</code>。</p>
<p>另外以HTML为背景的题目</p>
<ul>
<li>POJ 2271 HTML</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1377.Frog Position After T Seconds]]></title>
        <id>https://zyq2652192993zyq.github.io/post/1377frog-position-after-t-seconds/</id>
        <link href="https://zyq2652192993zyq.github.io/post/1377frog-position-after-t-seconds/">
        </link>
        <updated>2020-04-28T11:07:41.000Z</updated>
        <content type="html"><![CDATA[<p><strong>文中提到的题目可在我GitHub的<a href="https://github.com/zyq2652192993zyq/LeetCode">LeetCode</a>, <a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge">SJTU OJ</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Algorithm%20Analysis">Algorithm Analysis</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Problem%20Solution">Problem Solution</a>找到解答。</strong></p>
<p>Tags: <code>Hard</code> <code>Depth-first Search</code></p>
<p>Company: <code>Google</code></p>
<p>Years: <code>1~2</code></p>
<p>Links: <a href="https://leetcode.com/problems/frog-position-after-t-seconds/">https://leetcode.com/problems/frog-position-after-t-seconds/</a></p>
<hr>
<p>Given an undirected tree consisting of <code>n</code> vertices numbered from 1 to <code>n</code>. A frog starts jumping from the <strong>vertex 1</strong>. In one second, the frog jumps from its current vertex to another <strong>unvisited</strong> vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices it jumps randomly to one of them with the same probability, otherwise, when the frog can not jump to any unvisited vertex it jumps forever on the same vertex.</p>
<p>The edges of the undirected tree are given in the array <code>edges</code>, where <code>edges[i] = [fromi, toi]</code> means that exists an edge connecting directly the vertices <code>fromi</code> and <code>toi</code>.</p>
<p><em>Return the probability that after t seconds the frog is on the vertex target.</em></p>
<p><strong>Example 1:</strong></p>
<figure data-type="image" tabindex="1"><img src="https://assets.leetcode.com/uploads/2020/02/20/frog_2.png" alt="img" loading="lazy"></figure>
<pre><code>Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4
Output: 0.16666666666666666 
Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. 
</code></pre>
<p><strong>Example 2:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2020/02/20/frog_3.png" alt="img" loading="lazy"></strong></p>
<pre><code>Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7
Output: 0.3333333333333333
Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1. 
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 20, target = 6
Output: 0.16666666666666666
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li><code>edges.length == n-1</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>1 &lt;= edges[i][0], edges[i][1] &lt;= n</code></li>
<li><code>1 &lt;= t &lt;= 50</code></li>
<li><code>1 &lt;= target &lt;= n</code></li>
<li>Answers within <code>10^-5</code> of the actual value will be accepted as correct.</li>
</ul>
<hr>
<pre><code class="language-c++">class Solution {
public:
    double frogPosition(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int t, int target) {
        std::ios_base::sync_with_stdio(false);
		cin.tie(NULL);
		cout.tie(NULL);
		//特殊情况，只有1个节点
		if (edges.size() == 0) {
			return 1;
		}

		vector&lt;vector&lt;int&gt;&gt; ground(n + 1); //无向图的邻接表表示
		for (auto e : edges) {
			int from = e[0];
			int to = e[1];
			ground[from].push_back(to);
			ground[to].push_back(from);
		}

		vector&lt;int&gt; used(n + 1, -1); //记录节点是否被使用，同时记录跳跃的距离
		vector&lt;int&gt; pre(n + 1, -1); //记录当前节点是从哪个节点跳跃过来
		queue&lt;int&gt; q;
		q.push(target);
		used[target] = 0;

		while (!q.empty()) {
			int from = q.front(); q.pop();
			for (int i = 0; i &lt; ground[from].size(); ++i) {
				int tmp = ground[from][i];
				if (used[tmp] == -1) {
					q.push(tmp);
					used[tmp] = used[from] + 1;
					pre[tmp] = from;
					if (tmp == 1) break;
				}
			}
		}
        //如果节点1和target不相连，或者最少跳跃的时间大于t，输出0
		if (pre[1] == -1 || used[1] &gt; t) return 0;
        //保存从节点1到taget的时间，因为used接下来会被初始化再利用
		int pathLen = used[1];

		long long sum = 1; //防止相乘出现溢出
		int start = 1;
		fill(used.begin(), used.end(), 0);

		while (pre[start] != -1) {
			used[start] = 1;
			long long cnt = 0;
			for (int i = 0; i &lt; ground[start].size(); ++i) {
				int to = ground[start][i];
				if (!used[to]) ++cnt;
			}
			sum *= cnt;
			start = pre[start];
		}
        //pathLen != t意味着可能存在继续跳跃的可能
        //检验是否存在从target还能继续跳到其他点
		if (pathLen != t) {
			for (int i = 0; i &lt; ground[target].size(); ++i) {
				int to = ground[target][i];
				if (!used[to]) return 0;
			}
		}

		return 1.0 / sum;
    }
};
</code></pre>
<p>这道题虽然给的标签是DFS，但是我采用的是BFS来求解。</p>
<p>这道题首先去明确题意，从节点<code>1</code>出发，到节点标记为<code>target</code>的点，从一个节点跳到另一个节点耗时1秒，问能否在规定的时间<code>t</code>内到达。容易引发错误的是跳跃规则的限制，首先已经经过的点是不能再跳了，另外，如果在时间<code>t</code>内已经到达<code>target</code>，但是已经没有其他的点可以继续跳跃了，那么就原地不动。后一个条件就容易引发错误，考虑这样一个例子：</p>
<pre><code>n = 8, edges = [[1,2],[1,7],[1,4],[1,5],[7,8],[2,3],[4,6]], t = 20, target = 7
Output: 0.0
</code></pre>
<p>这是因为第一步就可以跳到<code>target = 7</code>，这里只用了1秒，还未到时间<code>t</code>，所以还可以继续跳跃到节点8，无法再跳跃了，于是落在了节点8，不符合题目要求了。</p>
<p>分析清楚了题意，那么问题的关键点就是最少需要跳多少步可以从节点1到节点<code>target</code>，所以很自然的联想到了BFS，但是还需要额外输出路径。这是因为我们最终要计算的是概率，不妨以第一个测试用例为例：</p>
<figure data-type="image" tabindex="2"><img src="https://assets.leetcode.com/uploads/2020/02/20/frog_2.png" alt="img" loading="lazy"></figure>
<pre><code>Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7
Output: 0.3333333333333333
</code></pre>
<p>从节点1到节点<code>target = 4</code>，节点1的跳跃选择有3个，从节点2的跳跃选择有2个，所以最终结果就是<code>1/(2*3)=1/6</code>。可以发现，分母恰好是每一次跳跃时，当前节点的可以选择跳跃的节点个数，所以只有确切的知道整个跳跃过程经过了哪些点，才能够统计可以跳跃的节点个数。</p>
<p>注意到给出的图是无向图，那么我们可以采用邻接表来表示图，用数组<code>used</code>来记录当前点是否被访问过，同时用来记录从出发点到终点的距离。在BFS过程中，可以从<code>target</code>出发找节点1，也可以从节点1出发找<code>target</code>，我选择是前一种。</p>
<p>当得到节点1和<code>target</code>的距离<code>used[1]</code>后，我们用变量<code>pathLen</code>来存储这个数据。如果节点1和target不相连，或者最少跳跃的时间大于t，输出0；如果<code>used[1] &lt;= t</code>，就需要去处理达到<code>target</code>还可以继续跳跃的情况了，那么这时候就再次利用<code>used</code>数组，标记已经经过的点。用<code>sum</code>来记录最终结果的分母，注意防止溢出。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[115.Distinct Subsequences]]></title>
        <id>https://zyq2652192993zyq.github.io/post/115distinct-subsequences/</id>
        <link href="https://zyq2652192993zyq.github.io/post/115distinct-subsequences/">
        </link>
        <updated>2020-04-28T11:06:28.000Z</updated>
        <content type="html"><![CDATA[<p><strong>文中提到的题目可在我GitHub的<a href="https://github.com/zyq2652192993zyq/LeetCode">LeetCode</a>, <a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge">SJTU OJ</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Algorithm%20Analysis">Algorithm Analysis</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Problem%20Solution">Problem Solution</a>找到解答。</strong></p>
<p>Tags: <code>Hard</code> <code>Dynamic Programming</code></p>
<p>Links: https://leetcode.com/problems/distinct-subsequences/</p>
<hr>
<p>Given a string <strong>S</strong> and a string <strong>T</strong>, count the number of distinct subsequences of <strong>S</strong> which equals <strong>T</strong>.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).</p>
<p>It's guaranteed the answer fits on a 32-bit signed integer.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: S = &quot;rabbbit&quot;, T = &quot;rabbit&quot;
Output: 3
Explanation:
As shown below, there are 3 ways you can generate &quot;rabbit&quot; from S.
(The caret symbol ^ means the chosen letters)

rabbbit
^^^^ ^^
rabbbit
^^ ^^^^
rabbbit
^^^ ^^^
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: S = &quot;babgbag&quot;, T = &quot;bag&quot;
Output: 5
Explanation:
As shown below, there are 5 ways you can generate &quot;bag&quot; from S.
(The caret symbol ^ means the chosen letters)

babgbag
^^ ^
babgbag
^^    ^
babgbag
^    ^^
babgbag
  ^  ^^
babgbag
    ^^^
</code></pre>
<hr>
<h1 id="解法一动态规划">解法一：动态规划</h1>
<pre><code class="language-c++">class Solution {
public:
    int numDistinct(string s, string t) {
        std::ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout.tie(NULL);

        int m = s.size(), n = t.size();
        vector&lt;vector&lt;long long&gt;&gt; d(m + 1, vector&lt;long long&gt;(n + 1, 0));
        d[0][0] = 1;
        int cnt = 0;
        for (int i = 1; i &lt;= m; ++i) {
        	if (s[i - 1] == t[0]) ++cnt;
        	d[i][1] = cnt;
        }

        for (int i = 1; i &lt;= m; ++i) {
            for (int j = 2; j &lt;= i &amp;&amp; j &lt;= n; ++j) {
                if (s[i - 1] == t[j - 1]) d[i][j] = d[i - 1][j - 1] + d[i - 1][j];
                else d[i][j] = d[i - 1][j];
            }
        }

        return d[m][n];
    }
};
</code></pre>
<p>题目的意思是给定字符串<code>s</code>和<code>t</code>，问在<code>s</code>中不连续的子串中有多少个和<code>t</code>完全匹配，本质上还是一个匹配问题。</p>
<p>首先思考连续的时候是怎么处理，很显然字符串哈希和KMP都可以解决，不连续情况多半就是动态规划了。</p>
<p>用<code>d[i][j]</code>表示<code>s</code>的前<code>i</code>个字符包含<code>t</code>前<code>j</code>个字符的个数，状态转移方程需要考虑<code>s</code>的第<code>i</code>个字符和<code>t</code>的第<code>j</code>个字符是否匹配。</p>
<ul>
<li>
<p>如果<code>s[i - 1] != t[j - 1]</code>，那么那么只能是前<code>i-1</code>个字符和<code>t</code>的前<code>j</code>个字符进行计算，所以<code>d[i][j] = d[i-1][j]</code>。</p>
</li>
<li>
<p>如果匹配，那么存在如下例子</p>
</li>
</ul>
<pre><code>第一个例子
s = abb
t = ab
很显然出现次数是2

第二个例子
s = aab
t = ab
很显然出现次数是2
</code></pre>
<p>所以<code>s[i - 1] == t[j - 1]</code>的时候存在两种情况：</p>
<ol>
<li><code>s[i - 1]</code>和<code>t[j - 1]</code>完成匹配，于是只需要计算<code>d[i-1][j-1]</code>，第二个例子</li>
<li><code>s[i-1]</code>属于重复的部分，第一个例子，那么需要计算<code>d[i - 1][j]</code></li>
</ol>
<p>所以<code>d[i][j]</code>就是两种情况的总和。</p>
<p>接下来就是很重要的初始化过程了，对于很多情况，比如<code>d[0][0]</code>究竟该怎么初始化会存在一些疑惑，那么最简单的判断方法就是举个例子，看看自己循环里是否会使用到<code>d[0][0]</code>，以及<code>d[0][0]</code>对程序的影响，那么就很容易判断<code>d[0][0] =1</code>还是0了。需要对<code>t</code>里的第一个字符进行特判。</p>
<p>另外最开始自己把14行的程序放在了<code>if</code>条件里面，下面这个样例就会错误：</p>
<pre><code>s = aabb
t = ab
结果为4
</code></pre>
<p>如果把14行放在<code>if</code>里面，结果就是2，原因在于当<code>s</code>的第一个<code>b</code>和<code>t</code>里的<code>a</code>计算时，无法完成匹配，会让对应的<code>d[3][1]= 0</code>，但是实际上应为2。</p>
<p>另外还有一个测试用例发生错误是可能存在数据溢出问题，比如这个例子：</p>
<pre><code>&quot;xslledayhxhadmctrliaxqpokyezcfhzaskeykchkmhpyjipxtsuljkwkovmvelvwxzwieeuqnjozrfwmzsylcwvsthnxujvrkszqwtglewkycikdaiocglwzukwovsghkhyidevhbgffoqkpabthmqihcfxxzdejletqjoxmwftlxfcxgxgvpperwbqvhxgsbbkmphyomtbjzdjhcrcsggleiczpbfjcgtpycpmrjnckslrwduqlccqmgrdhxolfjafmsrfdghnatexyanldrdpxvvgujsztuffoymrfteholgonuaqndinadtumnuhkboyzaqguwqijwxxszngextfcozpetyownmyneehdwqmtpjloztswmzzdzqhuoxrblppqvyvsqhnhryvqsqogpnlqfulurexdtovqpqkfxxnqykgscxaskmksivoazlducanrqxynxlgvwonalpsyddqmaemcrrwvrjmjjnygyebwtqxehrclwsxzylbqexnxjcgspeynlbmetlkacnnbhmaizbadynajpibepbuacggxrqavfnwpcwxbzxfymhjcslghmajrirqzjqxpgtgisfjreqrqabssobbadmtmdknmakdigjqyqcruujlwmfoagrckdwyiglviyyrekjealvvigiesnvuumxgsveadrxlpwetioxibtdjblowblqvzpbrmhupyrdophjxvhgzclidzybajuxllacyhyphssvhcffxonysahvzhzbttyeeyiefhunbokiqrpqfcoxdxvefugapeevdoakxwzykmhbdytjbhigffkmbqmqxsoaiomgmmgwapzdosorcxxhejvgajyzdmzlcntqbapbpofdjtulstuzdrffafedufqwsknumcxbschdybosxkrabyfdejgyozwillcxpcaiehlelczioskqtptzaczobvyojdlyflilvwqgyrqmjaeepydrcchfyftjighntqzoo&quot;
&quot;rwmimatmhydhbujebqehjprrwfkoebcxxqfktayaaeheys&quot;
结果为543744000，超出INT_MAX
</code></pre>
<p>所以涉及到加法以及计数的时候，还是要考虑以下数据溢出问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[97.Interleaving String]]></title>
        <id>https://zyq2652192993zyq.github.io/post/97interleaving-string/</id>
        <link href="https://zyq2652192993zyq.github.io/post/97interleaving-string/">
        </link>
        <updated>2020-04-28T11:05:46.000Z</updated>
        <content type="html"><![CDATA[<p><strong>文中提到的题目可在我GitHub的<a href="https://github.com/zyq2652192993zyq/LeetCode">LeetCode</a>, <a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge">SJTU OJ</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Algorithm%20Analysis">Algorithm Analysis</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Problem%20Solution">Problem Solution</a>找到解答。</strong></p>
<p>Tags: <code>Hard</code> <code>Dynamic Programming</code></p>
<p>Links: https://leetcode.com/problems/interleaving-string/</p>
<hr>
<p>Given <em>s1</em>, <em>s2</em>, <em>s3</em>, find whether <em>s3</em> is formed by the interleaving of <em>s1</em> and <em>s2</em>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;
Output: true
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;
Output: false
</code></pre>
<hr>
<pre><code class="language-c++">class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        std::ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout.tie(NULL);

        int m = s1.size(), n = s2.size();
        if (s3.size() != m + n) return false;

        vector&lt;vector&lt;bool&gt;&gt; d(m + 1, vector&lt;bool&gt;(n + 1));
        d[0][0] = true;
        for (int i = 1; i &lt;= m; ++i) {
            if (s1[i - 1] == s3[i - 1]) d[i][0] = true;
            else break;
        }

        for (int i = 1; i &lt;= n; ++i) {
            if (s2[i - 1] == s3[i - 1]) d[0][i] = true;
            else break;
        }

        for (int i = 1; i &lt;= m; ++i) {
            for (int j = 1; j &lt;= n; ++j) {
                d[i][j] = (s1[i - 1] == s3[i + j - 1] &amp;&amp; d[i - 1][j]) 
                	|| (s2[j - 1] == s3[i + j - 1] &amp;&amp; d[i][j - 1]);
            }
        }

        return d[m][n];
    }
};
</code></pre>
<p>首先如果交错构成的，则必有<code>s3</code>长度等于<code>s1</code>和<code>s2</code>的长度和。另外尤其需要注意的就是顺序问题，考虑这样一个例子：</p>
<pre><code>s3 = bbac
s1 = ab
s2 = bc
</code></pre>
<p>虽然<code>s1</code>和<code>s2</code>的字符在<code>s3</code>里都存在，但是违背了顺序关系。</p>
<p>其实这道题和编辑距离还是很接近的，用<code>d[i][j]</code>表示<code>s1</code>的前<code>i</code>个字符和<code>s2</code>的前<code>j</code>个字符能否和<code>s3</code>的前<code>i+j</code>个字符完成匹配。首先就是初始化问题，<code>d[0][0]</code>显然为<code>true</code>，另外初始化当<code>s1</code>为空和<code>s2</code>为空的情况。</p>
<p>假如<code>s1[i - 1]</code>和<code>s3[i+j-1]</code>完成匹配，那么意味着<code>s1</code>前<code>i-1</code>个和<code>s2</code>前<code>j</code>个字符要和<code>s3</code>前<code>i+j-1</code>个字符完成匹配，或者<code>s2[j -1] == s3[i + j - 1]</code>，则需要<code>s1</code>前<code>i</code>个和<code>s2</code>前<code>j-1</code>个匹配。两者中只要有一个满足即可，所以用或的关系。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 计算几何——最近点对]]></title>
        <id>https://zyq2652192993zyq.github.io/post/ji-suan-ji-he-zui-jin-dian-dui/</id>
        <link href="https://zyq2652192993zyq.github.io/post/ji-suan-ji-he-zui-jin-dian-dui/">
        </link>
        <updated>2020-04-28T10:56:03.000Z</updated>
        <content type="html"><![CDATA[<p><strong>文中提到的题目可在我GitHub的<a href="https://github.com/zyq2652192993zyq/LeetCode">LeetCode</a>, <a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge">SJTU OJ</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Algorithm%20Analysis">Algorithm Analysis</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Problem%20Solution">Problem Solution</a>找到解答。</strong></p>
<p>题意：给定平面上n个点，找出其中的一对点的距离，使得在这n个点的所有点对中，该欧式距离为所有点对中小的。(plane closest point pair)</p>
<h1 id="暴力求解">暴力求解</h1>
<p>先求第一个点到其他点的最短距离，再求第二个点到其他点的最短距离，依此类推。时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，只要数据大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>肯定超时。</p>
<h1 id="分治算法">分治算法</h1>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-6495610"><label class="task-list-item-label" for="task-item-6495610"> 洛谷-P1257 平面上的最接近点对</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-9415451"><label class="task-list-item-label" for="task-item-9415451"> 洛谷-P1429 平面最近点对（加强版）</label></li>
</ul>
<p>这里借鉴<strong>syksykCCC</strong>在洛谷题解里的解释，图片也援引于洛谷。</p>
<p>比如这样一组输入：</p>
<pre><code>10
1 1
1 5
3 1
5 1
5 6
6 7
7 3
8 1
10 3
9 9
</code></pre>
<p>共十个点，将其画在直角坐标系里。</p>
<img src="https://i.loli.net/2019/12/20/3jrHFVlvaZUPsDI.png" alt="image.png" style="zoom:50%;" />
<p>分治的思想是将整个数组一分为二，分别计算每个组内的最近点对，然后再去计算跨越左右界限的点对，看是否存在比已知点对距离更小的点对。首先就是根据横坐标对数据进行排序。函数PCPP的输入参数是需要计算部分的左右下标。</p>
<p>在进行划分之前需要进行边界处理，因为分治法是递归的去处理，一个很重要的环节就是递归何时终止，如果递归到数组内只有一个元素，那么就返回一个较大的数值，这时认为另一个点在无穷远处。如果只有两个点的时候，直接计算两个点的距离即可。</p>
<p>然后将数组一分为二，分别计算每个组内的最近点对距离。然后处理横跨左右的部分。</p>
<img src="https://i.loli.net/2019/12/20/XPskY3NgrcMBEW6.png" alt="image.png" style="zoom:50%;" />
<p>左右递归计算后最近点对结果为2，然后就是计算跨越中线的最近点对，这里只需要把横坐标差值小于<code>res</code>的部分进行统计，因为如果横坐标差值都大于<code>res</code>，加上纵坐标，肯定不是最近点对。用一个数组<code>tmp</code>存储这些点的下标，接下来就是看数组内的点对之间的距离，看起来需要暴力计算。但是可以根据其纵坐标进行排序，这样如果两个点的纵坐标差值大于<code>res</code>了，从这个点以后的都无需计算了。如果存在小于<code>res</code>的点对，那么就更新<code>res</code>即可。</p>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

int n;
struct Node
{
	double x, y;
	bool operator&lt;(const Node &amp; obj) const
	{
		return x &lt; obj.x || (x == obj.x &amp;&amp; y &lt; obj.y);
	}
};
vector&lt;Node&gt; seq(200005);
vector&lt;int&gt; tmp(200005);


inline bool cmp(int i, int j)
{
	return seq[i].y &lt; seq[j].y;
}

inline double dis(int i, int j)
{
	double xSquare = (seq[i].x - seq[j].x) * (seq[i].x - seq[j].x);
	double ySquare = (seq[i].y - seq[j].y) * (seq[i].y - seq[j].y);
	return sqrt(xSquare + ySquare);
}

//PCPP: plane closest point pair
double PCPP(int left, int right)
{
	if (left == right) return INT_MAX * 1.0;
	if (left + 1 == right) return dis(left, right);
	//分别计算左右部分的最近点对
	int mid = left + ((right - left) &gt;&gt; 1);
	double d1 = PCPP(left, mid);
	double d2 = PCPP(mid + 1, right);
	double res = min(d1, d2);
	//计算横跨左右部分的最近点对
	int cnt = 0;
	for (int i = left; i &lt;= right; ++i) {
		if (fabs(seq[i].x - seq[mid].x) &lt;= res) 
			tmp[cnt++] = i;
	}
    //根据纵坐标对下标进行排序
	sort(tmp.begin(), tmp.begin() + cnt, cmp);

	for (int i = 0; i &lt; cnt; ++i) {
        //如果纵坐标差值大于res，无需进行计算
		for (int j = i + 1; j &lt; cnt &amp;&amp; seq[tmp[j]].y - seq[tmp[i]].y &lt; res; ++j) {
			double d3 = dis(tmp[i], tmp[j]);
			res = min(res, d3);
		}
	}

	return res;
}



int main()
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; seq[i].x &gt;&gt; seq[i].y;
	}

	sort(seq.begin(), seq.begin() + n);
	cout &lt;&lt; fixed &lt;&lt; setprecision(4) &lt;&lt; PCPP(0, n - 1) &lt;&lt; endl;


	return 0;
}
</code></pre>
<h1 id="随机旋转">随机旋转</h1>
<p>算法基本步骤：</p>
<ul>
<li>随机旋转</li>
<li>按横坐标排序后枚举每个点与其后面5个点的距离取最小值更新答案。</li>
</ul>
<p>以点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_2, y_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>为中心进行旋转：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><msub><mi>x</mi><mn>2</mn></msub><mo>)</mo><mo>×</mo><mi>cos</mi><mo>⁡</mo><mi>θ</mi><mo>−</mo><mo>(</mo><msub><mi>y</mi><mn>1</mn></msub><mo>−</mo><msub><mi>y</mi><mn>2</mn></msub><mo>)</mo><mo>×</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mspace linebreak="newline"></mspace><msub><mi>y</mi><mn>1</mn></msub><mo>=</mo><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><msub><mi>x</mi><mn>2</mn></msub><mo>)</mo><mo>×</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi><mo>+</mo><mo>(</mo><msub><mi>y</mi><mn>1</mn></msub><mo>−</mo><msub><mi>y</mi><mn>2</mn></msub><mo>)</mo><mo>×</mo><mi>cos</mi><mo>⁡</mo><mi>θ</mi><mo>+</mo><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1 = (x_1 - x_2) \times \cos \theta - (y_1 - y_2) \times \sin \theta + x_2 \\
y_1 = (x_1 - x_2)\times \sin \theta + (y_1 - y_2) \times \cos \theta + y_2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>是弧度表示。现在看不旋转去寻找每个点后面五个点的距离最小值：</p>
<img src="F:\Project\Advanced-Algorithm\Algorithm Analysis\计算几何——平面最近点对.assets\image-20200427175848862.png" alt="image-20200427175848862" style="zoom: 67%;" />
<p>如图A点会与B、C、D、E、F（按顺序）更新答案，但是G应该是离A最近的点。<br>
旋转可以很好地解决这个问题。如下图：A点会与G、F、D、B、C（按顺序）更新答案。两次旋转即可得到结果。</p>
<img src="F:\Project\Advanced-Algorithm\Algorithm Analysis\计算几何——平面最近点对.assets\image-20200427175922109.png" alt="image-20200427175922109" style="zoom:67%;" />
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

int n;
struct Node
{
	double x, y;
	bool operator&lt;(const Node &amp; obj) const
	{
		return x &lt; obj.x || (x == obj.x &amp;&amp; y &lt; obj.y);
	}
};
vector&lt;Node&gt; seq(200005);
double res = INT_MAX * 1.0;
const double PI = 2 * asin(1);

inline double dis(int i, int j)
{
	double xSquare = (seq[i].x - seq[j].x) * (seq[i].x - seq[j].x);
	double ySquare = (seq[i].y - seq[j].y) * (seq[i].y - seq[j].y);
	return sqrt(xSquare + ySquare);
}

void DFS(int start)
{
	//计算从start往后5个点，不足就只计算到结尾
	int len = min(start + 5 + 1, n);
	for (int i = start + 1; i &lt; len; ++i) {
		if (seq[i].x - seq[start].x &gt; res) break;
		res = min(res, dis(start, i));
	}
}

void rotate(double arc)
{
	//根据旋转公式进行旋转
	for (int i = 0; i &lt; n; ++i) {
		double xPos = seq[i].x, yPos = seq[i].y;
		seq[i].x = xPos * cos(arc) - yPos * sin(arc);
		seq[i].y = xPos * sin(arc) + yPos * cos(arc);
	}
}

//PCPP: plane closest point pair
//times: 进行随机旋转的次数
void PCPP(int times)
{
	for (int i = 0; i &lt; times; ++i) {
		//根据横坐标进行排序
		sort(seq.begin(), seq.begin() + n);
		for (int j = 0; j &lt; n; ++j) DFS(j); //计算每个点后五个点的最小距离
		if (i != times - 1) { //最后一次不需要旋转
			//初始化随机种子
			srand(time(NULL));
			//产生一个0-359的角度，然后转成弧度
			rotate((rand() % 360) * 1.0 / 360 * PI);
		}
	}	
}

int main()
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; seq[i].x &gt;&gt; seq[i].y;
	}

	PCPP(2);
	cout &lt;&lt; fixed &lt;&lt; setprecision(4) &lt;&lt; res &lt;&lt; endl;

	return 0;
}
</code></pre>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>典型题目：</p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-1733229"><label class="task-list-item-label" for="task-item-1733229"> 洛谷-P1257 平面上的最接近点对</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-1290618"><label class="task-list-item-label" for="task-item-1290618"> 洛谷-P1429 平面最近点对（加强版）</label></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[First Unique Number]]></title>
        <id>https://zyq2652192993zyq.github.io/post/first-unique-number/</id>
        <link href="https://zyq2652192993zyq.github.io/post/first-unique-number/">
        </link>
        <updated>2020-04-28T10:51:25.000Z</updated>
        <content type="html"><![CDATA[<p><strong>文中提到的题目可在我GitHub的<a href="https://github.com/zyq2652192993zyq/LeetCode">LeetCode</a>, <a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge">SJTU OJ</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Algorithm%20Analysis">Algorithm Analysis</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Problem%20Solution">Problem Solution</a>找到解答。</strong></p>
<p>Tags: <code>Hash Table</code> <code>Queue</code></p>
<p>Links: https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3313/</p>
<hr>
<p>You have a queue of integers, you need to retrieve the first unique integer in the queue.</p>
<p>Implement the <code>FirstUnique</code> class:</p>
<ul>
<li><code>FirstUnique(int[] nums)</code> Initializes the object with the numbers in the queue.</li>
<li><code>int showFirstUnique()</code> returns the value of <strong>the first unique</strong> integer of the queue, and returns <strong>-1</strong> if there is no such integer.</li>
<li><code>void add(int value)</code> insert value to the queue.</li>
</ul>
<p><strong>Example 1:</strong></p>
<pre><code>Input: 
[&quot;FirstUnique&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;]
[[[2,3,5]],[],[5],[],[2],[],[3],[]]
Output: 
[null,2,null,2,null,3,null,-1]

Explanation: 
FirstUnique firstUnique = new FirstUnique([2,3,5]);
firstUnique.showFirstUnique(); // return 2
firstUnique.add(5);            // the queue is now [2,3,5,5]
firstUnique.showFirstUnique(); // return 2
firstUnique.add(2);            // the queue is now [2,3,5,5,2]
firstUnique.showFirstUnique(); // return 3
firstUnique.add(3);            // the queue is now [2,3,5,5,2,3]
firstUnique.showFirstUnique(); // return -1
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: 
[&quot;FirstUnique&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;]
[[[7,7,7,7,7,7]],[],[7],[3],[3],[7],[17],[]]
Output: 
[null,-1,null,null,null,null,null,17]

Explanation: 
FirstUnique firstUnique = new FirstUnique([7,7,7,7,7,7]);
firstUnique.showFirstUnique(); // return -1
firstUnique.add(7);            // the queue is now [7,7,7,7,7,7,7]
firstUnique.add(3);            // the queue is now [7,7,7,7,7,7,7,3]
firstUnique.add(3);            // the queue is now [7,7,7,7,7,7,7,3,3]
firstUnique.add(7);            // the queue is now [7,7,7,7,7,7,7,3,3,7]
firstUnique.add(17);           // the queue is now [7,7,7,7,7,7,7,3,3,7,17]
firstUnique.showFirstUnique(); // return 17
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: 
[&quot;FirstUnique&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;]
[[[809]],[],[809],[]]
Output: 
[null,809,null,-1]

Explanation: 
FirstUnique firstUnique = new FirstUnique([809]);
firstUnique.showFirstUnique(); // return 809
firstUnique.add(809);          // the queue is now [809,809]
firstUnique.showFirstUnique(); // return -1
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^8</code></li>
<li><code>1 &lt;= value &lt;= 10^8</code></li>
<li>At most <code>50000</code> calls will be made to <code>showFirstUnique</code> and <code>add</code>.</li>
</ul>
<hr>
<pre><code class="language-c++">class FirstUnique {
	unordered_map&lt;int, list&lt;int&gt;&gt; freq;
	unordered_map&lt;int, list&lt;int&gt;::iterator&gt; it;
	unordered_map&lt;int, int&gt; s;
public:
    FirstUnique(vector&lt;int&gt;&amp; nums) {
        std::ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout.tie(NULL);

        int n = nums.size();
        for (int i = 0; i &lt; n; ++i) {
        	add(nums[i]);
        }
    }
    
    int showFirstUnique() {
        return freq[1].size() == 0 ? -1 : freq[1].back();
    }
    
    void add(int value) {
        if (s.find(value) == s.end()) {
        	freq[1].push_front(value);
        	it[value] = freq[1].begin();
        	++s[value];
        }
        else {
        	if (s[value] == 1) {
        		auto pos = it[value];
        		freq[1].erase(pos);
        		it.erase(value);
        		++s[value];
        	}
        	else ++s[value];
        }
    }
};

/**
 * Your FirstUnique object will be instantiated and called as such:
 * FirstUnique* obj = new FirstUnique(nums);
 * int param_1 = obj-&gt;showFirstUnique();
 * obj-&gt;add(value);
 */
</code></pre>
<p>这道题是一个设计类型的问题，仅涉及两个操作，一个是查询第一个只出现一次的数，另一个是往序列里增加一个数。“第一个只出现一次”这个条件，其实可以很敏感的联想到LRU和LFU，LRU和LFU传递的很重要的思路是：</p>
<ul>
<li>如何表示插入顺序的先后？用双向链表来解决，链表靠前位置表示先出现，后来的元素插在尾端（究竟首尾哪一段表示位置靠前可以自行规定）</li>
<li>如何解决链表不能随机访问的缺点？用<code>unordered_map</code>将链表的迭代器和某一查询要素进行映射，以达到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>访问的目的。</li>
<li>LFU启发的思路是如何处理和频率相关的问题。</li>
</ul>
<p>那么这道题其实就可以从LRU和LFU中提取思路。用<code>freq</code>这个<code>unordered_map</code>用来建立频率和元素之间的映射，这里之存储频率为1的元素，值是一个链表，链表尾端表示顺序靠前，尾端表示新插入的元素。为了快速访问，用<code>it</code>建立元素和其在链表中迭代器的映射，因为这里之存储频率为1的元素，所以链表也不会出现重复元素。用<code>s</code>记录每个数字出现的频率。</p>
<p>初始化部分，对于第一次出现的元素，插入到<code>freq</code>中的链表，用<code>it</code>记录迭代器的位置，当插入一个元素发现和之前插入的元素重复时，如果之前这个元素只是出现一次，那么说明这个元素目前还在频率为1的链表中，那么就需要把它删掉；如果这个元素的频率超过一次，说明肯定不会在频率为1的链表里，也就无需执行删除操作了。<strong>这一部分的内容和LFU非常接近</strong></p>
]]></content>
    </entry>
</feed>