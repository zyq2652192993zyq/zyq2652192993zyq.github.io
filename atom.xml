<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zyq2652192993zyq.github.io/</id>
    <title>Kylin</title>
    <updated>2020-01-05T08:55:00.611Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zyq2652192993zyq.github.io/"/>
    <link rel="self" href="https://zyq2652192993zyq.github.io//atom.xml"/>
    <subtitle>Talk is cheap, show me the code.</subtitle>
    <logo>https://zyq2652192993zyq.github.io//images/avatar.png</logo>
    <icon>https://zyq2652192993zyq.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Kylin</rights>
    <entry>
        <title type="html"><![CDATA[AOJ-0033 Ball(DFS + 贪心或LIS)]]></title>
        <id>https://zyq2652192993zyq.github.io//post/aoj-0033-balldfs-tan-xin-huo-lis</id>
        <link href="https://zyq2652192993zyq.github.io//post/aoj-0033-balldfs-tan-xin-huo-lis">
        </link>
        <updated>2020-01-05T08:45:55.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>原题是日文，由于我看不懂日文，所以就直接翻译成中文了，评测是在virtual judge上。</p>
</blockquote>
<p><img src="http://judge.u-aizu.ac.jp/onlinejudge/IMAGE1/ball.gif" alt="img"></p>
<p>如图所示，有些容器是分叉的。从容器的开口A放下10个编号为1到10的球，并将其放在左管B或右管C中。板D可以绕支点E左右旋转，因此您可以通过移动板D来确定要插入哪个管B或C。</p>
<p>给一排球使其从开口A掉落。按顺序将它们放在气缸B或C中。此时，创建一个程序，如果气缸B和C都可以将大球排列在数量较小的球上，则输出YES，否则，则输出NO。但是，不能改变容器中球的顺序。另外，圆柱体可以相继放置在同一圆柱体中，并且圆柱体B和C具有足够的空间容纳所有十个球。</p>
<h2 id="输入项">输入项</h2>
<p>给出了多个数据集。第一行给出数据集的数量<em>N。<em>然后，给出具有</em>N</em>行的数据集。每个数据集都有10个数字，左右之间用空格隔开。</p>
<h2 id="输出量">输出量</h2>
<p>每个数据集在一行上输出YES或NO。</p>
<h2 id="样本输入">样本输入</h2>
<pre><code>2 
3 1 4 2 5 6 7 8 9 10 
10 9 8 7 6 5 4 3 2 1
</code></pre>
<h2 id="样本输入的输出">样本输入的输出</h2>
<pre><code>YES 
NO
</code></pre>
<hr>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

vector&lt;int&gt; sequence(10);
int leftTop = -1, rightTop = -1;

bool DFS(int num)
{
    if (num == 10) return true;
    //两边同时可以放置则采取贪心策略，找与顶部数字差距最小的放
    if (sequence[num] &gt; leftTop &amp;&amp; sequence[num] &gt; rightTop) {
        if (sequence[num] - leftTop &lt; sequence[num] - rightTop) {
            leftTop = sequence[num];
            return DFS(num + 1);
        }
        else {
            rightTop = sequence[num];
            return DFS(num + 1);
        }
    }
    else if (sequence[num] &gt; leftTop) {
        leftTop = sequence[num];
        return DFS(num + 1);
    }
    else if (sequence[num] &gt; rightTop) {
        rightTop = sequence[num];
        return DFS(num + 1);
    }

    return false;
}

int main()
{
    std::ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int caseNum;
    cin &gt;&gt; caseNum;
    while (caseNum--) {
        for (int i = 0; i &lt; 10; ++i) cin &gt;&gt; sequence[i];
        if (DFS(0)) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
        else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
        leftTop = rightTop = -1;
    }

    return 0;
}
</code></pre>
<p>每一个球的放置策略只有两种选择：左边和右边，但是能否放置有多种情况：</p>
<ul>
<li>左右都能放置</li>
<li>只能放在左边</li>
<li>只能放在右边</li>
<li>两边都不能放置</li>
</ul>
<p>都不能放置的情况最好处理，直接返回即可。比较难处理的是两边都能放置的情况，可以参考的一种思路是《挑战程序设计竞赛》在2.1.4的部分和例子，考虑每个数加上和不加上能否成功。这里就是先试试放在左边，然后试试放在右边。但是发现这个题目有个特殊的地方，考虑第一个样例，如果最开始1放在左边，3放在右边，然后4两边都可以放，如果选择4放在1的上面，到了2就没法放置了。</p>
<p>根据上面的分析可以直到，如果两边都可以放，那么选择与顶部数字差距最小的一边放置是最优选择，因为这样为后面的数字留出了最大的空间（很类似《算法导论》里的任务安排用的贪心的策略），这样就避免了很多无意义的搜索。</p>
<p>本题的数据是10， 考虑如果从1到100个数或者更大的数据，如果按照没有采取贪心的方法去搜索，显然分支情况就会过多，所以使用贪心其实也算是起到了剪枝的作用。</p>
<hr>
<p>这道题目还可以换一种等价问法：一个序列能否被划分(按顺序的从序列中选取数字)成两个单增序列，两个序列中的一个可以为空。</p>
<p>所以题目还可以从<strong>最长上升子序列</strong>的角度来考虑。先用一个数组<code>sequence</code>来存储所有的数字，然后用一个等长的数组<code>visit</code>，存储的内容是<code>bool</code>类型，初始化为<code>false</code>，然后在寻找最长上升子序列时，把在最长上升序列的数字对应的<code>visit</code>设为<code>true</code>。最后去检查<code>visit</code>数组里标记为<code>false</code>的部分是否满足单调上升。</p>
<p>但是这种方法的时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>空间复杂度显然不如上面的DFS+贪心的方法好。</p>
<pre><code class="language-c++">//也可以AC的O(n^2)的方法
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

vector&lt;int&gt; sequence(10);
vector&lt;bool&gt; visit(10, false);
vector&lt;int&gt; path(10, -1);

void mark(int num)
{
    if (num == -1) return;
    else {
        visit[num] = true;
        mark(path[num]);
    } 
}

void LIS()
{
    vector&lt;int&gt; d(10, 0);
    d[0] = 1;

    for (int j = 1; j &lt; 10; ++j) {
        int maxLength = 0;
        int pos = 0;
        for (int i = 0; i &lt; j; ++i) {
            if (sequence[j] &gt; sequence[i] &amp;&amp; maxLength &lt; d[i]) {
                maxLength = d[i];
                pos = i;
            }
        }
        path[j] = pos;
        d[j] = maxLength + 1;
    }
    int endPos = max_element(d.begin(), d.end()) - d.begin();
    mark(endPos);
}

bool split()
{
    LIS();
    int pre = -1;
    for (int i = 0; i &lt; 10; ++i) {
        if (!visit[i]) {
            if (sequence[i] &gt; pre) pre = sequence[i];
            else return false;
        }
    }
    return true;
}

int main()
{
    std::ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int caseNum;
    cin &gt;&gt; caseNum;
    while (caseNum--) {
        for (int i = 0; i &lt; 10; ++i) cin &gt;&gt; sequence[i];
        if (split()) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
        else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
        fill(visit.begin(), visit.end(), false);
        fill(path.begin(), path.end(), -1);
    }

    return 0;
}
</code></pre>
<p>用数组<code>sequence</code>来记录输入的数字，用函数<code>split()</code>来判断序列是否可以分成单增的两部分，函数<code>split()</code>先通过函数<code>LIS()</code>来寻找最长上升子序列，这里有一个技巧，就是增加一个<code>path()</code>数组，用来记录当前最大长度是将数字加入到哪一个序列得到的，<code>path()</code>数组初始化为-1，最后可以通过递归的方式得到最长上升子序列，-1就标记着当前位置就是子序列的起始位置。这里需要注意的就是因为<code>sequence</code>数组下一次输入的时候会覆盖原来的数字，所以并不需要去处理，但是<code>path, visit</code>需要在下一个算例开始前进行初始化。</p>
<p>（如果想进一步优化）其实最后一个算例的时候是没有必要对<code>path,visit</code>进行初始化的，只需要增加一句：</p>
<pre><code class="language-c++">if (caseNum != 0) {
    fill(visit.begin(), visit.end(), false);
    fill(path.begin(), path.end(), -1);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CS 631-APUE：Lecture 02 File I/O, File Sharing]]></title>
        <id>https://zyq2652192993zyq.github.io//post/cs-631-apuelecture-02-file-io-file-sharing</id>
        <link href="https://zyq2652192993zyq.github.io//post/cs-631-apuelecture-02-file-io-file-sharing">
        </link>
        <updated>2019-12-16T14:47:34.000Z</updated>
        <content type="html"><![CDATA[<p>回忆<code>simple-cat.c</code>的写法，这里<code>read</code> <code>write</code> 函数定义在头文件<code>&lt;unistd.h&gt;</code>内，在APUE 1.5节输入和输出有更详细的解释。</p>
<pre><code class="language-c">//filename: simple-cat.c
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

#ifndef BUFFSIZE
#define BUFFSIZE 32768
#endif

int main()
{
    int n;
    char buffer[BUFFSIZE];

    while ((n = read(STDIN_FILENO, buffer, BUFFSIZE)) &gt; 0) {
        if ((write(STDOUT_FILENO, buffer, n)) != n) {
            fprintf(stderr, &quot;write error!\n&quot;);
            exit(1);
          }
    }

    if (n &lt; 0){
      fprintf(stderr, &quot;read error!\n&quot;);
      exit(1);
    }

    return 0;
}
</code></pre>
<pre><code class="language-shell">$ ./simple-cat &lt; simple-cat.c &gt; out.txt
$ cat out.txt
</code></pre>
<p>其中<code>exit()</code>函数是定义在头文件<code>&lt;stdlib.h&gt;</code>内。<code>stderr</code>可以通过<code>man stderr</code>查看详细信息，定义在头文件<code>&lt;stdio.h&gt;</code>内：</p>
<pre><code class="language-c"> #include &lt;stdio.h&gt;

extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;
</code></pre>
<h2 id="文件描述符">文件描述符</h2>
<p>对于内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。（A <em>file descriptor</em> (or <em>file handle</em>) is a small, non-negative integer which identifies a file to the kernel.）</p>
<p>通常UNIX系统下文件描述符0与进程的标准输入关联，1与标准输出关联，2与标准错误关联。为了可读性，在头文件<code>&lt;unistd.h&gt;</code>中分别替换成符号常量<code>STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO</code>。</p>
<p><img src="https://i.loli.net/2019/11/22/FBIHV8ljvfuGq5N.png" alt=""></p>
<ul>
<li>prints the value of <code>STDIN FILENO</code>, <code>STDOUT FILENO</code>, <code>STDERR FILENO</code></li>
<li>prints the value of the file descriptors referenced via the <code>stdin</code>, <code>stdout</code>, <code>stderr</code> streams</li>
<li>open(2)’s a file, then prints the value of that file descriptor</li>
<li>fopen(3)’s a file, then prints the value of the file descriptor referenced via that stream</li>
</ul>
<p>这些需求在文件<code>fds.c</code>内实现。（其实这是warm-up exercise的内容）</p>
<pre><code class="language-c">//filename: fds.c
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    printf(&quot;prints the value of STDIN FILENO, STDOUT FILENO, STDERR FILENO.\n&quot;);
    printf(&quot;STDIN_FILENO: %d\n&quot;, STDIN_FILENO);
    printf(&quot;STDOUT_FILENO: %d\n&quot;, STDOUT_FILENO);
    printf(&quot;STDERR_FILENO: %d\n\n&quot;, STDERR_FILENO);

    printf(&quot;prints the value of the file descriptors referenced via the stdin, stdout, stderr streams.\n&quot;);
    printf(&quot;stdin: %d\n&quot;, fileno(stdin));
    printf(&quot;stdout: %d\n&quot;, fileno(stdout));
    printf(&quot;stderr: %d\n\n&quot;, fileno(stderr));

    printf(&quot;open(2)’s a file, then prints the value of that file descriptor.\n&quot;);
    printf(&quot;Opening /dev/zero...\n&quot;);
    int fd1;
    if ((fd1 = open(&quot;/dev/zero&quot;, O_RDONLY)) &lt; 0) {
		  fprintf(stderr, &quot;Unable to open /dev/zero: %s\n&quot;, strerror(errno));
	  } 
    else {
		  printf(&quot;fd1: %d\n&quot;, fd1);
	  }

    int fd2;
    printf(&quot;\nOpening /dev/zero a second time...\n&quot;);
    if ((fd2 = open(&quot;/dev/zero&quot;, O_RDONLY)) &lt; 0){
      fprintf(stderr, &quot;Unable to open /dev/zero: %s/n&quot;, strerror(errno));
      exit(EXIT_FAILURE);
    }
    else {
      printf(&quot;fd2: %d\n&quot;, fd2);
    }

    printf(&quot;\nNow closing fd1, but keeping fd2 open..\n&quot;);
    close(fd1);

    int fd3;
    printf(&quot;\nOpening /dev/zero a third time...\n&quot;);
    if ((fd3 = open(&quot;/dev/zero&quot;, O_RDONLY)) &lt; 0) {
      fprintf(stderr, &quot;Unable to open /dev/zero: %s\n&quot;, strerror(errno));
      exit(EXIT_FAILURE);
    }
    else {
      printf(&quot;fd3: %d\n&quot;, fd3);
    }

    printf(&quot;\nNow closing fd2 and fd3.\n&quot;);
    close(fd2);
    close(fd3);

    printf(&quot;Now opening /dev/zero as a stream.\n&quot;);
    FILE *f;
    if ((f = fopen(&quot;/dev/zero&quot;, &quot;r&quot;)) == NULL) {
      fprintf(stderr, &quot;Unable to open /dev/zero: %s\n&quot;, strerror(errno));
      exit(EXIT_FAILURE);
    }
    printf(&quot;f: %d\n&quot;, fileno(f));
    fclose(f);

    return 0;
}             
</code></pre>
<pre><code class="language-shell">$ gcc -o fds fds.c
$ ./fds
prints the value of STDIN FILENO, STDOUT FILENO, STDERR FILENO.                           
STDIN_FILENO: 0                                                                           
STDOUT_FILENO: 1                                                                          
STDERR_FILENO: 2                                                                          
                                                                                          
prints the value of the file descriptors referenced via the stdin, stdout, stderr streams.
stdin: 0                                                                                  
stdout: 1                                                                                 
stderr: 2                                                                                 
                                                                                          
open(2)’s a file, then prints the value of that file descriptor.                          
Opening /dev/zero...                                                                      
fd1: 3                                                                                    
                                                                                          
Opening /dev/zero a second time...                                                        
fd2: 4                                                                                    
                                                                                          
Now closing fd1, but keeping fd2 open..                                                   
                                                                                          
Opening /dev/zero a third time...                                                         
fd3: 3                                                                                    
                                                                                          
Now closing fd2 and fd3.                                                                  
Now opening /dev/zero as a stream.                                                        
f: 3                                                                                      
</code></pre>
<p>函数<code>fileno()</code>定义在头文件<code>&lt;stdio.h&gt;</code>内，返回文件描述符的值。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int fileno(FILE *stream);
//The function fileno() examines the argument stream and returns its integer file descriptor.
</code></pre>
<p>所以可以通过函数<code>fileno()</code>来查看<code>stdin, stdout, stderr</code>的值。</p>
<p><code>fprintf()</code>定义：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int fprintf(FILE *stream, const char *format, ...);
//The function dprintf() is the same as fprintf() except that it outputs to a file descriptor, fd, instead of to a stdio stream.
</code></pre>
<p><code>errno</code>的定义：</p>
<pre><code class="language-c">#include &lt;errno.h&gt;
/*
The  &lt;errno.h&gt;  header file defines the integer variable errno, which is set by system calls and some library functions in the event of an error to indicate what went wrong.
*/
</code></pre>
<p><code>fds.c</code>程序验证了函数<code>open()</code>返回的文件描述符一定是最小的未用描述符。</p>
<p>文件描述符的变化范围是<code>0~OPENMAX - 1</code>，通过程序<code>openmax.c</code>来判断系统文件描述符的上限和每个进程最多打开的文件数量。</p>
<pre><code class="language-c">//filename: openmax.c
#include &lt;stdio.h&gt;
#include &lt;sys/resource.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

#define OPEN_MAX_GUESS 256

int open_max()
{
#ifdef OPEN_MAX
  	int openmax = OPEN_MAX;
#else
  	int openmax = 0;
#endif

  	if (openmax == 0) {
    	errno = 0;
    	if ((openmax = sysconf(_SC_OPEN_MAX)) &lt; 0) {
      		if (errno == 0)
        		openmax = OPEN_MAX_GUESS;
      		else
        		fprintf(stderr, &quot;sysconf error for _SC_OPEN_MAX\n&quot;);
    	}
	}

  	return openmax;
}

int main()
{
    struct rlimit rlp;
    if (getrlimit(RLIMIT_NOFILE, &amp;rlp) != 0) {
        fprintf(stderr, &quot;Unable to get per process rlimit: %s\n&quot;, strerror(errno));
        exit(EXIT_FAILURE);
    }

    printf(&quot;This user could open %d file descriptors.\n&quot;, open_max());
    printf(&quot;This process could open %d file descriptors.\n&quot;, (int)rlp.rlim_cur);
}
</code></pre>
<pre><code class="language-shell">$ gcc -o openmax openmax.c
$ ./openmax
This user could open 1024 file descriptors.
This process could open 1024 file descriptors.
</code></pre>
<p>函数<code>getrlimit()</code>的定义，可以通过<code>man getrlimit</code>查看其定义：</p>
<pre><code class="language-c">#include &lt;sys/resource.h&gt;

int getrlimit(int resource, struct rlimit *rlim);
/*
 On success, these system calls return 0.  On error, -1 is returned, and errno is set appropriately.
 */
</code></pre>
<p>对于函数<code>getrlimit()</code>的作用：</p>
<pre><code class="language-c">/* 
The  getrlimit()  and  setrlimit()  system calls get and set resource limits respectively.  Each resource has an associated soft and hard limit, as defined by the rlimit structure:
*/

struct rlimit {
	rlim_t rlim_cur;  /* Soft limit */
	rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */
};
</code></pre>
<p>常量<code>RLIMIT_NOFILE</code>也定义在<code>&lt;sys/resource.h&gt;</code>里：</p>
<pre><code class="language-c">/*
RLIMIT_NOFILE:
This specifies a value one greater than the maximum file descriptor number that can be opened by this process.  Attempts (open(2),  pipe(2), dup(2), etc.)  to exceed this limit yield the error EMFILE.
*/
</code></pre>
<p>函数<code>sysconf()</code>定义：</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
long sysconf(int name); //get configuration information at run time

// _SC_OPEN_MAX:
// The maximum number of files that a process can have open at any time.

/*
 On error, -1 is returned and errno is set to indicate the cause of the error。
 */
</code></pre>
<p><code>open_max()</code>函数的设计也是基于<code>sysconf()</code>函数的定义的。如果<code>sysconf()</code>函数出错将返回-1， 并通过<code>errno</code>来提示错误的原因。如果函数的参数恰好是限制的最大值或最小值，并且这个限定值是模糊不确定的，那么<code>errno</code>的数值不会改变。所以为了区分由于限定值不确定造成的错误，一般先将<code>errno</code>设置称为0，当<code>sysconf()</code>返回-1时检查<code>errno</code>的数值是否改变，如果没变就是由限定值不确定造成的错误。（此处的设计思路其实就是<code>man sysconf</code>里<code>RETURN VALUE</code>的部分）</p>
<p>函数<code>open_max()</code>先检查是否定义了<code>OPEN_MAX</code>，定义了就<code>openmax = OPEN_MAX</code>，未定义先初始化为0。然后去检查限定值是否是不确定的。根据上面分分析，令<code>errno = 0</code>，然后检查其值是否发生变化，无变化就将令<code>openmax</code>为我们的猜测值（反正也不确定我们就猜一个好了），如果<code>errno</code>变化了说明是其他类型的错误。注意<code>openmax = sysconf(_SC_OPEN_MAX)</code>发生了隐式类型转换。</p>
<p><strong>不带缓冲</strong>：每个<code>read</code>和<code>write</code>都调用内核中的一个系统调用。</p>
<p>函数<code>open, close, read, write, lseek</code>都提供了不带缓冲的I/O。</p>
<h2 id="函数creat">函数creat</h2>
<p>通过<code>creat</code>函数创建一个新文件：</p>
<pre><code class="language-c">#include &lt;fcntl.h&gt;

int creat(const char * path, mode_t mode);
//return value: file descriptor if OK, -1 on error
</code></pre>
<p><code>creat</code>函数的不足之处是只是写的方式打开创建的文件，如果要创建一个临时文件，需要先写再读文件，需要依次调用<code>creat</code>, <code>close</code>，<code>open</code>，而用<code>open</code>函数只需要：</p>
<pre><code class="language-c">open(path, O_RDWR | O_CREAT | O_TRUNC, mode)
</code></pre>
<pre><code>//目前见到的头文件的缩写的具体含义
file control header -&gt; fcntl.h
unix standard header -&gt; unistd.h
standard input output header -&gt; stdio.h
standard library header -&gt; stdlib.h
</code></pre>
<h2 id="函数open和openat">函数open和openat</h2>
<p>调用<code>open</code>或<code>openat</code>函数可以打开或创建一个文件。</p>
<pre><code class="language-c">#include &lt;fcntl.h&gt;

int open(const char * path, int oflag, .../* mode_t mode */);

int openat(int fd, const char * path, int oflag, .../* mode_t mode */);
//return value: file discriptor if OK, -1 on error
</code></pre>
<p>最后一个参数写为<code>...</code>是表明余下参数的数量及类型是可变的。<code>path</code>参数是要打开或创建文件的名字，其中参数<code>oflag</code>只能是下列选项中的一个并且必须选择一个：</p>
<ul>
<li><code>O_RDONLY</code> : open for reading only</li>
<li><code>O_WRONLY</code> :  open for writing only</li>
<li><code>O_RDWR</code> :  open for reading and writing</li>
</ul>
<p>下列参数可以通过“或”运算来构成<code>oflag</code>参数：</p>
<ul>
<li><code>O_APPEND</code> : 每次写时都追加到文件尾端</li>
<li><code>O_CREAT</code> ：文件不存在就创建它</li>
<li><code>O_EXCL</code> ：如果同时使用了<code>O_CREAT</code>，而文件存在则出错。因此可以测试一个文件是否存在，不存在就创建文件，使测试和创建文件称为一个原子操作。</li>
<li><code>O_TRUNC</code>：文件存在且只写或读-写成功打开，将其长度截断为0。</li>
<li><code>O_NOCTTY</code> ：<code>path</code>引用的是终端设备，则不讲该设备分配作为此进程的控制终端。（在9.6节）</li>
<li><code>O_NONBLOCK</code> ：14.2节。</li>
<li><code>O_SYNC</code> – 使每次<code>write</code>都等待物理I/O完成，包括由该<code>write</code>引起的文件属性更所需的I/O。</li>
</ul>
<p>在其他的一些平台可能支持以下选项：</p>
<ul>
<li><code>O_EXEC</code>：只执行打开</li>
<li><code>O_SEARCH</code>：只搜索打开（应用于目录）。</li>
<li><code>O_DIRECTORY</code>:如果<code>path</code>引用的不是目录则出错。</li>
<li><code>O_DSYNC</code>：使每次<code>write</code>都等待物理I/O完成，但是如果写操作不影响读取刚写入的数据，不需等待文件属性的更新。</li>
<li><code>O_RSYNC</code>：使每一个以文件描述符作为参数的额<code>read</code>操作等待，直至所有对文件同一部分挂起的写操作完成。</li>
<li><code>O_PATH</code>：Obtain a file descriptor purely for fd-level operations. （获取仅用于fd级操作的文件描述符）</li>
</ul>
<p><code>openat()</code>函数存在的一个意义是：让线程可以使用相对路径名打开目录中的文件。</p>
<p><code>fd</code>参数把<code>open</code>和<code>openat</code>函数区分开来</p>
<ol>
<li><code>path</code>参数指定的是绝对路径，<code>fd</code>参数被忽略，两个函数作用一致</li>
<li><code>path</code>参数指定的是相对路径，<code>fd</code>参数指定了相对路径名在文件中的起始地址</li>
</ol>
<h2 id="函数close">函数close</h2>
<pre><code class="language-c">#include &lt;unistd.h&gt;

int close(int fd);
//return value: 0 if OK, -1 on error
</code></pre>
<p>通过程序<code>openex.c</code>来展示<code>open</code>和<code>openat</code>函数的用法。</p>
<pre><code class="language-c">//filename: openex.c
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;

//create a non-existent file
void createFile()
{
  printf(&quot;Trying to create './newfile' with O_RDONLY | O_CREAT...\n&quot;);
  int fd;

  if ((fd = open(&quot;./newfile&quot;, O_RDONLY | O_CREAT, S_IRUSR | S_IWUSR)) == -1) {
    fprintf(stderr, &quot;unable to create ./newfile %s\n&quot;, strerror(errno));
    exit(EXIT_FAILURE);
  }

  printf(&quot;'./newfile' created. File descriptor is: %d\n&quot;, fd);
}

//fail to create an existing failExclFileCreation
void failExclFileCreation()
{
  printf(&quot;Trying to create './newfile' with O_RDONLY | O_CREAT | O_EXCL...\n&quot;);
  int fd;

  if ((fd = open(&quot;./newfile&quot;, O_RDONLY | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR)) == -1) {
    fprintf(stderr, &quot;Unable to create './newfile': %s\n&quot;, strerror(errno));
  }

  if (close(fd) == -1) {
    fprintf(stderr, &quot;Closing failed: %s\n&quot;, strerror(errno));
  }
}

void openFile()
{
  printf(&quot;Trying to open './openex.c' with O_RDONLY...\n&quot;);

  int fd;
  if ((fd = open(&quot;./openex.c&quot;, O_RDONLY)) == -1) {
    fprintf(stderr, &quot;Unable to open './openex.c': %s\n&quot;, strerror(errno));
    exit(EXIT_FAILURE);
  }

  printf(&quot;'./openex.c' opened. File descriptor is: %d\n&quot;, fd);
  close(fd);

  printf(&quot;'./openex.c' closed again\n&quot;);
}

void failOpenNonexistingFile()
{
  printf(&quot;Trying to open (non-existant) './nosuchfile' with O_RDONLY...\n&quot;);
  int fd;

  if ((fd = open(&quot;./nosuchfile&quot;, O_RDONLY)) == -1){
    fprintf(stderr, &quot;Unable to open a nonexist file './nosuchfile': %s\n&quot;, strerror(errno));
  }

  close(fd);
}

void truncateFile()
{
  printf(&quot;Trying to open './newfile  with O_RDONLY | O_TRUNC...\n&quot;);
  int fd;

  if ((fd = open(&quot;./newfile&quot;, O_RDONLY | O_TRUNC)) == -1) {
    fprintf(stderr, &quot;Unable to open './newfile': %s\n&quot;, strerror(errno));
    exit(EXIT_FAILURE);
  }

  printf(&quot;'./newfile' opened. File descriptor is: %d\n&quot;, fd);
  printf(&quot;'./newfile' truncated -- see 'ls -l newfile'\n&quot;);

  close(fd);
}

int main()
{
  createFile();
  system(&quot;ls -l newfile&quot;);
  sleep(2);
  printf(&quot;\n&quot;);

  //&quot;create&quot; an existing file
  createFile();
  system(&quot;ls -l newfile&quot;);
  sleep(2);
  printf(&quot;\n&quot;);

  //fail to create an existing file
  failExclFileCreation();
  printf(&quot;\n&quot;);

  //open an existing file
  openFile();
  sleep(2);
  printf(&quot;\n&quot;);

  //fail to open a non-existing file
  failOpenNonexistingFile();
  printf(&quot;\n&quot;);
  sleep(2);

  //truncate an existing file
  printf(&quot;now cp openex.c newfile\n&quot;);
  system(&quot;cp openex.c newfile&quot;);
  system(&quot;ls -l newfile&quot;);
  truncateFile();
  system(&quot;ls -l newfile&quot;);

  return 0;
}
</code></pre>
<pre><code class="language-shell">$ gcc -o openex openex.c
$ ./openex
Trying to create './newfile' with O_RDONLY | O_CREAT...
'./newfile' created. File descriptor is: 3
-rw------- 1 kylin kylin 0 Nov 24 14:45 newfile

Trying to create './newfile' with O_RDONLY | O_CREAT...
'./newfile' created. File descriptor is: 4
-rw------- 1 kylin kylin 0 Nov 24 14:45 newfile

Trying to create './newfile' with O_RDONLY | O_CREAT | O_EXCL...
Unable to create './newfile': File exists
Closing failed: Bad file descriptor

Trying to open './openex.c' with O_RDONLY...
'./openex.c' opened. File descriptor is: 5
'./openex.c' closed again

Trying to open (non-existant) './nosuchfile' with O_RDONLY...
Unable to open a nonexist file './nosuchfile': No such file or directory

now cp openex.c newfile
-rw------- 1 kylin kylin 2632 Nov 24 14:45 newfile
Trying to open './newfile  with O_RDONLY | O_TRUNC...
'./newfile' opened. File descriptor is: 5
'./newfile' truncated -- see 'ls -l newfile'
-rw------- 1 kylin kylin 0 Nov 24 14:45 newfile
</code></pre>
<p>函数<code>system()</code>定义：</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int system(const char *command);
/*
The  system()  library  function uses fork(2) to create a child process that executes the shell command specified in command using execl(3) as follows:

	execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, command, (char *) 0);
	
system() returns after the command has been completed.
*/

/*
 The return value of system() is one of the following:
 - If command is NULL, then a nonzero value if a shell is available, or 0 if no shell is available.
 - If a child process could not be created, or its status could not be retrieved, the return value is -1
 - If  a  shell  could not be executed in the child process, then the return value is as though the child shell terminated by calling _exit(2) with the status 127.
 - If all system calls succeed, then the return value is the termination status of the child shell used to execute command.
 */
</code></pre>
<p><code>system()</code>函数这里我们不太需要关注其返回值。因为根据手册显示，其调用<code>fork()</code>来创建一个子进程，子进程里调用函数<code>exel</code>来执行<code>shell</code>命令。我们通过<code>sleep(2)</code>来等待其执行完毕。</p>
<p><code>sleep()</code>函数定义:</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;

unsigned int sleep(unsigned int seconds);
/*
参数： 挂起的时间数 ，单位为秒

返回值：若进程/线程挂起到参数所指定的时间则返回0，若有信号中断则返回剩余秒数。
*/
</code></pre>
<p>注意这里<code>exit</code>函数的使用要慎重。<code>return</code>是结束当前函数的调用，而<code>exit</code>是在操作系统层面的。</p>
<h2 id="函数read和write">函数read和write</h2>
<pre><code class="language-c">#include &lt;unistd.h&gt;

ssize_t read(int fd, void *buf, size_t nbytes);
//return value: number of bytes read, 0 if end of file, -1 on error
</code></pre>
<pre><code class="language-c">#include &lt;unistd.h&gt;

ssize_t write(int fd, const void *buf, size_t nbytes);
//return value: number of bytes written if OK, -1 on error
</code></pre>
<p><code>read</code>和<code>write</code>的使用例子在文件<code>rwex.c</code>内。</p>
<pre><code class="language-c">//filename: rwex.c
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

#define COMMENT		&quot;\n/* Just another comment. */\n&quot;
#define BUFFSIZE 64
#define SOURCE &quot;./rwex.c&quot;

int main()
{
  char buffer[BUFFSIZE];
  int fd;

  if ((fd = open(SOURCE, O_RDWR | O_APPEND)) == -1) {
    fprintf(stderr, &quot;Unable to open '%s': %s\n&quot;, SOURCE, strerror(errno));
    exit(EXIT_FAILURE);
  }

  int n;
  if ((n = read(fd, buffer, BUFFSIZE)) &gt; 0) {
    if (write(STDOUT_FILENO, buffer, n) != n) {
      fprintf(stderr, &quot;Unable to write: %s\n&quot;, strerror(errno));
      exit(EXIT_FAILURE);
    }
  }

  printf(&quot;\n\nOk, we read the first %d bytes. Now let's write something.\n&quot;, BUFFSIZE);
  
  int len = sizeof(COMMENT) - 1;
  if (write(fd, COMMENT, len) != len) {
    fprintf(stderr, &quot;Unable to write: %s\n&quot;, strerror(errno));
    exit(EXIT_FAILURE);
  }
  close(fd);

  return 0;
}
</code></pre>
<pre><code class="language-shell">$ gcc -o rwex rwex.c
$ ./rwex
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#inclu

Ok, we read the first 64 bytes. Now let's write something.
</code></pre>
<p>程序33-37行的作用是在文件<code>rwex.c</code>的末尾添<code>COMMENT</code>，效果是一个空行，一行注释文字。</p>
<h2 id="函数lseek">函数lseek</h2>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

off_t lseek(int fd, off_t offset, int whence);
//return values: new file offset if OK, -1 on error
</code></pre>
<p>也可以在终端通过命令<code>man lseek</code>查看<code>lseeek</code>的更详细内容。</p>
<p>每个文件都有一个与其关联的当前文件偏移量，通常是一个非负整数，度量从一个文件开始处计算的字节数。通常读、写操作都是从当前文件偏移量开始。参数<code>offset</code>和参数<code>whence</code>有关：</p>
<ul>
<li><code>whence = SEEK_SET</code>，将文件偏移量设置为距离文件开始处<code>offset</code>个字节。</li>
<li><code>whence = SEEK_CUR</code>， 将文件偏移量设置为当前偏移量加上<code>offset</code>，<code>offset</code>数值可正可负。</li>
<li><code>whence = SEEK_END</code>，将文件偏移量设置为文件长度加上<code>offset</code>。</li>
</ul>
<p><code>SEEK_SET, SEEK_CUR, SEEK_END</code>定义在头文件<code>&lt;stdio.h&gt;</code>内，可以打印查看其值：</p>
<pre><code class="language-c">//filename: test.c
#include &lt;stdio.h&gt;

int main()
{
    printf(&quot;SEEK_SET: %d\n&quot;, SEEK_SET);
    printf(&quot;SEEK_CUR: %d\n&quot;, SEEK_CUR);
    printf(&quot;SEEK_END: %d\n&quot;, SEEK_END);
    
    return 0;
}
</code></pre>
<pre><code class="language-shell">$ gcc test.c -o test
$ ./test
SEEK_SET: 0
SEEK_CUR: 1
SEEK_END: 2
</code></pre>
<p>用法：</p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

off_t currpos = lseek(fd, 0, SEEK_CUR); //fd is the file descriptor
</code></pre>
<p>如果文件描述符是指向一个管道、FIFO或网络套接字，则<code>lseek</code>返回-1，并将<code>errno</code>设置为<code>ESPIPE</code>。</p>
<pre><code class="language-c">//filename: lseek.c
#include &lt;stdio.h&gt;                               
#include &lt;sys/types.h&gt;                           
#include &lt;unistd.h&gt;                              
                                                 
int main()                                       
{                                                
    if (lseek(STDIN_FILENO, 0, SEEK_CUR) == -1)  
      printf(&quot;cannot seek!\n&quot;);                  
    else                                         
      printf(&quot;seek OK!\n&quot;);                      
                                                 
    return 0;                                    
}                                                
</code></pre>
<pre><code class="language-shell">$ gcc lseek.c -o lseek
$ ./lseek &lt; /etc/passwd
seek OK!
$ cat &lt; /etc/passwd | ./lseek
cannot seek!
</code></pre>
<p><code>lseek</code> 将当前文件偏移量记录在内核中，并不引起I/O操作。文件偏移量可以大于文件的当前长度。对该文件的写将加长文件并在文件上形成一个空洞，文件中没有写过的字节都被读为0.</p>
<p>APUE的55页程序，在<code>apue.h</code>里<code>FILE_MODE</code>是一个宏定义的变量：这些参数在第四章会有详细说明。</p>
<pre><code class="language-c">//apue.h
#define  FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
</code></pre>
<pre><code class="language-c">//filename: hole.c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;string.h&gt;

#define BIGNUM 10240000

int main()
{
  int fd;
  if ((fd = creat(&quot;file.hole&quot;, S_IRUSR | S_IWUSR)) == -1) {
    perror(&quot;creat error&quot;);
    return EXIT_FAILURE;
  }

  char buf1[] = &quot;abcdefghij&quot;;
  if (write(fd, buf1, strlen(buf1)) != (ssize_t)(strlen(buf1))) {
    perror(&quot;error writing buf1&quot;);
    return EXIT_FAILURE;
  }
  /* offset now is 10 */ 

  if (lseek(fd, BIGNUM, SEEK_CUR) == -1) {
    perror(&quot;lseek error&quot;);
    return EXIT_FAILURE;
  }
  /* offset now is 10 + 1024000 */

  char buf2[] = &quot;ABCDEFGHIJ&quot;;
  if (write(fd, buf2, strlen(buf2)) != (ssize_t)strlen(buf2)) {
    perror(&quot;error writing buf2&quot;); 		
    return EXIT_FAILURE;
  }
  /* offset now is 10 + 1024000 + 10 */

  return 0;
}
</code></pre>
<pre><code class="language-shell">$ gcc -o hole hole.c
$ ./hole
$ ls -l file.hole
-rw------- 1 kylin kylin 10240020 Nov 24 17:05 file.hole
$ od -c file.hole
0000000   a   b   c   d   e   f   g   h   i   j  \0  \0  \0  \0  \0  \0  
0000020  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  
*                                                                        
47040000  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0   A   B   C   D   E   F 
47040020   G   H   I   J                                                 
47040024       
$ cat file.hole &gt; file.nohole
$ ls -ls file.*
10004 -rw------- 1 kylin kylin 10240020 Nov 24 17:05 file.hole
11264 -rw-rw-rw- 1 kylin kylin 10240020 Nov 24 17:12 file.nohole
</code></pre>
<p>函数<code>perror()</code>的定义：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void perror(const char *s); // print a system error message
</code></pre>
<p>用来将上一个函数发生错误的原因输出到标准设备(<code>stderr</code>)。参数 <code>s</code>所指的字符串会先打印出,后面再加上错误原因字符串。此错误原因依照全局变量<code>errno</code> 的值来决定要输出的字符串。用法例子：</p>
<pre><code class="language-c">//filename: perror.c
#include &lt;stdio.h&gt;                
                                  
int main()                        
{                                 
  FILE *p;                        
  p = fopen(&quot;./nosuchfile&quot;, &quot;r+&quot;);
  if (p == NULL) {                
    perror(&quot;./nosuchfile&quot;);       
  }                               
                                  
  return 0;                       
}                                 
</code></pre>
<pre><code class="language-shell">$ gcc -o perror perror.c
$ ./perror
./nosuchfile: No such file or directory
</code></pre>
<p>函数<code>strlen()</code>的定义：</p>
<pre><code class="language-c">#include &lt;string.h&gt;

size_t strlen(const char *s); //calculate the length of a string
</code></pre>
<p>因为<code>write()</code>函数的返回类型是<code>ssize_t</code>，所以通过<code>(ssize_t)strlen(buf1)</code>来进行显示的强制类型转换。</p>
<p>命令<code>od</code> 是以8进制打印文件的实际内容，<code>-c</code>选项是选择可以打印的字符。</p>
<h2 id="io的效率">I/O的效率</h2>
<p>当<code>BUFFSIZE</code>超过4096时，继续增加缓冲区长度对时间几乎没有影响。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线段树]]></title>
        <id>https://zyq2652192993zyq.github.io//post/xian-duan-shu</id>
        <link href="https://zyq2652192993zyq.github.io//post/xian-duan-shu">
        </link>
        <updated>2019-12-15T07:24:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-线段树的背景">1 线段树的背景</h1>
<pre><code>题目一：
10000个正整数，编号1到10000，用A[1],A[2],A[10000]表示。
修改：无
统计：1.编号从L到R的所有数之和为多少？ 其中1&lt;= L &lt;= R &lt;= 10000.
</code></pre>
<ul>
<li>方法一：对于统计<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo separator="true">,</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L,R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> ，需要求下标从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>的所有数的和，从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>的所有下标记做<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>L</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>R</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[L..R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">]</span></span></span></span>,问题就是对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>L</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>R</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">A[L..R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">]</span></span></span></span>进行求和。这样求和，对于每个询问，需要将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>R</mi><mo>−</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(R-L+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>个数相加。</li>
<li>方法二：更快的方法是求前缀和,令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>S</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>=</mo><mi>A</mi><mo>[</mo><mn>1..</mn><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">S[0]=0, S[k]=A[1..k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span> ，那么，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>L</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>R</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">A[L..R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">]</span></span></span></span>的和就等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>[</mo><mi>R</mi><mo>]</mo><mo>−</mo><mi>S</mi><mo>[</mo><mi>L</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">S[R]-S[L-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，这样，对于每个询问，就只需要做一次减法，大大提高效率。</li>
</ul>
<pre><code>题目二：
10000个正整数，编号从1到10000，用A[1],A[2],A[10000]表示。
修改：1.将第L个数增加C （1 &lt;= L &lt;= 10000）
统计：1.编号从L到R的所有数之和为多少？ 其中1&lt;= L &lt;= R &lt;= 10000.
</code></pre>
<ul>
<li>再使用方法二的话，假如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>L</mi><mo>]</mo><mo>+</mo><mo>=</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A[L] += C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>之后，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>[</mo><mi>L</mi><mo>]</mo><mo separator="true">,</mo><mi>S</mi><mo>[</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mo separator="true">,</mo><mi>S</mi><mo>[</mo><mi>R</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">S[L],S[L+1],,S[R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">]</span></span></span></span>都需要增加<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>,全部都要修改，见下表。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>方法一</th>
<th>方法二</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>L</mi><mo>]</mo><mo>+</mo><mo>=</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A[L] += C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span></td>
<td>修改1个元素</td>
<td>修改<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>−</mo><mi>L</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">R-L+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个元素</td>
</tr>
<tr>
<td>求和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>L</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>R</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">A[L..R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">]</span></span></span></span></td>
<td>计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>−</mo><mi>L</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">R-L+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个元素之和</td>
<td>计算两个元素之差</td>
</tr>
</tbody>
</table>
<p>从上表可以看出，方法一修改快，求和慢。 方法二求和快，修改慢。线段树的出现就是设法使修改和求和都比较快。</p>
<p>线段树的出现是为了解决具有“<strong>区间加法</strong>”特性的一类问题，本质其实是<strong>分治</strong>的思想。比如：</p>
<ul>
<li>区间加法：左区间和 + 右区间和</li>
<li>最大公因数（GCD）：左区间GCD，右区间GCD</li>
<li>区间最值：左区间最值，右区间最值</li>
</ul>
<h1 id="2-线段树的实现">2 线段树的实现</h1>
<p><img src="https://raw.githubusercontent.com/zyq2652192993zyq/Picture-Bed/master/segmentTreeree.png" alt=""></p>
<h2 id="线段树的存储">线段树的存储</h2>
<p>线段树一般采取<strong>堆式储存法</strong>，构建方法既可以采用标准的二叉树存储，也可以采用数组来模拟。用数组模拟在解决编程问题时较为合适，可以根据题目的数据范围直接开一个大数组。</p>
<p>线段树从上图可以看出其不一定是完全二叉树，但是其节点编号的性质和完全二叉树相同。编号为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的节点的左儿子（如果有）的节点编号就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>k</mi></mrow><annotation encoding="application/x-tex">2k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，右儿子（如果有）的编号就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，父节点（如果有）的编号是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>，这里可以通过位运算优化以下。分别写成 <code>k &lt;&lt; 1</code> <code>k &lt;&lt; 1 | 1</code> <code>k &gt;&gt; 1</code>，解释一下<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&lt;</mo><mo>&lt;</mo><mn>1</mn><mi mathvariant="normal">∣</mi><mn>1</mn><mo>=</mo><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k &lt;&lt; 1 | 1 = 2k + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">∣</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>左移一位，那么二进制的最低位一定是0，与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>或运算最后一位就成了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，那么相当于总体加一了。</p>
<p>每个节点存储的数据应该包括：区间左边界<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span></span></span></span>，区间右边界<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span>，区间和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span>，懒惰标记<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>a</mi><mi>z</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">lazy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>：</p>
<pre><code class="language-c++">struct Node {
	int left, right;
	long long  sum;
	long long lazy;

	//Node():left(0), right(0), sum(0), lazy(0) {}
};

int N = 1000001; //叶节点的个数，设区间为[l, r]，则N = r - l + 1
vector&lt;Node&gt; v(N &lt;&lt; 2);
vector&lt;int&gt; num(N); //用来存储节点原始数据
</code></pre>
<p>这里需要关注一个细节，就是为什么要开4倍的数组空间，其实是和线段树的定义方式有关，线段树可以按下面两种方式定义：</p>
<ul>
<li>方式一：左子树：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo separator="true">,</mo><mfrac><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>+</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><mn>2</mn></mfrac><mo>]</mo></mrow><annotation encoding="application/x-tex">[left, \frac{left + right}{2}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span></span></span></span>，右子树：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mfrac><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>+</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><mn>2</mn></mfrac><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[\frac{left + right}{2} + 1, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mopen">[</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span></li>
</ul>
<p><img src="https://raw.githubusercontent.com/zyq2652192993zyq/Picture-Bed/master/segmentTreeree1.png" alt=""></p>
<ul>
<li>方式二：左子树：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo separator="true">,</mo><mfrac><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>+</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[left, \frac{left + right + 1}{2} - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，右子树：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mfrac><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>+</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[\frac{left + right + 1}{2}, right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mopen">[</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">]</span></span></span></span></li>
</ul>
<p><img src="https://raw.githubusercontent.com/zyq2652192993zyq/Picture-Bed/master/segmentTreeree2.png" alt=""></p>
<p>最坏情况应该是从第二种情况分析得出，因为此时最后一行除了两个叶节点以外，其他全是空节点。设倒数第二层的高度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>，那么倒数第二层的叶节点个数是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^h-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，因为全部叶节点个数是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，那么就有</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>=</mo><mi>n</mi><mspace linebreak="newline"></mspace><msup><mn>2</mn><mi>h</mi></msup><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^h-1+2=n\\
2^h = n -1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9824379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8991079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>因为要让线段树的下标属性和完全二叉树相同，那么就需要开辟<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>h</mi><mo>+</mo><mn>1</mn></mrow></msubsup><msup><mn>2</mn><mi>i</mi></msup><mo>=</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>+</mo><mn>2</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_{i = 0}^{h+1} 2^i=2^{h+2}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2887179999999998em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9324379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>大小的空间，把上面结果带入，那么就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mi>n</mi><mo>−</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">4n-5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>大小的空间，也就是最坏需要开辟4倍节点数的空间。</p>
<h2 id="线段树的初始化">线段树的初始化</h2>
<p>这里我们选择递归的方式来构建线段树，需要注意一个细节，就是求取中点的程序，我们看两种写法：</p>
<ul>
<li><code>int mid = (left + right) 2;</code></li>
<li><code>int mid = left + ((right - left) &gt;&gt; 1);</code></li>
</ul>
<p>虽然这两种表达式形式上一样，但是<strong>第一种情况可能存在溢出</strong>。不妨设想<code>right = INT_MAX - 1, left = 0</code>，第一次求<code>mid</code>没问题，但是第二次求<code>mid</code>的时候，<code>left</code>已经更新成<code>right / 2</code>了，这时候<code>left + right</code>就会溢出，所以第二种方式可以保证不会出错。同时在二分查找以及各种变形应用的时候，都应该关注这个细节。</p>
<p>这里<code>update</code>函数我们没有去检查需要更新的节点是否是叶节点，我们把这份工作交给其他函数去做，也就是说比如<code>build, query</code>等函数，都是先检查是否是叶节点。</p>
<pre><code class="language-c++">inline void update(int k)
{
	v[k].sum = v[k &lt;&lt; 1].sum + v[k &lt;&lt; 1 | 1].sum;
}

void build(int k, int leftPos, int rightPos)
{
	v[k].left = leftPos;
	v[k].right = rightPos;

	//递归到了叶节点可以停止了
	if (leftPos == rightPos) {
		 v[k].sum = num[leftPos];
		 return;
	}

	int mid = leftPos + ((rightPos - leftPos) &gt;&gt; 1);
	build(k &lt;&lt; 1, leftPos, mid);
	build(k &lt;&lt; 1 | 1, mid + 1, rightPos);
	update(k); //构建完成要更新当前节点的sum值
}
</code></pre>
<h2 id="单点修改">单点修改</h2>
<p>设当前节点编号是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，需要修改的节点编号是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，需要将节点的值修改为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span>，方法就类似于二叉查找树，修改的点肯定是叶节点，需要注意的是修改之后要更新包含此节点的区间所在的节点。</p>
<pre><code class="language-c++">void change(int k, int target, int value)
{
	//如果当前节点就是叶节点，直接修改，停止下滤
	if (v[k].left == v.right) {
		v.sum = value;
		return;
	}

	int mid = v[k].left + ((v[k].right - v[k].left) &gt;&gt; 1);

	if (target &lt;= mid) change(k &lt;&lt; 1, target, value);
	else change(k &lt;&lt; 1 | 1, target, value);
	update(k);
}
</code></pre>
<h2 id="区间修改与懒惰标记">区间修改与懒惰标记</h2>
<p>如果区间修改采取的策略是遍历区间的所有点，然后一一修改，那么线段树也就没什么存在意义了。比如在下面这种图，我要把区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>4</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[1, 4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">]</span></span></span></span>内的元素都加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>（如果赋值同理，只要自己明白<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>a</mi><mi>z</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">lazy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>最后的含义并且要全局统一），那么就更新区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[1,3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose">]</span></span></span></span>和区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>4</mn><mo separator="true">,</mo><mn>4</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[4, 4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">]</span></span></span></span>，更新区间的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span>值，令<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>a</mi><mi>z</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">lazy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>记录为此区间统一都需要修改的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，而区间内的节点先不修改，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>a</mi><mi>z</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">lazy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>的作用相当于一个标记。</p>
<p>需要考虑的有三种情形：</p>
<ul>
<li>需要更改的区间在中点的左边</li>
<li>需要修改的区间在中点的右边</li>
<li>需要修改的区间跨越中点</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zyq2652192993zyq/Picture-Bed/master/segmentTreeree1.png" alt=""></p>
<pre><code class="language-c++">void intervalChange(int k, int leftPos, int rightPos, int value)
{
	//恰好找到了一个完整的区间
	if (v[k].left == leftPos &amp;&amp; v[k].right == rightPos) {
		v[k].sum += (rightPos - leftPos + 1) * value;
		v[k].lazy += value;
		return;
	}

	pushDown(k);

	int mid = v[k].left + ((v[k].right - v[k].left) &gt;&gt; 1);
	if (rightPos &lt;= mid) intervalChange(k &lt;&lt; 1, leftPos, rightPos, value);
	else if (leftPos &gt; mid) intervalChange(k &lt;&lt; 1 | 1, leftPos, rightPos, value);
	else {
		intervalChange(k &lt;&lt; 1, leftPos, mid, value);
		intervalChange(k &lt;&lt; 1 | 1, mid + 1, rightPos, value);
	}
	update(k);
}
</code></pre>
<h2 id="区间查询与标记下传">区间查询与标记下传</h2>
<p>采用懒惰标记的一般针对只是想求取区间修改后的结果问题，比如对某个区间增加某一数值后的区间和，但是如果是区间查询，那么就必须要先标记下传再进行区间查询。</p>
<p>对于标记下传的理解可以想象过年发红包的情景，比如孩子A，B收到相同数额的红包，它们的父亲怕他们乱花钱，就统一在父亲那里保管，如果两个孩子需要用到这个红包（也就是线段树里的查询），就把红包再发下去。所以区间修改和区间查询都需要先标记下传，然后在执行其他操作。</p>
<pre><code class="language-c++">//标记下传
void pushDown(int k) 
{
	if (v[k].lazy) {
		v[k &lt;&lt; 1].lazy += v[k].lazy;
		v[k &lt;&lt; 1 | 1].lazy += v[k].lazy;
		v[k &lt;&lt; 1].sum += v[k].lazy * (v[k &lt;&lt; 1].right - v[k &lt;&lt; 1].left + 1);
		v[k &lt;&lt; 1 | 1].sum += v[k].lazy * (v[k &lt;&lt; 1 | 1].right - v[k &lt;&lt; 1 | 1].left + 1);
		v[k].lazy = 0;
	}
}
</code></pre>
<pre><code class="language-c++">//区间查询
long long query(int k, int leftPos, int rightPos)
{
	if (v[k].left == leftPos &amp;&amp; v[k].right == rightPos) 
		return v[k].sum;

	pushDown(k);

	int mid = v[k].left + ((v[k].right - v[k].left) &gt;&gt; 1);
	if (rightPos &lt;= mid) return query(k &lt;&lt; 1, leftPos, rightPos);
	else if (leftPos &gt; mid) return query(k &lt;&lt; 1 | 1, leftPos, rightPos);

	return query(k &lt;&lt; 1, leftPos, mid) + query(k &lt;&lt; 1 | 1, mid + 1, rightPos);
}
</code></pre>
<h1 id="权值线段树">权值线段树</h1>
<p>权值线段树维护<strong>数的个数，<strong>数组下标代表</strong>整个值域</strong>（如果值域太大，可以<strong>离散化</strong>）</p>
<p>权值线段树可以解决的问题：</p>
<ul>
<li>寻找第K大（整个区间，即左边界为1，右边界为n）</li>
<li>逆序对（归并排序也可以求解）</li>
</ul>
<p><u>标准练习：洛谷-P1801 黑匣子</u></p>
<p>询问整体第k大（query），在线段树上进行二分（即<strong>整体二分</strong>）：</p>
<p>先看左子树数的个数，设其个数为f.</p>
<ul>
<li>如果f&gt;=t递归进入左子树寻找</li>
<li>如果f&lt;k递归进入右子树寻找第f-k大</li>
</ul>
<h1 id="典型题目">典型题目</h1>
<ul>
<li><a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/blob/master/Problem%20Solution/POJ-3264%20Balanced%20Lineup(%E7%BA%BF%E6%AE%B5%E6%A0%91).md">POJ-3264 Balanced Lineup(线段树区间最大值，最小值查询)</a></li>
<li><a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/blob/master/Problem%20Solution/%E6%B4%9B%E8%B0%B7-P3374%20%5B%E6%A8%A1%E6%9D%BF%5D%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%841%EF%BC%88%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%EF%BC%89.md">洛谷-P3374 【模板】树状数组1（可以用线段树，单点修改，区间查询）</a></li>
<li><a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/blob/master/Problem%20Solution/%E6%B4%9B%E8%B0%B7-P3372%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%911%EF%BC%88%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%2B%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%EF%BC%89.md">洛谷-P3372 【模板】线段树1（区间修改 + 区间查询）</a></li>
<li><a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/blob/master/Problem%20Solution/%E6%B4%9B%E8%B0%B7-P1801%20%E9%BB%91%E5%8C%A3%E5%AD%90%EF%BC%88%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89.md">洛谷-P1801 黑匣子（权值线段树，也可以Spaly Tree, AVL或者堆）</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高精度问题]]></title>
        <id>https://zyq2652192993zyq.github.io//post/gao-jing-du-wen-ti</id>
        <link href="https://zyq2652192993zyq.github.io//post/gao-jing-du-wen-ti">
        </link>
        <updated>2019-12-15T06:44:52.000Z</updated>
        <content type="html"><![CDATA[<p>高精度问题主要包含以下几个子问题：</p>
<ul>
<li>高精度加法</li>
<li>高精度减法</li>
<li>高精度乘法
<ul>
<li>高精度 x 单精度</li>
<li>高精度 x 高精度</li>
</ul>
</li>
<li>高精度除法
<ul>
<li>高精度 / 单精度</li>
<li>高精度 / 高精度</li>
</ul>
</li>
</ul>
<hr>
<h1 id="高精度加法">高精度加法</h1>
<p>既可以用链表来计算，也可以用数组来计算，链表的方法在<a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge/blob/master/SJTU-OJ/1202.%20bigint.md">SJTU 1202 bigint</a>的里有写到，也可以参考我在<a href="https://github.com/zyq2652192993zyq/LeetCode/blob/master/Linked%20List/2.Add%20Two%20Numbers.md">LeetCode 2.Add Two Numbers</a>的思路。</p>
<p>思路主要是利用数组模拟，将数字翻转处理来模拟竖式加法，需要注意的细节是最高位可能存在进位，所以数组的长度会比最长的数字多出一位。特殊点就是<code>0+0</code>的情况以及出现前导0的情况，如<code>07</code>，可以把这种特殊情况放到输出里解决，因为数组多开了一位，所以如果多出的这一位不是0，那么结果也不可能是0。即使最终结果等于0，但是因为我们跳过了第一位，所以还是可以保证有效输出。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

vector&lt;char&gt; bigNumPlus(vector&lt;char&gt; &amp; num1, vector&lt;char&gt; &amp; num2)
{
	int extra = 0;
	for (size_t i = 0; i &lt; num1.size(); ++i) {
		int sum = (num1[i] - '0') + (num2[i] - '0') + extra;
		extra = sum / 10;
		num1[i] = '0' + sum % 10;
	}
	if (extra &amp; 1) num1[num1.size() - 1] = '1';
	reverse(num1.begin(), num1.end());

	return num1;
}

template &lt;typename T&gt;
ostream &amp; operator&lt;&lt;(ostream &amp; os, const vector&lt;T&gt; &amp; v)
{
	size_t i = 0;
	if (v[0] == '0') i = 1; 
	for ( ; i &lt; v.size(); ++i) {
		os &lt;&lt; v[i];
	}

	return os;
}

int main()
{
	string str1, str2;
	cin &gt;&gt; str1 &gt;&gt; str2;
	int length = max(str1.size(), str2.size()) + 1; //可能存在进位，所以多留出一位

	vector&lt;char&gt; num1(length, '0'), num2(length, '0');
	for (size_t i = 0; i &lt; str1.size(); ++i) {
		num1[str1.size() - 1 - i] = str1[i];
	}

	for (size_t i = 0; i &lt; str2.size(); ++i)
		num2[str2.size() - 1 - i] = str2[i];

	cout &lt;&lt; bigNumPlus(num1, num2) &lt;&lt; endl;

	return 0;
}
</code></pre>
<ul>
<li><a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/blob/master/Problem%20Solution/HDU-1002%20A%20%2B%20B%20Problem%202(%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95).md">HDU 1002</a></li>
<li><a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/blob/master/Problem%20Solution/HDU-1002%20A%20%2B%20B%20Problem%202(%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95).md">HDU 1002</a></li>
<li><a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge/blob/master/SJTU-OJ/1202.%20bigint.md">SJTU OJ 1202</a></li>
<li><a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/blob/master/Problem%20Solution/%E6%B4%9B%E8%B0%B7-P1601%20A%2BB%20Problem%EF%BC%88%E9%AB%98%E7%B2%BE%EF%BC%89.md">洛谷-P1601 A+B problem</a></li>
</ul>
<h1 id="高精度减法">高精度减法</h1>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

vector&lt;int&gt; sub(const vector&lt;int&gt; &amp; num1, const vector&lt;int&gt; &amp; num2)
{
	int length = num1.size();
	vector&lt;int&gt; res(length, 0);

	for (int i = 0; i &lt; length - 1; ++i) {
		res[i] += num1[i] - num2[i];
		if (res[i] &lt; 0) {
			res[i + 1] -= 1;
			res[i] += 10;
		}
	}
	res[length - 1] += num1[length - 1] - num2[length - 1];
	reverse(res.begin(), res.end());

	return res;
}

template &lt;typename T&gt;
ostream &amp; operator&lt;&lt;(ostream &amp; os, const vector&lt;T&gt; &amp; v)
{
	size_t i = 0;
    
	while (v[i] == 0) ++i;
	for ( ; i &lt; v.size(); ++i)
		os &lt;&lt; v[i];

	return os;
}


int main()
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);

	string str1, str2;
	cin &gt;&gt; str1 &gt;&gt; str2;

	if (str1 == str2) cout &lt;&lt; 0;
	else {
		bool flag = true;
		if (str1.size() &lt; str2.size() || (str1.size() == str2.size() &amp;&amp; str1 &lt; str2)) {
			std::swap(str1, str2);
			flag = false;
		} 

		int length = max(str1.size(), str2.size());
		vector&lt;int&gt; num1(length, 0), num2(length, 0);

		for (size_t i = 0; i &lt; str1.size(); ++i) num1[str1.size() - 1 - i] = str1[i] - '0';
		for (size_t i = 0; i &lt; str2.size(); ++i) num2[str2.size() - 1 - i] = str2[i] - '0';

		if (flag) cout &lt;&lt; sub(num1, num2);
		else cout &lt;&lt; &quot;-&quot; &lt;&lt; sub(num1, num2);
	}

	return 0;
}
</code></pre>
<ul>
<li><a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/blob/master/Problem%20Solution/%E6%B4%9B%E8%B0%B7-P2142%20%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95.md">洛谷-P2142 高精度减法</a></li>
</ul>
<p>这道题看上去和高精度加法类似，但是却布满坑点：</p>
<ul>
<li>两个字符串相减出现前导0，需要除去比如100-99</li>
<li>前导0并不是所有都需要除去，比如0-0或100-100</li>
<li>两个数相减可能为负，需要在结果前加负号，比较两个数的大小不能直接写成<code>str1 &lt; str2</code>，因为比如38和370，按照字符串的比较规则是<code>38 &gt; 370</code>，所以需要分为位数不同和位数相同两种情况计算。</li>
</ul>
<h1 id="高精度乘法">高精度乘法</h1>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

vector&lt;int&gt; multiply(const vector&lt;int&gt; &amp; num1, const vector&lt;int&gt; &amp; num2, int cnt)
{
	int length = num1.size();
	vector&lt;int&gt; res(length, 0);

	for (int i = 0; i &lt; cnt; ++i) {
		for (size_t j = 0; j &lt; num1.size(); ++j) {
			res[i + j] += num2[i] * num1[j];
		}
	}

	for (size_t i = 0; i &lt; res.size() - 1; ++i) {
		if (res[i] &gt;= 10) {
			res[i + 1] += res[i] / 10;
			res[i] = res[i] % 10;
		}
	}
	reverse(res.begin(), res.end());

	return res;
}

template &lt;typename T&gt;
ostream &amp; operator&lt;&lt;(ostream &amp; os, const vector&lt;T&gt; &amp; v)
{
	size_t i = 0;
    
	while (v[i] == 0) ++i; //处理前导0
	for ( ; i &lt; v.size(); ++i)
		os &lt;&lt; v[i];

	return os;
}


int main()
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);

	string str1, str2;
	cin &gt;&gt; str1 &gt;&gt; str2;

	if (str1 == &quot;0&quot; || str2 == &quot;0&quot;) cout &lt;&lt; 0;
	else if (str1 == &quot;1&quot;) cout &lt;&lt; str2;
	else if (str2 == &quot;1&quot;) cout &lt;&lt; str1;
	else {
		if (str1.size() &lt; str2.size()) std::swap(str1, str2);
		int length = 2 * max(str1.size(), str2.size());
		vector&lt;int&gt; num1(length, 0), num2(length, 0);
		int cnt = str2.size();

		for (size_t i = 0; i &lt; str1.size(); ++i) num1[str1.size() - 1 - i] = str1[i] - '0';
		for (size_t i = 0; i &lt; str2.size(); ++i) num2[str2.size() - 1 - i] = str2[i] - '0';
		cout &lt;&lt; multiply(num1, num2, cnt);
	}	

	return 0;
}
</code></pre>
<p>这里模拟竖式乘法的时候，始终保持利用数位最小的数的每一位去乘上数位较大的数，最后统一进位。相当于OI Wiki里面“高精度——单精度”的思想，时间复杂度从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>优化到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n,m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span></span></span></span>分别是字符串的长度。</p>
<p>典型题目：</p>
<ul>
<li><a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/blob/master/Problem%20Solution/%E6%B4%9B%E8%B0%B7-P1303%20AB%20Problem.md">洛谷-P1303 A*B Problem</a></li>
</ul>
<p>需要考虑的问题：</p>
<ul>
<li>其中一个数是0</li>
<li>其中一个数是1</li>
<li>考虑前导0</li>
<li>两个数中有一个负数</li>
<li>两个数中有两个负数</li>
</ul>
<p>最后两点在题目里是不需要考虑的，因为题目默认都是给定正数。即使是负数，只需要增加变量来记录符号，影响不大。</p>
<p>高精度乘法可以涉及的知识点：</p>
<ul>
<li>快速傅里叶变换： 洛谷-P1919</li>
<li>Karatsuba乘法</li>
</ul>
<h1 id="高精度除法">高精度除法</h1>
<p>主要包含两种方法：</p>
<ul>
<li>高精度除以单精度</li>
<li>高精度除以高精度</li>
</ul>
<pre><code class="language-c++">//高精度除以单精度
#include &lt;string&gt;
#include &lt;iostream&gt;

using namespace std;

int main()
{
	string str;
	long long num;
	cin &gt;&gt; str &gt;&gt; num;

	if (str == &quot;0&quot;) cout &lt;&lt; 0;
    else if (num == 1) cout &lt;&lt; str;
	else {
		string res;
		long long extra = 0;
		for (size_t i = 0; i &lt; str.size(); ++i) {
			long long tmp = extra * 10 + (str[i] - '0');
			res += to_string(tmp / num);
			extra = tmp % num;
		}
		int pos = 0;
		while (res[pos] == '0') ++pos;
		res = res.substr(pos);
		cout &lt;&lt; res;
	}
	
	return 0;
}
</code></pre>
<pre><code class="language-c++">//高精度除以高精度
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

struct bigNum {
	vector&lt;int&gt; num;
	int len;

	bigNum(int n): len(n) {num.assign(n, 0);}
};

bool compare(const bigNum &amp; a, const bigNum &amp; b)
{
	if (a.len &lt; b.len) return false;
	if (a.len &gt; b.len) return true;
	for (int i = a.len - 1; i &gt;= 0; --i) {
		if (a.num[i] &lt; b.num[i]) return false;
		else if (a.num[i] &gt; b.num[i]) return true;
	}

	return true; //两个数完全一致
}

void subtraction(bigNum &amp; a, const bigNum &amp; minus)
{
	for (int i = 0; i &lt; minus.len; ++i) {
		a.num[i] -= minus.num[i];
		if (a.num[i] &lt; 0) {
			--a.num[i + 1];
			a.num[i] += 10;
		}
	}

	for (int i = a.len - 1; i &gt;= 0; --i) {
		if (a.num[i] != 0) {
			a.len = i + 1; //更新被减数的长度
			return;
		}
	}
	a.len = 0; //恰好整除，a所有位都是0
}

vector&lt;int&gt; divide(bigNum &amp; a, const bigNum &amp; b)
{
	vector&lt;int&gt; res(a.len - b.len + 1, 0);
	for (int i = res.size() - 1; i &gt;= 0; --i) {
		if (a.len == 0) break;
		bigNum minus(b.len + i); //构造被减数
		for (int j = b.len - 1; j &gt;= 0; --j) minus.num[j + i] = b.num[j];
		
		while (compare(a, minus)) {
			subtraction(a, minus);
			++res[i];
		}
	}
	reverse(res.begin(), res.end());


	return res;
}

ostream &amp; operator&lt;&lt;(ostream &amp; os, const vector&lt;int&gt; &amp; v)
{
	size_t i = 0;
	while (v[i] == 0) ++i;
	for ( ; i &lt; v.size(); ++i) os &lt;&lt; v[i];

	return os;
}

int main()
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);

	string str1, str2;
	cin &gt;&gt; str1 &gt;&gt; str2;
	

	if (str1 == &quot;0&quot;) cout &lt;&lt; 0;
	else if (str2 == &quot;1&quot;) cout &lt;&lt; str1;
	else if (str1.size() &lt; str2.size() || (str1.size() == str2.size() &amp;&amp; str1 &lt; str2)) cout &lt;&lt; 0;
	else if (str1 == str2) cout &lt;&lt; 1;
	else {
		int length = max(str1.size(), str2.size());
		bigNum a(length), b(length);
		b.len = str2.size();
		//倒序处理，便于后续大数减法的运算
		for (size_t i = 0; i &lt; str1.size(); ++i) a.num[str1.size() - 1 - i] = str1[i] - '0';
		for (size_t i = 0; i &lt; str2.size(); ++i) b.num[str2.size() - 1 - i] = str2[i] - '0';

		cout &lt;&lt; divide(a, b);
	}
	
	return 0;
}
</code></pre>
<p>高精度除以高精度的思想其实是高精度减法，可以根据被除数和除数来得出商的最大位数，然后每次在除数后面添加0，构成一个减数，然后去模拟竖式除法。</p>
<pre><code>//输入的两个大数分别位a， b，长度分别是M和N，计算12345/45
//商的最大位数i=M-N+1，即4，设计一个 临时减数，减数后面补齐i-1个0，再进行减法
i=4     12345 &lt; 45000   可以减0个   res[4]=0      减后A：12345
i=3     12345 &lt; 4500    可以减2个   res[3]=2      减后A：3345
i=2     3345  &lt; 450     可以减7个   res[2]=7      减后A：195
i=1     195   &lt; 45      可以减4个   res[1]=4      减后A：15

//res[4]=0，故商的有效位数res[0]--，为3
//结果  商为274，余数15
</code></pre>
<p>相当于对竖式除法的模拟。</p>
<p>典型题目：</p>
<ul>
<li><a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/blob/master/Problem%20Solution/%E6%B4%9B%E8%B0%B7-P1480%20A%E9%99%A4B%20Problem.md">洛谷-P1480 A/B Problem （高精度除以单精度）</a></li>
<li><a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/blob/master/Problem%20Solution/%E6%B4%9B%E8%B0%B7-P2005%20AB%20Problem%20II.md">洛谷-P2005 A/B Problem 2 (高精度除以高精度)</a></li>
<li><a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge/blob/master/SJTU-OJ/1016.%20%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95.md">SJTU OJ 1016 （高精度除以高精度)</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最大子矩形的降维分析方法]]></title>
        <id>https://zyq2652192993zyq.github.io//post/zui-da-zi-ju-xing-de-jiang-wei-fen-xi-fang-fa</id>
        <link href="https://zyq2652192993zyq.github.io//post/zui-da-zi-ju-xing-de-jiang-wei-fen-xi-fang-fa">
        </link>
        <updated>2019-11-11T03:21:30.000Z</updated>
        <content type="html"><![CDATA[<p>最大子矩形类问题有很多种形式：比如找最大01矩阵，比如找最大子矩形和等。这里将其限制在最大子矩形和上，通过<code>LeetCode 363.Max Sum of Rectangle No Larger Than K</code>这样一道<code>Hard</code>类型的题目来讲述降维的分析方法。</p>
<p>Given a non-empty 2D matrix <em>matrix</em> and an integer <em>k</em>, find the max sum of a rectangle in the <em>matrix</em> such that its sum is no larger than <em>k</em>.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: matrix = [[1,0,1],[0,-2,3]], k = 2
Output: 2 
Explanation: Because the sum of rectangle [[0, 1], [-2, 3]] is 2,
             and 2 is the max number no larger than k (k = 2).
</code></pre>
<p><strong>Note:</strong></p>
<ol>
<li>The rectangle inside the matrix must have an area &gt; 0.</li>
<li>What if the number of rows is much larger than the number of columns?</li>
</ol>
<hr>
<p>这道题目初看如果采用暴力搜索，时间复杂度一定很高，但是联系之前做过的一维最大连续子数组，是否可以从中去找到一些思路？总结下来主要分为四个关键步骤：</p>
<ul>
<li>一维数组下最大的连续子数组和</li>
<li>一维数组下不超过K的最大连续子数组和（变形问题：小于K等）</li>
<li>二维数组的最大子矩形的和</li>
<li>二维数组下不超过K的最大子矩形和（本题）。</li>
</ul>
<h1 id="一维数组下最大的连续子数组和">一维数组下最大的连续子数组和</h1>
<p>也就是<code>53.Maximum Subarray</code>，列出一个状态转移方程即可，当前元素加入前面序列，或者另起一个新的序列。</p>
<p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
</code></pre>
<p><strong>Follow up:</strong></p>
<p>If you have figured out the O(<em>n</em>) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<hr>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>d</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>max</mi><mo>⁡</mo><mo>{</mo><mi>d</mi><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>+</mo><mi>S</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo separator="true">,</mo><mi>S</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>}</mo><mo separator="true">,</mo><mi mathvariant="normal">其</mi><mi mathvariant="normal">中</mi><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>target</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>max</mi><mo>⁡</mo><mo>{</mo><mi>d</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>}</mo><mo separator="true">,</mo><mi mathvariant="normal">其</mi><mi mathvariant="normal">中</mi><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} 
d[j] &amp;=\max \{d[j-1]+S[j], S[j]\}, 其中1 \leq j \leq n \\
\text {target} &amp;=\max \{d[j]\},其中1 \leq j \leq n
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000000000000004em;vertical-align:-1.2500000000000002em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">target</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop">max</span><span class="mopen">{</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">n</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop">max</span><span class="mopen">{</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<pre><code class="language-c++">class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int tmpSum, maxSum;
        tmpSum = maxSum = nums[0];
        
        for (int i = 1; i &lt; nums.size(); ++i){
            tmpSum = max(tmpSum + nums[i], nums[i]);
            maxSum = max(maxSum, tmpSum);
        }
        
        return maxSum;
    }
};
</code></pre>
<h1 id="一维数组下不超过k的最大连续子数组和">一维数组下不超过K的最大连续子数组和</h1>
<p>这个问题还可以衍生出下列三种变化形式：</p>
<ul>
<li>一维数组下小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>的最大连续子数组和</li>
<li>一维数组下不小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>的最小连续子数组和</li>
<li>一维数组下大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>的最小连续子数组和</li>
</ul>
<ol>
<li>首先分析<strong>一维数组下不超过K的最大连续子数组和</strong></li>
</ol>
<p><strong>一维数组下最大的连续子数组和</strong>可以视为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo>=</mo><mo>+</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">K = +\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">∞</span></span></span></span>的特殊情形。这里采用前缀和的思路，不妨设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">S_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是数组前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>项的和，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>是数组前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>项的和，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><msub><mi>S</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_m - S_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>就是数组从位置<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>到位置<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>的和，也就是一个子数组的和。</p>
<p>原问题可以转化成：设满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><msub><mi>S</mi><mi>n</mi></msub><mo>≤</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_m -S_n \leq k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的集合为可行集<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span>，我们要找<code>max_element(Q)</code>。对于每一次查找过程，可以认为在对应次查找中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">S_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>是固定的，也就是要去寻找<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的位置，因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub><mo>≥</mo><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_n \geq S_m -k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，要使能找到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span>里面最大的值，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>应该尽可能的小，也就是寻找<strong>第一个不小于目标值的数</strong>，所以应选择<code>lower_bound</code>。时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

const int INF = 0x0ffffff;

int maxSubArray(vector&lt;int&gt; &amp; nums, int k)
{
    set&lt;int&gt; prefixSum;
    prefixSum.emplace(0);
    int sum = 0, tmpSum = -INF;

    for (auto e : nums) {
        sum += e;
        auto pos = prefixSum.lower_bound(sum - k);
        if (pos != prefixSum.end() &amp;&amp; sum - *pos &gt; tmpSum) {
            tmpSum = sum - *pos;
            if (tmpSum == k){
                return tmpSum;
            }
        }
        prefixSum.emplace(sum);
    }

    return tmpSum;
}


int main()
{
    vector&lt;int&gt; nums = {-2,1,-3,4,-1,2,1,-5,4};
    int k = 5; //6为最大
    cout &lt;&lt; maxSubArray(nums, k) &lt;&lt; endl;

    return 0;
}
//输出为5
</code></pre>
<p>这里如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>小于数组里的所有数，那么就输出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mi>I</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">-INF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span>。</p>
<ol start="2">
<li>题目变形，分析<strong>一维数组下小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>的最大连续子数组和</strong></li>
</ol>
<p>相当于找<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><msub><mi>S</mi><mi>n</mi></msub><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_m - S_n &lt; k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，转化为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub><mo>&gt;</mo><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_n &gt; S_m - k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，这里为了让<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_m - S_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>尽可能的大，那么应该让<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>尽可能的小，所以对应次查找可以认为目标值是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_m - k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，也就是<strong>找第一个大于目标值的数</strong>，也就是用函数<code>upper_bound</code>。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

const int INF = 0x0ffffff;

int maxSubArray(vector&lt;int&gt; &amp; nums, int k)
{
    set&lt;int&gt; prefixSum;
    prefixSum.emplace(0);
    int sum = 0, tmpSum = -INF;

    for (auto e : nums) {
        sum += e;
        auto pos = prefixSum.upper_bound(sum - k);
        if (pos != prefixSum.end() &amp;&amp; sum - *pos &gt; tmpSum) {
            tmpSum = sum - *pos;
            if (tmpSum == k){
                return tmpSum;
            }
        }
        prefixSum.emplace(sum);
    }

    return tmpSum;
}


int main()
{
    vector&lt;int&gt; nums = {-2,1,-3,4,-1,2,1,-5,4};
    int k = 5; //6为最大
    cout &lt;&lt; maxSubArray(nums, k) &lt;&lt; endl;

    return 0;
}
//输出为4
</code></pre>
<ol start="3">
<li><strong>一维数组下不小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>的最小连续子数组和</strong>。（类似<code>leetcode 862.Shortest Subarray with Sum at Least K</code>）</li>
</ol>
<p>这个问题其实和<code>LeetCode 862</code>只是题面类似，但是解题方法可是差别很大。题目等价于找<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><msub><mi>S</mi><mi>n</mi></msub><mo>≥</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_m - S_n \geq k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，转化为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub><mo>≤</mo><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_n \leq S_m -k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，并且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>还要尽可能的大，那么目标值就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_m - k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，相当于找最后一个不大于目标值的数，则转化为<code>upper_bound</code>的问题，因为<code>upper_bound</code>找到的是第一个大于目标值的数，那么这个数前面的就是<strong>最后一个不大于目标值的数</strong>。相较于前面的问题，只需要将迭代器位置前移一个位置即可。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

const int INF = 0x0ffffff;

int maxSubArray(vector&lt;int&gt; &amp; nums, int k)
{
    set&lt;int&gt; prefixSum;
    prefixSum.emplace(0);
    int sum = 0, tmpSum = INF;

    for (auto e : nums) {
        sum += e;
        auto pos = prefixSum.upper_bound(sum - k);
        if (pos != prefixSum.begin() &amp;&amp; sum - *prev(pos) &lt; tmpSum &amp;&amp; sum - *prev(pos) &gt;= k) {
            tmpSum = sum - *prev(pos);
            if (tmpSum == k){
                return tmpSum;
            }
        }
        prefixSum.emplace(sum);
    }

    return tmpSum;
}


int main()
{
    vector&lt;int&gt; nums = {-2,1,-3,4,-1,2,1,-5,4};
    int k = -7; //6为最大
    cout &lt;&lt; maxSubArray(nums, k) &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>这里分别令<code>k = -7, k = 0, k = 5, k = 10</code>来进行验证，依次输出<code>-5, 0, 5, INF</code>则正确。</p>
<ol start="4">
<li><strong>一维数组下大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>的最小连续子数组和</strong></li>
</ol>
<p>题目等价于找<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><msub><mi>S</mi><mi>n</mi></msub><mo>&gt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_m - S_n &gt; k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，转化为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub><mo>&lt;</mo><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_n &lt; S_m -k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，并且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>还要尽可能的大，那么目标值就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_m - k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，相当于找最后一个小于目标值的数，则转化为<code>lower_bound</code>的问题，因为<code>lower_bound</code>找到的是第一个不小于目标值的数，那么这个数前面的就是<strong>最后一个小于目标值的数</strong>。相较于前面的问题，只需要将迭代器位置前移一个位置即可。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

const int INF = 0x0ffffff;

int maxSubArray(vector&lt;int&gt; &amp; nums, int k)
{
    set&lt;int&gt; prefixSum;
    prefixSum.emplace(0);
    int sum = 0, tmpSum = INF;

    for (auto e : nums) {
        sum += e;
        auto pos = prefixSum.lower_bound(sum - k);
        if (pos != prefixSum.begin() &amp;&amp; sum - *prev(pos) &lt; tmpSum &amp;&amp; sum - *prev(pos) &gt; k) {
            tmpSum = sum - *prev(pos);
            if (tmpSum == k){
                return tmpSum;
            }
        }
        prefixSum.emplace(sum);
    }

    return tmpSum;
}


int main()
{
    vector&lt;int&gt; nums = {-2,1,-3,4,-1,2,1,-5,4};
    int k = 5; //6为最大
    cout &lt;&lt; maxSubArray(nums, k) &lt;&lt; endl;

    return 0;
}
</code></pre>
<h1 id="二维数组的最大子矩形的和">二维数组的最大子矩形的和</h1>
<p>一维的最大连续子数组我们已经会求了，那么二维的情况可以把他压缩成一维的情况。可以参考的题目是<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1081">HDU 1081.To The Max</a>。</p>
<pre><code class="language-c++">//HDU 1081
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

const int INF = 0x0ffffff;

int maxSubArray(vector&lt;int&gt; &amp; nums)
{
    int n = nums.size();
    if (n == 0) return INF;

    int res = -INF, tmpSum = 0;
    // for (auto e : nums) {
    //     tmpSum = max(tmpSum + e, e);
    //     res = max(res, tmpSum);
    // }
    for (int i = 0; i &lt; n; ++i) {
        tmpSum = max(tmpSum + nums[i], nums[i]);
        res = max(res, tmpSum);
    }

    return res;
}


int maxSubMatrix(vector&lt;vector&lt;int&gt; &gt; &amp; nums)
{
    int m = nums.size();
    int res = -INF;
    int n = nums[0].size();

    vector&lt;int&gt; subMax(n, 0);

    for (int i = 0; i &lt; m; ++i) {
        fill(subMax.begin(), subMax.end(), 0);
        for (int j = i; j &lt; m; ++j) {
            for (int k = 0; k &lt; n; ++k) {
                subMax[k] += nums[j][k];
            }
            res = max(res, maxSubArray(subMax));
        }
    }

    return res;
}

int main()
{
    std::ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n;
    cin &gt;&gt; n;
    vector&lt;vector&lt;int&gt; &gt; matrix(n, vector&lt;int&gt;(n, 0));
    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            cin &gt;&gt; matrix[i][j];
        }
    }

    cout &lt;&lt; maxSubMatrix(matrix) &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>这道题目如果把上面代码直接粘过去会<code>wrong answer</code>，但是放到<a href="http://poj.org/problem?id=1050">POJ 1050-To the Max</a>就会通过，注意POJ不支持C++11的许多新特性。</p>
<h1 id="二维数组下不超过k的最大子矩形和本题">二维数组下不超过K的最大子矩形和（本题）</h1>
<p>如果上面的方法掌握了，那么会发现到这里只需要去把<code>res = max(res, maxSubArray(subMax));</code>改为<code>res = max(res, maxSubArray(subMax, k));</code>即可。代码见最下方。</p>
<p>那么扩展一下，如果要找小于k的最大子矩形和呢？改动的也只有两个地方，一个是在时间复杂度选择那里，不能出现等于的情况；另一个就是传入的<code>maxSubArray</code>函数的形式应该根据第二大类的讨论来进行相应修改。</p>
<p>进一步，如果想找不小于k的最小子矩形和呢？找大于k的最小子矩形和呢？方法就同理了。</p>
<p>回到本题，会发现一个很奇怪的现象，下面几段代码均可通过，但是速度却是千差万别！</p>
<p>先看一个超时但是思路是正确的（在倒数第二个大数据量超时）</p>
<pre><code>Time Limit Exceeded.
</code></pre>
<pre><code class="language-c++">class Solution {
int maxSubArray(vector&lt;int&gt; &amp; nums, int k)
{
    set&lt;int&gt; prefixSum;
    prefixSum.emplace(0);
    int sum = 0, tmpSum = INT_MIN;

    for (auto e : nums) {
        sum += e;
        auto pos = prefixSum.lower_bound(sum - k);
        if (pos != prefixSum.end() &amp;&amp; sum - *pos &gt; tmpSum) {
            tmpSum = sum - *pos;
            if (tmpSum == k){
                return tmpSum;
            }
        }
        prefixSum.emplace(sum);
    }

    return tmpSum;
}
    
public:
    int maxSumSubmatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {
        std::ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        
        int res = INT_MIN;
        int n = matrix[0].size(), m = matrix.size();

        vector&lt;int&gt; subMax(n, 0);

        for (int i = 0; i &lt; m; ++i) {
            fill(subMax.begin(), subMax.end(), 0);
            for (int j = i; j &lt; m; ++j) {
                for (int k = 0; k &lt; n; ++k) {
                    subMax[k] += matrix[j][k];
                }
                res = max(res, maxSubArray(subMax, k));
            }
        }

        return res;
    }
};
</code></pre>
<p>下面这个仅仅是改动了通过行求子数组还是列求子数组，代码就通过了。</p>
<pre><code>Runtime: 380 ms
Memory Usage: 106.5 MB
</code></pre>
<pre><code class="language-c++">class Solution {
int maxSubArray(vector&lt;int&gt; &amp; nums, int k)
{
    set&lt;int&gt; prefixSum;
    prefixSum.emplace(0);
    int sum = 0, tmpSum = INT_MIN;

    for (auto e : nums) {
        sum += e;
        auto pos = prefixSum.lower_bound(sum - k);
        if (pos != prefixSum.end() &amp;&amp; sum - *pos &gt; tmpSum) {
            tmpSum = sum - *pos;
            if (tmpSum == k){
                return tmpSum;
            }
        }
        prefixSum.emplace(sum);
    }

    return tmpSum;
}
    
public:
    int maxSumSubmatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {
        std::ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        
        int res = INT_MIN;
        int n = matrix[0].size(), m = matrix.size();

        if (m * m * n &lt; n * n * m) {
            for (int i = 0; i &lt; m; ++i) {
                vector&lt;int&gt; subMax(n, 0);
                for (int j = i; j &lt; m; ++j) {
                    for (int k = 0; k &lt; n; ++k) {
                        subMax[k] += matrix[j][k];
                    }
                    res = max(res, maxSubArray(subMax, k));
                }
            }
        }
        else{
            for (int i = 0; i &lt; n; ++i) {
                vector&lt;int&gt; subMax(m, 0);
                for (int j = i; j &lt; n; ++j) {
                    for (int k = 0; k &lt; m; ++k) {
                        subMax[k] += matrix[k][j];
                    }
                    res = max(res, maxSubArray(subMax, k));
                }
            }
        }
        
        return res;
    }
};
</code></pre>
<p>下面这个版本增加了一步判断，如果连续子数组的最大值都小于k，那么就没必要去寻找不超过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>的子数组了，相当于节省了比较费时的一步。这里其实应该可以想到，毕竟找最大连续子数组时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，而找不超过k的连续子数组时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。效果很明显，时间降了一半多。</p>
<pre><code>Runtime: 128 ms
Memory Usage: 11.1 MB
</code></pre>
<pre><code class="language-c++">class Solution {
int maxSubArray(vector&lt;int&gt; &amp; nums, int k)
{
    set&lt;int&gt; prefixSum;
    prefixSum.emplace(0);
    int sum = 0, tmpSum = INT_MIN;

    for (auto e : nums) {
        sum += e;
        auto pos = prefixSum.lower_bound(sum - k);
        if (pos != prefixSum.end() &amp;&amp; sum - *pos &gt; tmpSum) {
            tmpSum = sum - *pos;
            if (tmpSum == k){
                return tmpSum;
            }
        }
        prefixSum.emplace(sum);
    }

    return tmpSum;
}

int maxSubArray(vector&lt;int&gt; &amp; nums)
{
    int n = nums.size();
    if (n == 0) return INT_MIN;

    int res = INT_MIN, tmpSum = 0;
    for (auto e : nums) {
        tmpSum = max(tmpSum + e, e);
        res = max(res, tmpSum);
    }

    return res;
}
    
public:
    int maxSumSubmatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {
        int res = INT_MIN;
        int n = matrix[0].size(), m = matrix.size();

        for (int i = 0; i &lt; m; ++i) {
            vector&lt;int&gt; subMax(n, 0);
            for (int j = i; j &lt; m; ++j) {
                for (int k = 0; k &lt; n; ++k) {
                    subMax[k] += matrix[j][k];
                }
                int tmp = maxSubArray(subMax);
                if (tmp &lt;= k) {
                    res = max(res, tmp);
                    continue;
                }
                res = max(res, maxSubArray(subMax, k));
            }
        }
        
        
        return res;
    }
};
auto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();
</code></pre>
<p>来看看讨论区的20ms的解法和我的差别在哪里。差别在于它只选择通过列来寻找。速度是20ms。它的<code>maxS</code>就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>。</p>
<pre><code class="language-c++">class Solution {
public:
    int maxSumSubmatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int maxS) {
        int maxA = INT32_MIN, r = matrix.size(), c = matrix[0].size();
        for(int i = 0; i &lt; c; ++i) {
            vector&lt;int&gt; sum(r, 0);
            if(maxA == maxS) return maxA; // Stop if we can reach maxS
            for(int j = i; j &lt; c; ++j) {
                for(int k = 0; k &lt; r; ++k) sum[k] += matrix[k][j];
                
                //First try Kadane's Algo and see if maxSum is less than maxS. 
                int curMax = INT32_MIN, curSum = 0;
                for(int k = 0; k &lt; r; ++k) {
                    curSum += sum[k];
                    curMax = max(curMax, curSum);
                    if(curSum &lt; 0) curSum = 0;
                }
                if(curMax &lt;= maxS) {maxA = max(maxA, curMax); continue;}
                
                // Only apply slow method when there maxSum that is greater than maxS.
                int csum = 0;
                set&lt;int&gt; s({csum});
                for(int k = 0; k &lt; r; ++k) {
                    csum += sum[k];
                    auto it = s.lower_bound(csum - maxS);
                    if(it != s.end()) maxA = max(maxA, csum - *it);
                    s.insert(csum);
                }
            }
        }
        return maxA;
    }
};

auto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();
</code></pre>
<p>于是我把刚刚运行128ms的代码改成通过按列来寻找，速度确实立刻到了16ms。</p>
<pre><code>Runtime: 16 ms
Memory Usage: 11 MB
</code></pre>
<pre><code class="language-c++">class Solution {
int maxSubArray(vector&lt;int&gt; &amp; nums, int k)
{
    set&lt;int&gt; prefixSum;
    prefixSum.emplace(0);
    int sum = 0, tmpSum = INT_MIN;

    for (auto e : nums) {
        sum += e;
        auto pos = prefixSum.lower_bound(sum - k);
        if (pos != prefixSum.end() &amp;&amp; sum - *pos &gt; tmpSum) {
            tmpSum = sum - *pos;
            if (tmpSum == k){
                return tmpSum;
            }
        }
        prefixSum.emplace(sum);
    }

    return tmpSum;
}

int maxSubArray(vector&lt;int&gt; &amp; nums)
{
    int n = nums.size();
    if (n == 0) return INT_MIN;

    int res = INT_MIN, tmpSum = 0;
    for (auto e : nums) {
        tmpSum = max(tmpSum + e, e);
        res = max(res, tmpSum);
    }

    return res;
}
    
public:
    int maxSumSubmatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {
        int res = INT_MIN;
        int n = matrix[0].size(), m = matrix.size();

        for (int i = 0; i &lt; n; ++i) {
            vector&lt;int&gt; subMax(m, 0);
            for (int j = i; j &lt; n; ++j) {
                for (int k = 0; k &lt; m; ++k) {
                    subMax[k] += matrix[k][j];
                }
                int tmp = maxSubArray(subMax);
                if (tmp &lt;= k) {
                    res = max(res, tmp);
                    continue;
                }
                res = max(res, maxSubArray(subMax, k));
            }
        }
        
        
        return res;
    }
};
auto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();
</code></pre>
<p>通过上面的一系列探索，可以发现有两个关键点：</p>
<ul>
<li>在时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的判断选择上，这个必须有才能进行加速。</li>
<li>在通过行还是列来进行搜索区别很大，也就是总体时间复杂度或者是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>m</mi><mn>2</mn></msup><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m^2nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，或者是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2mlogm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，所以比较<code>m*m*n</code>和<code>n*n*m</code>很有必要。</li>
</ul>
<p>此题只是恰好通过列来搜索较优，实际上需要在最开始就进行一次判断，可自行测试。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[有环单链表问题总结]]></title>
        <id>https://zyq2652192993zyq.github.io//post/you-huan-dan-lian-biao-wen-ti-zong-jie</id>
        <link href="https://zyq2652192993zyq.github.io//post/you-huan-dan-lian-biao-wen-ti-zong-jie">
        </link>
        <updated>2019-11-04T07:01:56.000Z</updated>
        <content type="html"><![CDATA[<p>有环单链表问题总结下来主要有以下几个子问题：</p>
<ul>
<li>如何判断一个单链表是否有环？（<code>LeetCode 141.Linked List Cycle</code>）</li>
<li>单链表有环，如何找到环的入口节点？（<code>LeetCode 142.Linked List Cycle II</code>）</li>
<li>单链表有环，如何破环？</li>
<li>单链表有环，输出环的长度。</li>
<li>无环单链表的中间节点。</li>
<li>如何判断两个单链表是否相交？（《编程之美》）</li>
<li>两个无环单链表相交，如何找到交点？</li>
<li>两个单链表可能有环，如何判断两个单链表是否相交？</li>
</ul>
<hr>
<h1 id="如何判断一个单链表是否有环">如何判断一个单链表是否有环？</h1>
<p>Given a linked list, determine if it has a cycle in it.</p>
<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where tail connects to the second node.
</code></pre>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<p><strong>Example 2:</strong></p>
<pre><code>Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where tail connects to the first node.
</code></pre>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<p><strong>Example 3:</strong></p>
<pre><code>Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.
</code></pre>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<p><strong>Follow up:</strong></p>
<ul>
<li>Can you solve it using <em>O(1)</em> (i.e. constant) memory?</li>
</ul>
<hr>
<p>两个指针，慢指针一次走过一个节点，慢指针一次走过两个节点，有环则快慢指针必相遇。</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if (!head) return false;
        ListNode * slow = head, *fast = head;
        while (fast &amp;&amp; fast -&gt; next) {
            slow = slow -&gt; next;
            fast = fast -&gt; next -&gt; next;
            if (slow == fast) {
                return true；
            }
        }
        
        return false;
    }
};
</code></pre>
<h1 id="单链表有环如何找到环的入口节点">单链表有环，如何找到环的入口节点？</h1>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>
<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>
<p><strong>Note:</strong> Do not modify the linked list.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: head = [3,2,0,-4], pos = 1
Output: tail connects to node index 1
Explanation: There is a cycle in the linked list, where tail connects to the second node.
</code></pre>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<p><strong>Example 2:</strong></p>
<pre><code>Input: head = [1,2], pos = 0
Output: tail connects to node index 0
Explanation: There is a cycle in the linked list, where tail connects to the first node.
</code></pre>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<p><strong>Example 3:</strong></p>
<pre><code>Input: head = [1], pos = -1
Output: no cycle
Explanation: There is no cycle in the linked list.
</code></pre>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<p><strong>Follow-up</strong>:</p>
<ul>
<li>Can you solve it without using extra space?</li>
</ul>
<hr>
<p>设从头节点到环的起点距离为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>，环的起点到第一次相遇的节点之间的距离为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>，第一次相遇节点到尾端距离为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，显然<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">b+c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>为环一圈的周长。第一次相遇时，快指针走过的距离：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a+b+c+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>，慢指针走过的距离是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>，因为快指针速度是慢指针的两倍，所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo>+</mo><mi>b</mi><mo>=</mo><mn>2</mn><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">a+b+c+b = 2(a+b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>，则可知<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a=c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，</p>
<p>所以思路是如果存在环，那么第一次相遇后，其中一个指针回到起始节点，另一个指针继续走，两个指针每次移动的距离都是1，那么第二次相遇的时候走过的距离就都是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>了，所以返回这个节点即可。</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if (!head) return head;
        
        ListNode * slow = head, *fast = head;
        while (fast &amp;&amp; fast -&gt; next) {
            slow = slow -&gt; next;
            fast = fast -&gt; next -&gt; next;
            if (slow == fast) break;
        }
        if (!fast || !fast -&gt; next) return nullptr;
        
        slow = head;
        while (slow !=fast) {
            slow = slow -&gt; next;
            fast = fast -&gt; next;
        }
        
        return slow;
    }
};
</code></pre>
<h1 id="单链表有环如何破环">单链表有环，如何破环？</h1>
<p>对单链表中寻找环的入口点程序稍加改动即可。</p>
<pre><code class="language-c++">class Solution {
public:
    void breakCycle(ListNode *head) {
        ListNode * slow = head, *fast = head;
        while (slow != fast) {
            slow = slow -&gt; next;
            fast = fast -&gt; next -&gt; next;
        }
     
        slow = head;
        while (slow -&gt; next != fast -&gt; next) {
            slow = slow -&gt; next;
            fast = fast -&gt; next;
        }
        fast -&gt; next = nullptr;
    }
};
</code></pre>
<h1 id="单链表有环输出环的长度">单链表有环，输出环的长度</h1>
<p>思路和上面是一样的，只不过多了个计数器，计数器始终绑定在慢指针上，每走一步就+1，两个指针第一次相遇慢指针走过的步数就是环的长度。因为环的长度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">b+c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，慢指针走过的是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>，因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a=c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，所以可得。如果无环则返回-1.</p>
<pre><code class="language-c++">class Solution {
public:
    int cycleLength(ListNode *head){
        if (!head) return -1;
        int cnt = 0;
        ListNode * dummy = new ListNode(0);
        dummy -&gt; next = head;
        ListNode *slow = dummy, *fast = dummy;
        while (fast -&gt; next &amp;&amp; fast -&gt; next -&gt; next) {
            slow = slow -&gt; next;
            fast = fast -&gt; next -&gt; next;
            ++cnt;
            if (slow == fast) break;
        }
        if (!fast -&gt; next || !fast -&gt; next -&gt; next) return -1;
        
        return cnt;
    }
};
</code></pre>
<h1 id="无环单链表的中间节点">无环单链表的中间节点</h1>
<p>一个无环单链表，返回链表的中间节点，如果长度为偶数，返回两个节点的任意一个。</p>
<p>仍然是快慢指针思路，快指针走两步，慢指针走一步，那么快指针走到末尾，慢指针刚好走到一半。</p>
<pre><code class="language-c++">class Solution {
public:
    ListNode *middleNode(ListNode *head){
        if (!head) return nullptr;
        
        ListNode *slow = head, *fast = head;
        while (fast -&gt; next &amp;&amp; fast -&gt; next -&gt; next) {
            slow = slow -&gt; next;
            fast = fast -&gt; next -&gt; next;
        }
        
        return slow;
    }
};
</code></pre>
<p>这个方法的用处在<code>LeetCode 143.Reorder List</code>体现出来。</p>
<h1 id="如何判断两个单链表是否相交">如何判断两个单链表是否相交？</h1>
<p>首先假设两个单链表都无环，相交情况如下图：</p>
<p><img src="https://i.loli.net/2019/11/04/pW1INy5RGhoHcwM.png" alt=""></p>
<p>有两种思路：</p>
<p>一种是根据上面题目很自然想到的：先遍历第一个链表，由于无环，肯定可以访问到最后，然后把最后节点和自己的头节点连起来形成一个环，然后去访问第二个链表，如果两个链表相交，那么第二个链表就会形成环，否则不会，所以转化成了链表找环的问题，如果想输出交点思路同上。</p>
<p>第二种方法较第一种实施起来更为简单，因为第一种还需要去改动链表，最后记得恢复原状。不妨换一种思路，如果两个链表相交，那么一定有公共节点，在哪个位置不清楚，但是可以知道相交的链表最后一个节点一定是公共节点。所以访问第一个链表，记录最后一个节点，再访问第二个链表，如果第二个链表访问到最后也没有找到与记录节点相同的节点，那么没有相交，否则相交。</p>
<p>这里实现第二种方案：</p>
<pre><code class="language-c++">class Solution {
public:
    bool isIntersected(ListNode *head1, ListNode * head2){
        if (!head1 || !head2) return false;
        
        ListNode * prob1 = head1;
        while (prob1 -&gt; next)
            prob1 = prob1 -&gt; next;
        ListNode * prob2 = head2;
        while (prob2 -&gt; next)
            prob2 = prob2 -&gt; next;
        
        if (prob1 == prob2) return true;
        
        return false;
    }
};
</code></pre>
<h1 id="两个无环单链表相交如何找到交点">两个无环单链表相交，如何找到交点？</h1>
<p>一种思路是先遍历第一个链表，由于无环，肯定可以访问到最后，然后把最后节点和自己的头节点连起来形成一个环，然后去访问第二个链表，第二个链表就会形成环，问题转化成了一个单链表找环入口点问题，和<code>LeeCode 142</code>就是一个问题了。</p>
<p>第二种思路是由于无环，两个链表从头开始访问一定可以到尾端。首先判断是否相交，相交的情况我们采用一个计数器记录走过的长度，假设短链为链1，长链为链2，设公共长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>，则链1的长度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mn>1</mn><mo>=</mo><mi>l</mi><mn>1</mn><mo>+</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">s1=l1 + l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>，链2的长度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mn>2</mn><mo>=</mo><mi>l</mi><mn>2</mn><mo>+</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">s2 = l2+l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>，差值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mn>2</mn><mo>−</mo><mi>l</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">l2-l1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">1</span></span></span></span>，那么从头开始访问，让长链先走<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mn>2</mn><mo>−</mo><mi>l</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">l2-l1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">1</span></span></span></span>步，然后两个链的指针同时移动，那么第一次相交就是交点。</p>
<pre><code class="language-c++">class Solution {
public:
    bool isIntersected(ListNode *head1, ListNode * head2){
        if (!head1 || !head2) return false;
        
        ListNode * prob1 = head1;
        while (prob1 -&gt; next)
            prob1 = prob1 -&gt; next;
        ListNode * prob2 = head2;
        while (prob2 -&gt; next)
            prob2 = prob2 -&gt; next;
        
        if (prob1 == prob2) return true;
        
        return false;
    }
    
    ListNode * findIntersected(ListNode *head1, ListNode * head2){
        if (!isIntersected(head1, head2)) return nullptr;
        
        int s1 = 1, s2 = 1; //如果为0则比真实长度少1，也不影响差值计算结果
        ListNode * prob1 = head1; 
        while (prob1 -&gt; next){
            prob1 = prob1 -&gt; next;
            ++s1;
        }
        ListNode * prob2 = head2;
        while (prob2 -&gt; next){
            prob2 = prob2 -&gt; next;
            ++s2;
        }
        
        int delta = 0;
        bool flag = true; //记录哪个链是长链
        if (s1 &gt; s2){
            delta = s1 - s2;
        } 
        else{
            delta = s2 - s1;
            flag = false;
        } 
        
        prob1 = head1;
        prob2 = head2;
        if (flag){ //链1较长
            s1 = 0;
            while (s1 != delta){
                prob1 = prob1 -&gt; next;
                ++s1;
            }
            while (prob1 != prob2){
                prob1 = prob1 -&gt; next;
                prob2 = prob2 -&gt; next;
            }
            return prob1;
        }
        
        s2 = 0;
        while (s2 != delta){
            prob2 = prob2 -&gt; next;
            ++s2;
        } 
        while (prob1 != prob2){
            prob1 = prob1 -&gt; next;
            prob2 = prob2 -&gt; next;
        }
        return prob1;
    }
};
</code></pre>
<h1 id="两个单链表可能有环如何判断两个单链表是否相交">两个单链表可能有环，如何判断两个单链表是否相交？</h1>
<p>两个单链表可能有环，可分为4类（两个链表标记为链1和链2）：</p>
<ul>
<li>链1有环，链2有环</li>
<li>链1有环，链2无环</li>
<li>链1无环，链2有环</li>
<li>链1无环，链2无环</li>
</ul>
<p>最简单的情况是两个链中一个有环，一个无环，这种情况下必然无交点。</p>
<p>两个无环的链表思路和“判断无环链表是否相交一样了”，判断尾指针即可。</p>
<p>两个单链表有环不相交，显然环不会有重合的部分。<strong>两个链都有环且相交</strong>，分为两种情形如下图，但是一个共同点是，环是两个单链表的公共部分。</p>
<p><img src="https://i.loli.net/2019/11/04/EOATYwd2BqiKDcg.png" alt=""></p>
<p>很明显，区别在于环的入口不同。所以思路是：</p>
<ul>
<li>先写一个判断单链表是否有环的程序，分别判断两个单链表是否有环。</li>
<li>一个有环，一个无环，则不相交。</li>
<li>两个无环，那么应用判断尾节点的方法。</li>
<li>两个都有环，预先得到两个环的入口节点和环的长度（记为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>），如果环的长度不一致，则不相交。如果环的长度一致，考虑入口节点是否相同，如果相同，那么则相交。如果入口节点不同，设置一个慢指针在第一个入口，一个快指针（每次走两步）在第二个入口，两个指针如果在同一个环里面且入口点不同，相遇时慢指针最多走<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">s/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord">2</span></span></span></span>步。所以可以增加一个计数器，如果慢指针走了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">s/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord">2</span></span></span></span>步还是没有和快指针相遇，那么就是属于不同的环，否则就相交。</li>
</ul>
<pre><code class="language-c++">class Solution {
public:
    //计算单链表环的长度
    int cycleLength(ListNode *head){ 
        if (!head) return -1;
        int cnt = 0;
        ListNode * dummy = new ListNode(0);
        dummy -&gt; next = head;
        ListNode *slow = dummy, *fast = dummy;
        while (fast -&gt; next &amp;&amp; fast -&gt; next -&gt; next) {
            slow = slow -&gt; next;
            fast = fast -&gt; next -&gt; next;
            ++cnt;
            if (slow == fast) break;
        }
        if (!fast -&gt; next || !fast -&gt; next -&gt; next) return -1;
        
        return cnt;
    }
    
    //判断单链表是否有环，并返回环的入口节点
    ListNode *detectCycle(ListNode *head) {
        if (!head) return head;
        
        ListNode * slow = head, *fast = head;
        while (fast &amp;&amp; fast -&gt; next) {
            slow = slow -&gt; next;
            fast = fast -&gt; next -&gt; next;
            if (slow == fast) break;
        }
        if (!fast || !fast -&gt; next) return nullptr;
        
        slow = head;
        while (slow !=fast) {
            slow = slow -&gt; next;
            fast = fast -&gt; next;
        }
        
        return slow;
    }
    
    //判断两个无环单链表是否有交点
    bool isIntersected(ListNode *head1, ListNode * head2){
        if (!head1 || !head2) return false;
        
        ListNode * prob1 = head1;
        while (prob1 -&gt; next)
            prob1 = prob1 -&gt; next;
        ListNode * prob2 = head2;
        while (prob2 -&gt; next)
            prob2 = prob2 -&gt; next;
        
        if (prob1 == prob2) return true;
        
        return false;
    }
    
    //判断两个有环单链表是否有交点
    bool isCycleListIntersected(ListNode *head1, ListNode * head2){
        if (!head1 || !head2) return false;
        
        //得到两个单链表的环的长度和环入口节点
        ListNode * enterPoint1 = detectCycle(head1), * enterPoint2 = detectCycle(head2);
        int perimeter1 = cycleLength(head1), perimeter2 = cycleLength(head2);
        
        //一个有环，一个无环必不相交
        if ( (!enterPoint1 &amp;&amp; enterPoint2) || (enterPoint1 &amp;&amp; !enterPoint2) ) return false;
        
        //两个无环，尾节点判断法
        if (perimeter1 &lt; 0 &amp;&amp; perimeter2 &lt; 0) return isIntersected(head1, head2);
        
        //两个都有环，先判断环的长度是否一致
        if (perimeter1 != perimeter2) return false;
        
        //判断入口节点是否相同，相同则相交
        if (enterPoint1 == enterPoint2) return true;
        
        //环长度相同但是入口节点不同
        int cnt = 0; 
        ListNode * slow = enterPoint1, *fast = enterPoint2;
        while (cnt != perimeter1 / 2 + 1){
            slow = slow -&gt; next;
            fast = fast -&gt; next -&gt; next;
            if (slow == fast) return true;
        }
        
    	return false;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[矩阵旋转类问题的通用编程解法]]></title>
        <id>https://zyq2652192993zyq.github.io//post/ju-zhen-xuan-zhuan-lei-wen-ti-de-tong-yong-bian-cheng-jie-fa</id>
        <link href="https://zyq2652192993zyq.github.io//post/ju-zhen-xuan-zhuan-lei-wen-ti-de-tong-yong-bian-cheng-jie-fa">
        </link>
        <updated>2019-09-03T03:56:34.000Z</updated>
        <content type="html"><![CDATA[<p>对于这类问题的思考来源于做过的两道题目，一道是LeetCode 48.Rotate Image，另一道是SJTU OJ 4046. 矩阵旋转。先以LeetCode 48.Rotate Image为例，题目原型：</p>
<pre><code>You are given an n x n 2D matrix representing an image.
Rotate the image by 90 degrees (clockwise).

You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.

Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
</code></pre>
<p>对于这种旋转问题，直觉上第一反应是可以通过旋转矩阵求解，也就是得到一个通项公式。</p>
<p>首先建立一个映射，无论题目里给出的矩阵是多少维，描述其中每一个元素的维数总是二维的，即行号和列号，将其画在平面直角坐标系里，单位长度为1，则旋转相当于顺时针旋转90°或逆时针旋转270°。</p>
<p>其次我们需要找到旋转所围绕的中心点，但它是一直变化的且不在原点。更一般的，我们来研究下平面直角坐标系里的平移、旋转的新坐标和原坐标之间的关系。</p>
<p><strong>规定逆时针旋转角度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi><mi mathvariant="normal">​</mi></mrow><annotation encoding="application/x-tex">\theta​</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mord">​</span></span></span></span> 为正，向右上平移方向为正。</strong></p>
<ol>
<li>绕原点的旋转</li>
</ol>
<p>这种情形最简单，在矩阵论课程或者线性代数的课程里已经学过通过旋转矩阵来得到新坐标。
<img src="https://zyq2652192993zyq.github.io//post-images/1567483582390.png" alt=""></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>r</mi><mi>c</mi><mi>o</mi><mi>s</mi><mi>ϕ</mi><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">x=rcos\phi \\ 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">ϕ</span></span><span class="mspace newline"></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mi>r</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>ϕ</mi><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">y=rsin\phi \\ 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">ϕ</span></span><span class="mspace newline"></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>=</mo><mi>r</mi><mi>c</mi><mi>o</mi><mi>s</mi><mo>(</mo><mi>θ</mi><mo>+</mo><mi>ϕ</mi><mo>)</mo><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">x^{&#x27;}=rcos(\theta+\phi) \\
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.99248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.99248em;"><span style="top:-2.99248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ϕ</span><span class="mclose">)</span></span><span class="mspace newline"></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>y</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>=</mo><mi>r</mi><mi>s</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>θ</mi><mo>+</mo><mi>ϕ</mi><mo>)</mo><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">y^{&#x27;}=rsin(\theta+\phi) \\
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.18692em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.99248em;"><span style="top:-2.99248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ϕ</span><span class="mclose">)</span></span><span class="mspace newline"></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∴</mo><msup><mi>x</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>=</mo><mi>x</mi><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi><mo>−</mo><mi>y</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>θ</mi><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">\therefore  x^{&#x27;} = xcos\theta - y sin\theta \\
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∴</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.99248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.99248em;"><span style="top:-2.99248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span><span class="mspace newline"></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>y</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>=</mo><mi>x</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>θ</mi><mo>+</mo><mi>y</mi><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">y^{&#x27;} = xsin\theta+ycos\theta
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.18692em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.99248em;"><span style="top:-2.99248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></span></p>
<p>从而得到：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>∗</mo><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[\begin{array}{l}{x^{\prime}} \\ {y^{\prime}}\end{array}\right]=\left[\begin{array}{ll}{\cos \theta} &amp; {-\sin \theta} \\ {\sin \theta} &amp; {\cos \theta}\end{array}\right] *\left[\begin{array}{l}{x} \\ {y}\end{array}\right] 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span></span></p>
<ol start="2">
<li>平移变换
<img src="https://zyq2652192993zyq.github.io//post-images/1567483840941.png" alt=""></li>
</ol>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>=</mo><mi>x</mi><mo>+</mo><msub><mi>t</mi><mi>x</mi></msub><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">x^{&#x27;} = x + t_x \\ 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.99248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.99248em;"><span style="top:-2.99248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>y</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>=</mo><mi>y</mi><mo>+</mo><msub><mi>t</mi><mi>y</mi></msub><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">y^{&#x27;} = y + t_y \\
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.18692em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.99248em;"><span style="top:-2.99248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>t</mi><mi>x</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>t</mi><mi>y</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>∗</mo><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[\begin{array}{c}{x^{\prime}} \\ {y^{\prime}} \\ {1}\end{array}\right]=\left[\begin{array}{ccc}{1} &amp; {0} &amp; {t_x} \\ {0} &amp; {1} &amp; {t_y} \\ {0} &amp; {0} &amp; {1}\end{array}\right] *\left[\begin{array}{l}{x} \\ {y} \\ {1}\end{array}\right]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">0</span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">0</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<ol start="3">
<li>绕任意点的旋转
<img src="https://zyq2652192993zyq.github.io//post-images/1567483938949.png" alt=""></li>
</ol>
<ul>
<li>先平移到原点</li>
<li>绕原点旋转</li>
<li>在平移恢复到平移前的位置
上述过程发现，如果最初平移了<code>t</code>，最后一步就需要平移<code>-t</code>，所以上述过程描述成矩阵为：</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><msub><mi>t</mi><mi>x</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><msub><mi>t</mi><mi>y</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>∗</mo><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>∗</mo><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>t</mi><mi>x</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>t</mi><mi>y</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>∗</mo><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[\begin{array}{c}{x^{\prime}} \\ {y^{\prime}} \\ {1}\end{array}\right] = \left[\begin{array}{ccc}{1} &amp; {0} &amp; {-t_x} \\ {0} &amp; {1} &amp; {-t_y} \\ {0} &amp; {0} &amp; {1}\end{array}\right] *\left[\begin{array}{ccc}{\cos \theta} &amp; {-\sin \theta} &amp; {0} \\ {\sin \theta} &amp; {\cos \theta} &amp; {0} \\ {0} &amp; {0} &amp; {1}\end{array}\right] *\left[\begin{array}{ccc}{1} &amp; {0} &amp; {t_x} \\ {0} &amp; {1} &amp; {t_y} \\ {0} &amp; {0} &amp; {1}\end{array}\right] *\left[\begin{array}{l}{x} \\ {y} \\ {1}\end{array}\right]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">0</span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">0</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">−</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">−</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">0</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">0</span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">0</span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">0</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>所以得到新坐标只需要将上述计算出结果即可，对于本题，角度是固定的为-90°或270°，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>s</mi><mi>i</mi><mi>n</mi><mi>θ</mi><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">cos\theta=0, sin\theta = -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>y</mi><mo>+</mo><msub><mi>t</mi><mi>y</mi></msub><mo>−</mo><msub><mi>t</mi><mi>x</mi></msub><mspace linebreak="newline"></mspace><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mo>−</mo><mi>x</mi><mo>−</mo><msub><mi>t</mi><mi>x</mi></msub><mo>−</mo><msub><mi>t</mi><mi>y</mi></msub><mspace linebreak="newline"></mspace><mo>∵</mo><msub><mi>t</mi><mi>x</mi></msub><mo>=</mo><msub><mi>t</mi><mi>y</mi></msub><mo>=</mo><mi>t</mi><mspace linebreak="newline"></mspace><mo>∴</mo><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>y</mi><mspace linebreak="newline"></mspace><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mo>−</mo><mi>x</mi><mo>−</mo><mn>2</mn><mi>t</mi></mrow><annotation encoding="application/x-tex">x^{\prime} = y + t_y - t_x \\
y^{\prime} = -x - t_x - t_y \\
\because t_x = t_y = t\\
\therefore x^{\prime} = y \\
y^{\prime} = -x -2t
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.801892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.996332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∵</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∴</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.801892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.996332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">t</span></span></span></span></span></p>
<p>所以问题求解的关键在于求<code>t</code>的值。注意到题目里是个正方形矩阵，则如果真正求解<code>t</code>，则：</p>
<pre><code class="language-c++">double t = (-1.0) * (matrix.size()- 1)/ 2;
</code></pre>
<p>实际上只需要知道<code>2t</code>值即可，通过上述可知为<code>-(n-1)</code>。所以得到：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>y</mi><mspace linebreak="newline"></mspace><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x^{\prime} = y \\
y^{\prime} = n - 1 - x
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.801892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.996332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span></span></p>
<p>接下来的问题就是考虑遍历矩阵元素来执行变换，不妨对于坐标为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>的元素进行变换：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>→</mo><mo>(</mo><mi>j</mi><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>i</mi><mo>)</mo><mo>→</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>j</mi><mo>)</mo><mo>→</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>j</mi><mo separator="true">,</mo><mi>i</mi><mo>)</mo><mo>→</mo><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,j) \rightarrow (j,n-1-i)  \rightarrow (n-1-i,n-1-j)  \rightarrow (n-1-j,i)  \rightarrow (i,j)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></span></p>
<p>通过上述推导可以发现，四次变换后回到起始点，图形示意如下。</p>
<p><img src="https://zyq2652192993zyq.github.io//post-images/1567484232434.png" alt=""></p>
<p>观察发现，对于每一行的元素，并不是所有元素都需要被遍历，只需要遍历从起始点到倒数第二个点，如果把矩阵按奇数阶和偶数阶来划分，则遍历的过程如下：</p>
<p><img src="https://zyq2652192993zyq.github.io//post-images/1567484242908.png" alt=""></p>
<p>其中只有红色标记的点需要遍历，其他的点都可以通过红色点来求出相应的坐标。对于究竟有多少个点需要遍历，我们需要考虑一下矩阵的阶数：奇数阶矩阵和偶数阶矩阵，偶数阶矩阵又要考虑<code>4k+2</code>阶和<code>4k</code>阶的区别。</p>
<p>奇数阶矩阵的特点是总有一个点不需要变换，偶数阶矩阵里无论是<code>4k</code>还是<code>4k+2</code>阶，都能像右边的图一样，所有点都需要变动。</p>
<p>设最外层为第0层，矩阵边长为n。可以发现，无论是奇数阶还是偶数阶矩阵，需要遍历的层数都是从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">[0, n/2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>。对于每一层里需要遍历的元素，无论是奇数阶还是偶数阶矩阵，都是从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">[i, n - 1 - i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>。变成工作只需要把上述过程翻译成代码即可。</p>
<pre><code class="language-c++">class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int n = matrix.size();
        if (n == 0) return;
        int boundary = n / 2;
        
        for (int i = 0; i &lt; boundary; ++i){
            for (int j = i; j &lt; n - i - 1; ++j){
                int tmp = std::move(matrix[i][j]);
                matrix[i][j] = std::move(matrix[n-1-j][i]);
                matrix[n-1-j][i] = std::move(matrix[n-1-i][n-1-j]);
                matrix[n-1-i][n-1-j] = std::move(matrix[j][n-1-i]);
                matrix[j][n-1-i] = std::move(tmp);
            }
        }
    }
};
</code></pre>
<pre><code class="language-shell"># test result
Runtime: 0 ms, faster than 100.00% of C++ online submissions for Rotate Image.
Memory Usage: 9 MB, less than 97.56% of C++ online submissions for Rotate Image.
</code></pre>
<p>值得一提的是，本题如果矩阵包含的元素很多，通过交换数据代价很大，实际在整个过程中并没有额外分配一个矩阵，交换的只是对于存储数据的内存的所有权。所以很容易想到用<code>C++11</code>里的<code>move</code>来实现。</p>
]]></content>
    </entry>
</feed>