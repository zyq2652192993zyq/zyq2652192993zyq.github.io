<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>动态规划——最长上升子序列（LIS） | Kylin</title>
<meta name="description" content="Talk is cheap, show me the code.">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://zyq2652192993zyq.github.io//favicon.ico?v=1588491133496">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://zyq2652192993zyq.github.io//styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://zyq2652192993zyq.github.io/">
        <img src="https://zyq2652192993zyq.github.io//images/avatar.png?v=1588491133496" class="site-logo">
        <h1 class="site-title">Kylin</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="https://github.com/zyq2652192993zyq" class="site-nav" target="_blank">
            GitHub
          </a>
        
      
        
          <a href="https://zyq2652192993zyq.github.io/" class="site-nav">
            首页
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      Talk is cheap, show me the code.
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://zyq2652192993zyq.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">动态规划——最长上升子序列（LIS）</h2>
            <div class="post-date">2020-03-30</div>
            
              <div class="feature-container" style="background-image: url('https://zyq2652192993zyq.github.io//post-images/dong-tai-gui-hua-zui-chang-shang-sheng-zi-xu-lie-lis.png')">
              </div>
            
            <div class="post-content">
              <p><strong>文中提到的题目可在我GitHub的<a href="https://github.com/zyq2652192993zyq/LeetCode">LeetCode</a>, <a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge">SJTU OJ</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Algorithm%20Analysis">Algorithm Analysis</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Problem%20Solution">Problem Solution</a>找到解答。</strong></p>
<h1 id="基本模型">基本模型</h1>
<p>如果在判断条件上存在犹豫，只需要在纸上举几个数字自然就知道属于二分的哪种情况了。</p>
<h2 id="最长上升子序列">最长上升子序列</h2>
<p>相当于每次去找第一个不小于目标值的数。</p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-9178157"><label class="task-list-item-label" for="task-item-9178157"> 一本通-1281：最长上升子序列</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2761293"><label class="task-list-item-label" for="task-item-2761293"> LeetCode 300.Longest Increasing Subsequence</label></li>
</ul>
<pre><code class="language-c++">int n;
vector&lt;int&gt; seq(1005), d(1005);

int LIS()
{
	d[1] = seq[0];
	int len = 1;
	for (int i = 1; i &lt; n; ++i) {
		int target = seq[i];

		int left = 1, right = len + 1;
		while (left &lt; right) {
			int mid = left + ((right - left) &gt;&gt; 1);
			if (d[mid] &lt; target) left = mid + 1;
			else right = mid;
		}
		if (left == len + 1) d[++len] = target;
		else d[left] = target;
	}

	return len;
}
</code></pre>
<h2 id="最长不降子序列">最长不降子序列</h2>
<p>相当于查找第一个大于目标值的数。</p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3012397"><label class="task-list-item-label" for="task-item-3012397">  一本通-1259：【例9.3】求最长不下降序列（附加路径输出）</label></li>
</ul>
<pre><code class="language-c++">int n;
vector&lt;int&gt; seq(205), d(205), pre(205, INT_MIN);

void print(int pos)
{
	if (pos == INT_MIN) return;

	print(pre[pos]);
	cout &lt;&lt; seq[pos] &lt;&lt; ' ';
}

void solve()
{
	d[1] = 0;
	d[0] = INT_MIN;
	int len = 1;
	for (int i = 1; i &lt; n; ++i) {
		int target = seq[i];

		int left = 1, right = len + 1;
		while (left &lt; right) {
			int mid = left + ((right - left) &gt;&gt; 1);
			if (seq[d[mid]] &lt;= target) left = mid + 1;
			else right = mid;
		}
		if (left == len	+ 1) {
			d[++len] = i;
			pre[i] = d[len - 1];
		}
		else {
			d[left] = i;
			pre[i] = d[left - 1];
		}
	}

	cout &lt;&lt; &quot;max=&quot; &lt;&lt; len &lt;&lt; endl;
	print(d[len]);
	cout &lt;&lt; endl;
}

</code></pre>
<p>这里数组<code>d[i] = pos</code>表示最长不降子序列长度为<code>i</code>的时候，以原数组下标<code>pos</code>作为结尾，用<code>pre[i]</code>记录构成最长不降子序列的前一个元素的下标。最后递归输出路径即可。</p>
<h2 id="最长下降子序列">最长下降子序列</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8910167"><label class="task-list-item-label" for="task-item-8910167"> 一本通-1286：怪盗基德的滑翔翼（前向和后向两次计算LIS）</label></li>
</ul>
<p>这时候数组<code>d</code>降序排列，相当于查找第一个小于等于目标值的数。</p>
<pre><code class="language-c++">int n;
vector&lt;int&gt; seq(1005), d(1005);

int LIS()
{
	d[1] = seq[0];
	int len = 1;
	for (int i = 1; i &lt; n; ++i) {
		int target = seq[i];

		int left = 1, right = len + 1;
		while (left &lt; right) {
			int mid = left + ((right - left) &gt;&gt; 1);
			if (d[mid] &gt; target) left = mid + 1;
			else right = mid;
		}
		if (left == len + 1) d[++len] = target;
		else d[left] = target;
	}

	return len;
}
</code></pre>
<h2 id="最长不升子序列">最长不升子序列</h2>
<p>相当于查找第一个小于目标值的数。</p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2341298"><label class="task-list-item-label" for="task-item-2341298"> 一本通-1289：拦截导弹</label></li>
</ul>
<pre><code class="language-c++">int n;
vector&lt;int&gt; seq(205), d(205);

int solve()
{
	d[1] = seq[0];
	int len = 1;
	for (int i = 1; i &lt; n; ++i) {
		int target = seq[i];

		int left = 1, right = len + 1;
		while (left &lt; right) {
			int mid = left + ((right - left) &gt;&gt; 1);
			if (d[mid] &gt;= target) left = mid + 1;
			else right = mid;
		}
		if (left == len + 1) d[++len] = target;
		else d[left] = target;
	}

	return len;
}
</code></pre>
<h2 id="动态规划的方法">动态规划的方法</h2>
<p>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">d[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>表示以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为终点的最长上升子序列的长度，状态转移方程：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>max</mi><mo>⁡</mo><mo>{</mo><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>}</mo><mo>+</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo>&lt;</mo><mi>i</mi><mo>&lt;</mo><mi>j</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>i</mi></msub><mo>&lt;</mo><msub><mi>a</mi><mi>j</mi></msub></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">d[j]=\left\{\begin{array}{ll}
{1} &amp; {j=1} \\
{\max \{d[i]\}+1} &amp; {1&lt;i&lt;j, a_{i}&lt;a_{j}}
\end{array}\right.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mop">max</span><span class="mopen">{</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>核心代码</p>
<pre><code class="language-c++">int lengthOfLIS(vector&lt;int&gt;&amp; nums) {
    if (nums.size() == 0) return 0;

    int n = nums.size();
    vector&lt;int&gt; d(n, 0);
    d[0] = 1;

    for (int j = 1; j &lt; n; ++j){
        int maxLength = 0;
        for (int i = 0; i &lt; j; ++i){
            if (nums[i] &lt; nums[j] &amp;&amp; maxLength &lt; d[i])
                maxLength = d[i];
        }
        d[j] = maxLength + 1;
    }

    return *max_element(d.begin(), d.end());
}
</code></pre>
<p>上面是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的解法，但是在某些时间限制比较严的情况下是无法通过的，比如POJ 1631。所以需要采用二分优化将时间复杂度降到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<h2 id="最大上升子序列和">最大上升子序列和</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-1381480"><label class="task-list-item-label" for="task-item-1381480"> 一本通-1285：最大上升子序列和</label></li>
</ul>
<p>一个数的序列bi，当b1&lt;b2&lt;...&lt;bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1,a2,...,aN)，我们可以得到一些上升的子序列(ai1,ai2,...,aiK)，这里1≤i1&lt;i2&lt;...&lt;iK≤N。比如，对于序列(1,7,3,5,9,4,8)，有它的一些上升子序列，如(1,7),(3,4,8)等等。这些子序列中和最大为18，为子序列(1,3,5,9)的和。</p>
<p>你的任务，就是对于给定的序列，求出最大上升子序列和。注意，最长的上升子序列的和不一定是最大的，比如序列(100,1,2,3)的最大上升子序列和为100，而最长上升子序列为(1,2,3)。</p>
<p>其实就是LIS动态规划方法的稍微变动，用<code>d[i]</code>表示以<code>seq[i]</code>结尾的最大上升子序列和，状态转移方程是：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo>(</mo><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>+</mo><mi>s</mi><mi>e</mi><mi>q</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>)</mo><mo separator="true">,</mo><mn>0</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">d[i] = \max(d[i], d[j] + seq[i]), 0 \leq j &lt; i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></span></p>
<p>但是需要注意一点是，数组<code>d[i]</code>的元素应该初始化为<code>seq[i]</code>。假如还是初始化为0，考虑特殊情况：</p>
<pre><code>4
-1 -2 -100 -3
</code></pre>
<p>不初始化输出结果会为0。</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

int n;
vector&lt;int&gt; seq(1005);
vector&lt;int&gt; d(1005);

int LISsum()
{
	d[0] = seq[0];
	for (int i = 1; i &lt; n; ++i) {
		d[i] = seq[i];
		for (int j = 0; j &lt; i; ++j) {
			if (seq[j] &lt; seq[i]) {
				d[i] = max(d[i], d[j] + seq[i]);
			}
		}
	}

	return *max_element(d.begin(), d.begin() + n);
}

int main()
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) cin &gt;&gt; seq[i];
	cout &lt;&lt; LISsum() &lt;&lt; endl;

	return 0;
}
</code></pre>
<h2 id="合并lisjlis">合并LIS（JLIS）</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2035931"><label class="task-list-item-label" for="task-item-2035931"> ALGOSPOT JLIS（《算法问题实战策略》8.5）</label></li>
</ul>
<h2 id="第k个最大自增子序列klis">第K个最大自增子序列（KLIS）</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-820922"><label class="task-list-item-label" for="task-item-820922"> ALGOSPOT KLIS（《算法竞赛实战策略》9.7）</label></li>
</ul>
<h2 id="最长公共上升子序列">最长公共上升子序列</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-520081"><label class="task-list-item-label" for="task-item-520081"> 一本通-1306：最长公共子上升序列</label></li>
</ul>
<p>将LIS和LCS进行结合</p>
<h2 id="统计区间长度为k的lis个数">统计区间长度为k的LIS个数</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-441876"><label class="task-list-item-label" for="task-item-441876"> HDU 4352 XHXJ's LIS</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-7105135"><label class="task-list-item-label" for="task-item-7105135"> LeetCode 115.不同的子序列（可以转化成LIS模型，也可以用普通动态规划做，注意数据溢出问题）</label></li>
</ul>
<h2 id="生成lis序列">生成LIS序列</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9359299"><label class="task-list-item-label" for="task-item-9359299"> CodeForces 1304D Shortest and Longest LIS</label></li>
</ul>
<p>这种题目属于逆向思维题，以往的都是给定序列求LIS长度，现在是给定比较关系来生成序列。</p>
<h2 id="lis路径输出">LIS路径输出</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-5530657"><label class="task-list-item-label" for="task-item-5530657"> 一本通-1259：【例9.3】求最长不下降序列</label></li>
</ul>
<p><strong>LIS路径输出用动态规划应该是最好理解的，但是也可以用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span>的方法</strong></p>
<p>设有由n(1≤n≤200)个不相同的整数组成的数列，记为:b(1)、b(2)、……、b(n)且b(i)≠b(j)(i≠j)，若存在i1&lt;i2&lt;i3&lt;…&lt;ie 且有b(i1)&lt;b(i2)&lt;…&lt;b(ie)则称为长度为e的不下降序列。程序要求，当原数列出之后，求出最长的不下降序列。</p>
<p>例如13，7，9，16，38，24，37，18，44，19，21，22，63，15。</p>
<p>例中13，16，18，19，21，22，63就是一个长度为7的不下降序列，同时也有7 ，9，16，18，19，21，22，63组成的长度为8的不下降序列。</p>
<p>【输入】<br>
第一行为n,第二行为用空格隔开的n个整数。</p>
<p>【输出】<br>
第一行为输出最大个数max(形式见样例)；</p>
<p>第二行为max个整数形成的不下降序列,答案可能不唯一，输出一种就可以了，本题进行特殊评测。</p>
<p>【输入样例】</p>
<pre><code>14
13 7 9 16 38 24 37 18 44 19 21 22 63 15
</code></pre>
<p>【输出样例】</p>
<pre><code>max=8
7 9 16 18 19 21 22 63
</code></pre>
<pre><code class="language-c++">//动态规划方法输出路径
#include &lt;bits/stdc++.h&gt;

using namespace std;

vector&lt;int&gt; num(205);
int n;
vector&lt;int&gt; d(205);
vector&lt;int&gt; pre(205, -1);


void print(int pos)
{
	if (pos == -1) return;
	else {
		print(pre[pos]);
		cout &lt;&lt; num[pos] &lt;&lt; ' ';
	}
}


void LIS()
{
	if (n == 1) {
		cout &lt;&lt; &quot;max=&quot; &lt;&lt; 1 &lt;&lt; endl;
		cout &lt;&lt; num[0] &lt;&lt; endl;
		return;
	}

	d[0] = 1;
	for (int j = 1; j &lt; n; ++j) {
		int maxLen = 0;
		int pos = -1;
		for (int i = 0; i &lt; j; ++i) {
			if (num[i] &lt;= num[j] &amp;&amp; maxLen &lt; d[i]) {
				maxLen = d[i];
				pos = i;
			}
		}
		d[j] = maxLen + 1;
		pre[j] = pos;
	}

	int position = -1;
	int res = INT_MIN;
	for (int i = 0; i &lt; n; ++i) {
		if (d[i] &gt; res) {
			res = d[i];
			position = i;
		}
	}

	cout &lt;&lt; &quot;max=&quot; &lt;&lt; res &lt;&lt; endl;
	print(position);
	cout &lt;&lt; endl;
}

int main()
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) cin &gt;&gt; num[i];
	LIS();

	return 0;
}
</code></pre>
<h1 id="拦截导弹二分优化">拦截导弹（二分优化）</h1>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3183515"><label class="task-list-item-label" for="task-item-3183515"> 洛谷-P1020 导弹拦截（最典型的LIS练习，两种形式）</label></li>
</ul>
<p>【题目描述】<br>
某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。</p>
<p>输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数，导弹数不超过1000），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。</p>
<p>【输入】<br>
输入导弹依次飞来的高度。</p>
<p>【输出】<br>
第一行：最多能拦截的导弹数；</p>
<p>第二行：要拦截所有导弹最少要配备的系统数。</p>
<p>【输入样例】</p>
<pre><code>389 207 155 300 299 170 158 65
</code></pre>
<p>【输出样例】</p>
<pre><code>6
2
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

int n = 0;
vector&lt;int&gt; seq(1005);
vector&lt;int&gt; num(1005); //计算最长不升子序列
vector&lt;int&gt; cnt(1005); //计算所需的导弹数

int main()
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int height;
	while (cin &gt;&gt; height) {
		seq[n++] = height;
	}

	num[1] = seq[0];
	cnt[1] = seq[0];
	int len1 = 1, len2 = 1;
	for (int i = 1; i &lt; n; ++i) {
		int target = seq[i];
		//caculate LIS
		int left = 1, right = len1 + 1;
		while (left &lt; right) {
			int mid = left + ((right - left) &gt;&gt; 1);
			if (num[mid] &gt;= target) left = mid + 1;
			else right = mid;
		}
		if (left == len1 + 1) num[++len1] = target;
		else num[left] = target;

		//calculate the number of the system
		left = 1, right = len2 + 1;
		while (left &lt; right) {
			int mid = left + ((right - left) &gt;&gt; 1);
			if (cnt[mid] &lt; target) left = mid + 1;
			else right = mid;
		}
		if (left == len2 + 1) cnt[++len2] = target;
		else cnt[left] = target;
	}
	cout &lt;&lt; len1 &lt;&lt; endl;
	cout &lt;&lt; len2 &lt;&lt; endl;

	return 0;
}
</code></pre>
<h1 id="城市架桥">城市架桥</h1>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-875394"><label class="task-list-item-label" for="task-item-875394"> POJ 1631 Bridging signals（二进制优化后的LIS）或 HDU 1950 Bridging signals</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-4256185"><label class="task-list-item-label" for="task-item-4256185"> 一本通-1263：【例9.7】友好城市(和POJ 1631一样的方法)</label></li>
</ul>
<p>【题目描述】<br>
Palmia国有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的N个城市。北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。</p>
<p>每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航线不相交的情况下，被批准的申请尽量多。</p>
<p>【输入】<br>
第1行，一个整数N(1≤N≤5000)，表示城市数。</p>
<p>第2行到第n+1行，每行两个整数，中间用1个空格隔开，分别表示南岸和北岸的一对友好城市的坐标。(0≤xi≤10000)</p>
<p>【输出】<br>
仅一行，输出一个整数，表示政府所能批准的最多申请数。</p>
<p>【输入样例】</p>
<pre><code>7
22 4
2 6
10 3
15 12
9 8
17 17
4 2
</code></pre>
<p>【输出样例】</p>
<pre><code>4
</code></pre>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

struct Node
{
	int start, end;
	bool operator&lt;(const Node &amp; obj) const
	{
		return start &lt; obj.start;
	}
};

int n;
vector&lt;Node&gt; seq(5005);
vector&lt;int&gt; d(5005);

int solve()
{
	sort(seq.begin(), seq.begin() + n);

	d[1] = seq[0].end;
	int len = 1;
	for (int i = 1; i &lt; n; ++i) {
		int target = seq[i].end;

		int left = 1, right = len + 1;
		while (left &lt; right) {
			int mid = left + ((right - left) &gt;&gt; 1);
			if (d[mid] &lt; target) left = mid + 1;
			else right = mid;
		}
		if (left == len + 1) d[++len] = target;
		else d[left] = target;
	}

	return len;
}


int main()
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; seq[i].start &gt;&gt; seq[i].end;
	}

	cout &lt;&lt; solve() &lt;&lt; endl;

	return 0;
}
</code></pre>
<h1 id="合唱队形">合唱队形</h1>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3956775"><label class="task-list-item-label" for="task-item-3956775"> 一本通-1264：【例9.8】合唱队形</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3714199"><label class="task-list-item-label" for="task-item-3714199"> 一本通-1283：登山（背景不同，模型相同）</label></li>
</ul>
<p>【题目描述】<br>
N位同学站成一排，音乐老师要请其中的(N−K)位同学出列，使得剩下的KK位同学排成合唱队形。</p>
<p>合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1,2,…,K，他们的身高分别为T1,T2,…,TK，则他们的身高满足T1&lt;T2&lt;…&lt;Ti,Ti&gt;Ti+1&gt;…&gt;TK(1≤i≤K)。</p>
<p>你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。</p>
<p>【输入】<br>
输入的第一行是一个整数N（2≤N≤100），表示同学的总数。第二行有n个整数，用空格分隔，第i个整数Ti（130≤Ti≤230）是第i位同学的身高（厘米）。</p>
<p>【输出】<br>
输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。</p>
<p>【输入样例】<br>
8<br>
186 186 150 200 160 130 197 220</p>
<p>【输出样例】<br>
4</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

int n;
vector&lt;int&gt; seq(105), forwardSeq(105), backwardSeq(105);
vector&lt;int&gt; d(105), c(105);

int solve()
{
	forwardSeq[1] = seq[0];
	int len1 = 1;
	d[1] = 1;
	for (int i = 1; i &lt; n; ++i) {
		int target = seq[i];

		int left = 1, right = len1 + 1;
		while (left &lt; right) {
			int mid = left + ((right - left) &gt;&gt; 1);
			if (forwardSeq[mid] &lt; target) left = mid + 1;
			else right = mid;
		}
		if (left == len1 + 1) {
			forwardSeq[++len1] = target;
			d[i + 1] = len1;
		}
		else {
			forwardSeq[left] = target;
			d[i + 1] = left;
		}
	}

	backwardSeq[1] = seq[n - 1];
	int len2 = 1;
	c[n] = 1;
	for (int i = n - 2; i &gt;= 0; --i) {
		int target = seq[i];

		int left = 1, right = len2 + 1;
		while (left &lt; right) {
			int mid = left + ((right - left) &gt;&gt; 1);
			if (backwardSeq[mid] &lt; target) left = mid + 1;
			else right = mid;
		}
		if (left == len2 + 1) {
			backwardSeq[++len2] = target;
			c[i + 1] = len2;
		}
		else {
			backwardSeq[left] = target;
			c[i + 1] = left;
		}
	}

	int maxVal = -1;
	for (int i = 1; i &lt;= n; ++i) {
		maxVal = max(maxVal, c[i] + d[i] - 1);
	}

	return n - maxVal;
}

int main()
{
	std::ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) cin &gt;&gt; seq[i];
	cout &lt;&lt; solve() &lt;&lt; endl;

	return 0;
}
</code></pre>
<p>第一遍正向遍历，寻找最长上升子序列，用<code>d[i]</code>表示以<code>seq[i - 1]</code>结尾的最长上升子序列长度，第二遍逆序遍历，用<code>c[i]</code>记录以<code>seq[i - 1]</code>结尾的最长上升子序列长度（从后往前看），那么最终形成的先上升后下降的最大长度是<code>d[i] + c[i] + 1</code>，因为第<code>i</code>个人被重复计算了一次。那么最后只需要删掉<code>n - max(d[i] + c[i] - 1)</code>个人即可。</p>
<p>典型题目：</p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-4489983"><label class="task-list-item-label" for="task-item-4489983"> 洛谷-P1020 导弹拦截（最典型的LIS练习，两种形式）</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3496386"><label class="task-list-item-label" for="task-item-3496386"> LeetCode 300.Longest Increasing Subsequence</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8437508"><label class="task-list-item-label" for="task-item-8437508"> POJ 2533 Longest Ordered Subsequence</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8035084"><label class="task-list-item-label" for="task-item-8035084"> POJ 1631 Bridging signals（二进制优化后的LIS）</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3348038"><label class="task-list-item-label" for="task-item-3348038"> 一本通-1263：【例9.7】友好城市(和POJ 1631一样的方法)</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8649819"><label class="task-list-item-label" for="task-item-8649819"> HDU 1257 最少拦截系统</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3211747"><label class="task-list-item-label" for="task-item-3211747"> 一本通-1259：【例9.3】求最长不下降序列</label></li>
</ul>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://zyq2652192993zyq.github.io/tag/WVkGCnvmy/" class="tag">
                    动态规划——最长上升子序列（LIS）
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://zyq2652192993zyq.github.io/post/dong-tai-gui-hua-shu-zi-san-jiao-xing/">
                  <h3 class="post-title">
                    动态规划——数字三角形
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
