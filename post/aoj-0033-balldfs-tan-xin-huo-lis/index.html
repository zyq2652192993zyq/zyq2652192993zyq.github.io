<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>AOJ-0033 Ball(DFS + 贪心或LIS) | Kylin</title>
<meta name="description" content="Talk is cheap, show me the code.">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://zyq2652192993zyq.github.io//favicon.ico?v=1585573207763">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://zyq2652192993zyq.github.io//styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://zyq2652192993zyq.github.io/">
        <img src="https://zyq2652192993zyq.github.io//images/avatar.png?v=1585573207763" class="site-logo">
        <h1 class="site-title">Kylin</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="https://github.com/zyq2652192993zyq" class="site-nav" target="_blank">
            GitHub
          </a>
        
      
        
          <a href="https://zyq2652192993zyq.github.io/" class="site-nav">
            首页
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      Talk is cheap, show me the code.
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://zyq2652192993zyq.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">AOJ-0033 Ball(DFS + 贪心或LIS)</h2>
            <div class="post-date">2020-01-05</div>
            
            <div class="post-content">
              <blockquote>
<p>原题是日文，由于我看不懂日文，所以就直接翻译成中文了，评测是在virtual judge上。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="http://judge.u-aizu.ac.jp/onlinejudge/IMAGE1/ball.gif" alt="img" loading="lazy"></figure>
<p>如图所示，有些容器是分叉的。从容器的开口A放下10个编号为1到10的球，并将其放在左管B或右管C中。板D可以绕支点E左右旋转，因此您可以通过移动板D来确定要插入哪个管B或C。</p>
<p>给一排球使其从开口A掉落。按顺序将它们放在气缸B或C中。此时，创建一个程序，如果气缸B和C都可以将大球排列在数量较小的球上，则输出YES，否则，则输出NO。但是，不能改变容器中球的顺序。另外，圆柱体可以相继放置在同一圆柱体中，并且圆柱体B和C具有足够的空间容纳所有十个球。</p>
<h2 id="输入项">输入项</h2>
<p>给出了多个数据集。第一行给出数据集的数量<em>N。<em>然后，给出具有</em>N</em>行的数据集。每个数据集都有10个数字，左右之间用空格隔开。</p>
<h2 id="输出量">输出量</h2>
<p>每个数据集在一行上输出YES或NO。</p>
<h2 id="样本输入">样本输入</h2>
<pre><code>2 
3 1 4 2 5 6 7 8 9 10 
10 9 8 7 6 5 4 3 2 1
</code></pre>
<h2 id="样本输入的输出">样本输入的输出</h2>
<pre><code>YES 
NO
</code></pre>
<hr>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

vector&lt;int&gt; sequence(10);
int leftTop = -1, rightTop = -1;

bool DFS(int num)
{
    if (num == 10) return true;
    //两边同时可以放置则采取贪心策略，找与顶部数字差距最小的放
    if (sequence[num] &gt; leftTop &amp;&amp; sequence[num] &gt; rightTop) {
        if (sequence[num] - leftTop &lt; sequence[num] - rightTop) {
            leftTop = sequence[num];
            return DFS(num + 1);
        }
        else {
            rightTop = sequence[num];
            return DFS(num + 1);
        }
    }
    else if (sequence[num] &gt; leftTop) {
        leftTop = sequence[num];
        return DFS(num + 1);
    }
    else if (sequence[num] &gt; rightTop) {
        rightTop = sequence[num];
        return DFS(num + 1);
    }

    return false;
}

int main()
{
    std::ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int caseNum;
    cin &gt;&gt; caseNum;
    while (caseNum--) {
        for (int i = 0; i &lt; 10; ++i) cin &gt;&gt; sequence[i];
        if (DFS(0)) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
        else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
        leftTop = rightTop = -1;
    }

    return 0;
}
</code></pre>
<p>每一个球的放置策略只有两种选择：左边和右边，但是能否放置有多种情况：</p>
<ul>
<li>左右都能放置</li>
<li>只能放在左边</li>
<li>只能放在右边</li>
<li>两边都不能放置</li>
</ul>
<p>都不能放置的情况最好处理，直接返回即可。比较难处理的是两边都能放置的情况，可以参考的一种思路是《挑战程序设计竞赛》在2.1.4的部分和例子，考虑每个数加上和不加上能否成功。这里就是先试试放在左边，然后试试放在右边。但是发现这个题目有个特殊的地方，考虑第一个样例，如果最开始1放在左边，3放在右边，然后4两边都可以放，如果选择4放在1的上面，到了2就没法放置了。</p>
<p>根据上面的分析可以直到，如果两边都可以放，那么选择与顶部数字差距最小的一边放置是最优选择，因为这样为后面的数字留出了最大的空间（很类似《算法导论》里的任务安排用的贪心的策略），这样就避免了很多无意义的搜索。</p>
<p>本题的数据是10， 考虑如果从1到100个数或者更大的数据，如果按照没有采取贪心的方法去搜索，显然分支情况就会过多，所以使用贪心其实也算是起到了剪枝的作用。</p>
<hr>
<p>这道题目还可以换一种等价问法：一个序列能否被划分(按顺序的从序列中选取数字)成两个单增序列，两个序列中的一个可以为空。</p>
<p>所以题目还可以从<strong>最长上升子序列</strong>的角度来考虑。先用一个数组<code>sequence</code>来存储所有的数字，然后用一个等长的数组<code>visit</code>，存储的内容是<code>bool</code>类型，初始化为<code>false</code>，然后在寻找最长上升子序列时，把在最长上升序列的数字对应的<code>visit</code>设为<code>true</code>。最后去检查<code>visit</code>数组里标记为<code>false</code>的部分是否满足单调上升。</p>
<p>但是这种方法的时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>空间复杂度显然不如上面的DFS+贪心的方法好。</p>
<pre><code class="language-c++">//也可以AC的O(n^2)的方法
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

vector&lt;int&gt; sequence(10);
vector&lt;bool&gt; visit(10, false);
vector&lt;int&gt; path(10, -1);

void mark(int num)
{
    if (num == -1) return;
    else {
        visit[num] = true;
        mark(path[num]);
    } 
}

void LIS()
{
    vector&lt;int&gt; d(10, 0);
    d[0] = 1;

    for (int j = 1; j &lt; 10; ++j) {
        int maxLength = 0;
        int pos = 0;
        for (int i = 0; i &lt; j; ++i) {
            if (sequence[j] &gt; sequence[i] &amp;&amp; maxLength &lt; d[i]) {
                maxLength = d[i];
                pos = i;
            }
        }
        path[j] = pos;
        d[j] = maxLength + 1;
    }
    int endPos = max_element(d.begin(), d.end()) - d.begin();
    mark(endPos);
}

bool split()
{
    LIS();
    int pre = -1;
    for (int i = 0; i &lt; 10; ++i) {
        if (!visit[i]) {
            if (sequence[i] &gt; pre) pre = sequence[i];
            else return false;
        }
    }
    return true;
}

int main()
{
    std::ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int caseNum;
    cin &gt;&gt; caseNum;
    while (caseNum--) {
        for (int i = 0; i &lt; 10; ++i) cin &gt;&gt; sequence[i];
        if (split()) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
        else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
        fill(visit.begin(), visit.end(), false);
        fill(path.begin(), path.end(), -1);
    }

    return 0;
}
</code></pre>
<p>用数组<code>sequence</code>来记录输入的数字，用函数<code>split()</code>来判断序列是否可以分成单增的两部分，函数<code>split()</code>先通过函数<code>LIS()</code>来寻找最长上升子序列，这里有一个技巧，就是增加一个<code>path()</code>数组，用来记录当前最大长度是将数字加入到哪一个序列得到的，<code>path()</code>数组初始化为-1，最后可以通过递归的方式得到最长上升子序列，-1就标记着当前位置就是子序列的起始位置。这里需要注意的就是因为<code>sequence</code>数组下一次输入的时候会覆盖原来的数字，所以并不需要去处理，但是<code>path, visit</code>需要在下一个算例开始前进行初始化。</p>
<p>（如果想进一步优化）其实最后一个算例的时候是没有必要对<code>path,visit</code>进行初始化的，只需要增加一句：</p>
<pre><code class="language-c++">if (caseNum != 0) {
    fill(visit.begin(), visit.end(), false);
    fill(path.begin(), path.end(), -1);
}
</code></pre>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://zyq2652192993zyq.github.io/tag/raBg49h1A/" class="tag">
                    搜索算法——DFS
                  </a>
                
                  <a href="https://zyq2652192993zyq.github.io/tag/aYDWqEIoq/" class="tag">
                    基础算法——贪心
                  </a>
                
                  <a href="https://zyq2652192993zyq.github.io/tag/YAOsNubaS/" class="tag">
                    动态规划——LIS
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://zyq2652192993zyq.github.io/post/gao-jing-du-wen-ti/">
                  <h3 class="post-title">
                    基础算法——高精度问题
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
