<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>CS 631-APUE：Lecture 02 File I/O, File Sharing | Kylin</title>
<meta name="description" content="Talk is cheap, show me the code.">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://zyq2652192993zyq.github.io//favicon.ico?v=1588146938074">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://zyq2652192993zyq.github.io//styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://zyq2652192993zyq.github.io/">
        <img src="https://zyq2652192993zyq.github.io//images/avatar.png?v=1588146938074" class="site-logo">
        <h1 class="site-title">Kylin</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="https://github.com/zyq2652192993zyq" class="site-nav" target="_blank">
            GitHub
          </a>
        
      
        
          <a href="https://zyq2652192993zyq.github.io/" class="site-nav">
            首页
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      Talk is cheap, show me the code.
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://zyq2652192993zyq.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">CS 631-APUE：Lecture 02 File I/O, File Sharing</h2>
            <div class="post-date">2019-12-16</div>
            
            <div class="post-content">
              <p>回忆<code>simple-cat.c</code>的写法，这里<code>read</code> <code>write</code> 函数定义在头文件<code>&lt;unistd.h&gt;</code>内，在APUE 1.5节输入和输出有更详细的解释。</p>
<pre><code class="language-c">//filename: simple-cat.c
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

#ifndef BUFFSIZE
#define BUFFSIZE 32768
#endif

int main()
{
    int n;
    char buffer[BUFFSIZE];

    while ((n = read(STDIN_FILENO, buffer, BUFFSIZE)) &gt; 0) {
        if ((write(STDOUT_FILENO, buffer, n)) != n) {
            fprintf(stderr, &quot;write error!\n&quot;);
            exit(1);
          }
    }

    if (n &lt; 0){
      fprintf(stderr, &quot;read error!\n&quot;);
      exit(1);
    }

    return 0;
}
</code></pre>
<pre><code class="language-shell">$ ./simple-cat &lt; simple-cat.c &gt; out.txt
$ cat out.txt
</code></pre>
<p>其中<code>exit()</code>函数是定义在头文件<code>&lt;stdlib.h&gt;</code>内。<code>stderr</code>可以通过<code>man stderr</code>查看详细信息，定义在头文件<code>&lt;stdio.h&gt;</code>内：</p>
<pre><code class="language-c"> #include &lt;stdio.h&gt;

extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;
</code></pre>
<h2 id="文件描述符">文件描述符</h2>
<p>对于内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。（A <em>file descriptor</em> (or <em>file handle</em>) is a small, non-negative integer which identifies a file to the kernel.）</p>
<p>通常UNIX系统下文件描述符0与进程的标准输入关联，1与标准输出关联，2与标准错误关联。为了可读性，在头文件<code>&lt;unistd.h&gt;</code>中分别替换成符号常量<code>STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO</code>。</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/11/22/FBIHV8ljvfuGq5N.png" alt="" loading="lazy"></figure>
<ul>
<li>prints the value of <code>STDIN FILENO</code>, <code>STDOUT FILENO</code>, <code>STDERR FILENO</code></li>
<li>prints the value of the file descriptors referenced via the <code>stdin</code>, <code>stdout</code>, <code>stderr</code> streams</li>
<li>open(2)’s a file, then prints the value of that file descriptor</li>
<li>fopen(3)’s a file, then prints the value of the file descriptor referenced via that stream</li>
</ul>
<p>这些需求在文件<code>fds.c</code>内实现。（其实这是warm-up exercise的内容）</p>
<pre><code class="language-c">//filename: fds.c
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    printf(&quot;prints the value of STDIN FILENO, STDOUT FILENO, STDERR FILENO.\n&quot;);
    printf(&quot;STDIN_FILENO: %d\n&quot;, STDIN_FILENO);
    printf(&quot;STDOUT_FILENO: %d\n&quot;, STDOUT_FILENO);
    printf(&quot;STDERR_FILENO: %d\n\n&quot;, STDERR_FILENO);

    printf(&quot;prints the value of the file descriptors referenced via the stdin, stdout, stderr streams.\n&quot;);
    printf(&quot;stdin: %d\n&quot;, fileno(stdin));
    printf(&quot;stdout: %d\n&quot;, fileno(stdout));
    printf(&quot;stderr: %d\n\n&quot;, fileno(stderr));

    printf(&quot;open(2)’s a file, then prints the value of that file descriptor.\n&quot;);
    printf(&quot;Opening /dev/zero...\n&quot;);
    int fd1;
    if ((fd1 = open(&quot;/dev/zero&quot;, O_RDONLY)) &lt; 0) {
		  fprintf(stderr, &quot;Unable to open /dev/zero: %s\n&quot;, strerror(errno));
	  } 
    else {
		  printf(&quot;fd1: %d\n&quot;, fd1);
	  }

    int fd2;
    printf(&quot;\nOpening /dev/zero a second time...\n&quot;);
    if ((fd2 = open(&quot;/dev/zero&quot;, O_RDONLY)) &lt; 0){
      fprintf(stderr, &quot;Unable to open /dev/zero: %s/n&quot;, strerror(errno));
      exit(EXIT_FAILURE);
    }
    else {
      printf(&quot;fd2: %d\n&quot;, fd2);
    }

    printf(&quot;\nNow closing fd1, but keeping fd2 open..\n&quot;);
    close(fd1);

    int fd3;
    printf(&quot;\nOpening /dev/zero a third time...\n&quot;);
    if ((fd3 = open(&quot;/dev/zero&quot;, O_RDONLY)) &lt; 0) {
      fprintf(stderr, &quot;Unable to open /dev/zero: %s\n&quot;, strerror(errno));
      exit(EXIT_FAILURE);
    }
    else {
      printf(&quot;fd3: %d\n&quot;, fd3);
    }

    printf(&quot;\nNow closing fd2 and fd3.\n&quot;);
    close(fd2);
    close(fd3);

    printf(&quot;Now opening /dev/zero as a stream.\n&quot;);
    FILE *f;
    if ((f = fopen(&quot;/dev/zero&quot;, &quot;r&quot;)) == NULL) {
      fprintf(stderr, &quot;Unable to open /dev/zero: %s\n&quot;, strerror(errno));
      exit(EXIT_FAILURE);
    }
    printf(&quot;f: %d\n&quot;, fileno(f));
    fclose(f);

    return 0;
}             
</code></pre>
<pre><code class="language-shell">$ gcc -o fds fds.c
$ ./fds
prints the value of STDIN FILENO, STDOUT FILENO, STDERR FILENO.                           
STDIN_FILENO: 0                                                                           
STDOUT_FILENO: 1                                                                          
STDERR_FILENO: 2                                                                          
                                                                                          
prints the value of the file descriptors referenced via the stdin, stdout, stderr streams.
stdin: 0                                                                                  
stdout: 1                                                                                 
stderr: 2                                                                                 
                                                                                          
open(2)’s a file, then prints the value of that file descriptor.                          
Opening /dev/zero...                                                                      
fd1: 3                                                                                    
                                                                                          
Opening /dev/zero a second time...                                                        
fd2: 4                                                                                    
                                                                                          
Now closing fd1, but keeping fd2 open..                                                   
                                                                                          
Opening /dev/zero a third time...                                                         
fd3: 3                                                                                    
                                                                                          
Now closing fd2 and fd3.                                                                  
Now opening /dev/zero as a stream.                                                        
f: 3                                                                                      
</code></pre>
<p>函数<code>fileno()</code>定义在头文件<code>&lt;stdio.h&gt;</code>内，返回文件描述符的值。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int fileno(FILE *stream);
//The function fileno() examines the argument stream and returns its integer file descriptor.
</code></pre>
<p>所以可以通过函数<code>fileno()</code>来查看<code>stdin, stdout, stderr</code>的值。</p>
<p><code>fprintf()</code>定义：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int fprintf(FILE *stream, const char *format, ...);
//The function dprintf() is the same as fprintf() except that it outputs to a file descriptor, fd, instead of to a stdio stream.
</code></pre>
<p><code>errno</code>的定义：</p>
<pre><code class="language-c">#include &lt;errno.h&gt;
/*
The  &lt;errno.h&gt;  header file defines the integer variable errno, which is set by system calls and some library functions in the event of an error to indicate what went wrong.
*/
</code></pre>
<p><code>fds.c</code>程序验证了函数<code>open()</code>返回的文件描述符一定是最小的未用描述符。</p>
<p>文件描述符的变化范围是<code>0~OPENMAX - 1</code>，通过程序<code>openmax.c</code>来判断系统文件描述符的上限和每个进程最多打开的文件数量。</p>
<pre><code class="language-c">//filename: openmax.c
#include &lt;stdio.h&gt;
#include &lt;sys/resource.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

#define OPEN_MAX_GUESS 256

int open_max()
{
#ifdef OPEN_MAX
  	int openmax = OPEN_MAX;
#else
  	int openmax = 0;
#endif

  	if (openmax == 0) {
    	errno = 0;
    	if ((openmax = sysconf(_SC_OPEN_MAX)) &lt; 0) {
      		if (errno == 0)
        		openmax = OPEN_MAX_GUESS;
      		else
        		fprintf(stderr, &quot;sysconf error for _SC_OPEN_MAX\n&quot;);
    	}
	}

  	return openmax;
}

int main()
{
    struct rlimit rlp;
    if (getrlimit(RLIMIT_NOFILE, &amp;rlp) != 0) {
        fprintf(stderr, &quot;Unable to get per process rlimit: %s\n&quot;, strerror(errno));
        exit(EXIT_FAILURE);
    }

    printf(&quot;This user could open %d file descriptors.\n&quot;, open_max());
    printf(&quot;This process could open %d file descriptors.\n&quot;, (int)rlp.rlim_cur);
}
</code></pre>
<pre><code class="language-shell">$ gcc -o openmax openmax.c
$ ./openmax
This user could open 1024 file descriptors.
This process could open 1024 file descriptors.
</code></pre>
<p>函数<code>getrlimit()</code>的定义，可以通过<code>man getrlimit</code>查看其定义：</p>
<pre><code class="language-c">#include &lt;sys/resource.h&gt;

int getrlimit(int resource, struct rlimit *rlim);
/*
 On success, these system calls return 0.  On error, -1 is returned, and errno is set appropriately.
 */
</code></pre>
<p>对于函数<code>getrlimit()</code>的作用：</p>
<pre><code class="language-c">/* 
The  getrlimit()  and  setrlimit()  system calls get and set resource limits respectively.  Each resource has an associated soft and hard limit, as defined by the rlimit structure:
*/

struct rlimit {
	rlim_t rlim_cur;  /* Soft limit */
	rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */
};
</code></pre>
<p>常量<code>RLIMIT_NOFILE</code>也定义在<code>&lt;sys/resource.h&gt;</code>里：</p>
<pre><code class="language-c">/*
RLIMIT_NOFILE:
This specifies a value one greater than the maximum file descriptor number that can be opened by this process.  Attempts (open(2),  pipe(2), dup(2), etc.)  to exceed this limit yield the error EMFILE.
*/
</code></pre>
<p>函数<code>sysconf()</code>定义：</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
long sysconf(int name); //get configuration information at run time

// _SC_OPEN_MAX:
// The maximum number of files that a process can have open at any time.

/*
 On error, -1 is returned and errno is set to indicate the cause of the error。
 */
</code></pre>
<p><code>open_max()</code>函数的设计也是基于<code>sysconf()</code>函数的定义的。如果<code>sysconf()</code>函数出错将返回-1， 并通过<code>errno</code>来提示错误的原因。如果函数的参数恰好是限制的最大值或最小值，并且这个限定值是模糊不确定的，那么<code>errno</code>的数值不会改变。所以为了区分由于限定值不确定造成的错误，一般先将<code>errno</code>设置称为0，当<code>sysconf()</code>返回-1时检查<code>errno</code>的数值是否改变，如果没变就是由限定值不确定造成的错误。（此处的设计思路其实就是<code>man sysconf</code>里<code>RETURN VALUE</code>的部分）</p>
<p>函数<code>open_max()</code>先检查是否定义了<code>OPEN_MAX</code>，定义了就<code>openmax = OPEN_MAX</code>，未定义先初始化为0。然后去检查限定值是否是不确定的。根据上面分分析，令<code>errno = 0</code>，然后检查其值是否发生变化，无变化就将令<code>openmax</code>为我们的猜测值（反正也不确定我们就猜一个好了），如果<code>errno</code>变化了说明是其他类型的错误。注意<code>openmax = sysconf(_SC_OPEN_MAX)</code>发生了隐式类型转换。</p>
<p><strong>不带缓冲</strong>：每个<code>read</code>和<code>write</code>都调用内核中的一个系统调用。</p>
<p>函数<code>open, close, read, write, lseek</code>都提供了不带缓冲的I/O。</p>
<h2 id="函数creat">函数creat</h2>
<p>通过<code>creat</code>函数创建一个新文件：</p>
<pre><code class="language-c">#include &lt;fcntl.h&gt;

int creat(const char * path, mode_t mode);
//return value: file descriptor if OK, -1 on error
</code></pre>
<p><code>creat</code>函数的不足之处是只是写的方式打开创建的文件，如果要创建一个临时文件，需要先写再读文件，需要依次调用<code>creat</code>, <code>close</code>，<code>open</code>，而用<code>open</code>函数只需要：</p>
<pre><code class="language-c">open(path, O_RDWR | O_CREAT | O_TRUNC, mode)
</code></pre>
<pre><code>//目前见到的头文件的缩写的具体含义
file control header -&gt; fcntl.h
unix standard header -&gt; unistd.h
standard input output header -&gt; stdio.h
standard library header -&gt; stdlib.h
</code></pre>
<h2 id="函数open和openat">函数open和openat</h2>
<p>调用<code>open</code>或<code>openat</code>函数可以打开或创建一个文件。</p>
<pre><code class="language-c">#include &lt;fcntl.h&gt;

int open(const char * path, int oflag, .../* mode_t mode */);

int openat(int fd, const char * path, int oflag, .../* mode_t mode */);
//return value: file discriptor if OK, -1 on error
</code></pre>
<p>最后一个参数写为<code>...</code>是表明余下参数的数量及类型是可变的。<code>path</code>参数是要打开或创建文件的名字，其中参数<code>oflag</code>只能是下列选项中的一个并且必须选择一个：</p>
<ul>
<li><code>O_RDONLY</code> : open for reading only</li>
<li><code>O_WRONLY</code> :  open for writing only</li>
<li><code>O_RDWR</code> :  open for reading and writing</li>
</ul>
<p>下列参数可以通过“或”运算来构成<code>oflag</code>参数：</p>
<ul>
<li><code>O_APPEND</code> : 每次写时都追加到文件尾端</li>
<li><code>O_CREAT</code> ：文件不存在就创建它</li>
<li><code>O_EXCL</code> ：如果同时使用了<code>O_CREAT</code>，而文件存在则出错。因此可以测试一个文件是否存在，不存在就创建文件，使测试和创建文件称为一个原子操作。</li>
<li><code>O_TRUNC</code>：文件存在且只写或读-写成功打开，将其长度截断为0。</li>
<li><code>O_NOCTTY</code> ：<code>path</code>引用的是终端设备，则不讲该设备分配作为此进程的控制终端。（在9.6节）</li>
<li><code>O_NONBLOCK</code> ：14.2节。</li>
<li><code>O_SYNC</code> – 使每次<code>write</code>都等待物理I/O完成，包括由该<code>write</code>引起的文件属性更所需的I/O。</li>
</ul>
<p>在其他的一些平台可能支持以下选项：</p>
<ul>
<li><code>O_EXEC</code>：只执行打开</li>
<li><code>O_SEARCH</code>：只搜索打开（应用于目录）。</li>
<li><code>O_DIRECTORY</code>:如果<code>path</code>引用的不是目录则出错。</li>
<li><code>O_DSYNC</code>：使每次<code>write</code>都等待物理I/O完成，但是如果写操作不影响读取刚写入的数据，不需等待文件属性的更新。</li>
<li><code>O_RSYNC</code>：使每一个以文件描述符作为参数的额<code>read</code>操作等待，直至所有对文件同一部分挂起的写操作完成。</li>
<li><code>O_PATH</code>：Obtain a file descriptor purely for fd-level operations. （获取仅用于fd级操作的文件描述符）</li>
</ul>
<p><code>openat()</code>函数存在的一个意义是：让线程可以使用相对路径名打开目录中的文件。</p>
<p><code>fd</code>参数把<code>open</code>和<code>openat</code>函数区分开来</p>
<ol>
<li><code>path</code>参数指定的是绝对路径，<code>fd</code>参数被忽略，两个函数作用一致</li>
<li><code>path</code>参数指定的是相对路径，<code>fd</code>参数指定了相对路径名在文件中的起始地址</li>
</ol>
<h2 id="函数close">函数close</h2>
<pre><code class="language-c">#include &lt;unistd.h&gt;

int close(int fd);
//return value: 0 if OK, -1 on error
</code></pre>
<p>通过程序<code>openex.c</code>来展示<code>open</code>和<code>openat</code>函数的用法。</p>
<pre><code class="language-c">//filename: openex.c
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;

//create a non-existent file
void createFile()
{
  printf(&quot;Trying to create './newfile' with O_RDONLY | O_CREAT...\n&quot;);
  int fd;

  if ((fd = open(&quot;./newfile&quot;, O_RDONLY | O_CREAT, S_IRUSR | S_IWUSR)) == -1) {
    fprintf(stderr, &quot;unable to create ./newfile %s\n&quot;, strerror(errno));
    exit(EXIT_FAILURE);
  }

  printf(&quot;'./newfile' created. File descriptor is: %d\n&quot;, fd);
}

//fail to create an existing failExclFileCreation
void failExclFileCreation()
{
  printf(&quot;Trying to create './newfile' with O_RDONLY | O_CREAT | O_EXCL...\n&quot;);
  int fd;

  if ((fd = open(&quot;./newfile&quot;, O_RDONLY | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR)) == -1) {
    fprintf(stderr, &quot;Unable to create './newfile': %s\n&quot;, strerror(errno));
  }

  if (close(fd) == -1) {
    fprintf(stderr, &quot;Closing failed: %s\n&quot;, strerror(errno));
  }
}

void openFile()
{
  printf(&quot;Trying to open './openex.c' with O_RDONLY...\n&quot;);

  int fd;
  if ((fd = open(&quot;./openex.c&quot;, O_RDONLY)) == -1) {
    fprintf(stderr, &quot;Unable to open './openex.c': %s\n&quot;, strerror(errno));
    exit(EXIT_FAILURE);
  }

  printf(&quot;'./openex.c' opened. File descriptor is: %d\n&quot;, fd);
  close(fd);

  printf(&quot;'./openex.c' closed again\n&quot;);
}

void failOpenNonexistingFile()
{
  printf(&quot;Trying to open (non-existant) './nosuchfile' with O_RDONLY...\n&quot;);
  int fd;

  if ((fd = open(&quot;./nosuchfile&quot;, O_RDONLY)) == -1){
    fprintf(stderr, &quot;Unable to open a nonexist file './nosuchfile': %s\n&quot;, strerror(errno));
  }

  close(fd);
}

void truncateFile()
{
  printf(&quot;Trying to open './newfile  with O_RDONLY | O_TRUNC...\n&quot;);
  int fd;

  if ((fd = open(&quot;./newfile&quot;, O_RDONLY | O_TRUNC)) == -1) {
    fprintf(stderr, &quot;Unable to open './newfile': %s\n&quot;, strerror(errno));
    exit(EXIT_FAILURE);
  }

  printf(&quot;'./newfile' opened. File descriptor is: %d\n&quot;, fd);
  printf(&quot;'./newfile' truncated -- see 'ls -l newfile'\n&quot;);

  close(fd);
}

int main()
{
  createFile();
  system(&quot;ls -l newfile&quot;);
  sleep(2);
  printf(&quot;\n&quot;);

  //&quot;create&quot; an existing file
  createFile();
  system(&quot;ls -l newfile&quot;);
  sleep(2);
  printf(&quot;\n&quot;);

  //fail to create an existing file
  failExclFileCreation();
  printf(&quot;\n&quot;);

  //open an existing file
  openFile();
  sleep(2);
  printf(&quot;\n&quot;);

  //fail to open a non-existing file
  failOpenNonexistingFile();
  printf(&quot;\n&quot;);
  sleep(2);

  //truncate an existing file
  printf(&quot;now cp openex.c newfile\n&quot;);
  system(&quot;cp openex.c newfile&quot;);
  system(&quot;ls -l newfile&quot;);
  truncateFile();
  system(&quot;ls -l newfile&quot;);

  return 0;
}
</code></pre>
<pre><code class="language-shell">$ gcc -o openex openex.c
$ ./openex
Trying to create './newfile' with O_RDONLY | O_CREAT...
'./newfile' created. File descriptor is: 3
-rw------- 1 kylin kylin 0 Nov 24 14:45 newfile

Trying to create './newfile' with O_RDONLY | O_CREAT...
'./newfile' created. File descriptor is: 4
-rw------- 1 kylin kylin 0 Nov 24 14:45 newfile

Trying to create './newfile' with O_RDONLY | O_CREAT | O_EXCL...
Unable to create './newfile': File exists
Closing failed: Bad file descriptor

Trying to open './openex.c' with O_RDONLY...
'./openex.c' opened. File descriptor is: 5
'./openex.c' closed again

Trying to open (non-existant) './nosuchfile' with O_RDONLY...
Unable to open a nonexist file './nosuchfile': No such file or directory

now cp openex.c newfile
-rw------- 1 kylin kylin 2632 Nov 24 14:45 newfile
Trying to open './newfile  with O_RDONLY | O_TRUNC...
'./newfile' opened. File descriptor is: 5
'./newfile' truncated -- see 'ls -l newfile'
-rw------- 1 kylin kylin 0 Nov 24 14:45 newfile
</code></pre>
<p>函数<code>system()</code>定义：</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int system(const char *command);
/*
The  system()  library  function uses fork(2) to create a child process that executes the shell command specified in command using execl(3) as follows:

	execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, command, (char *) 0);
	
system() returns after the command has been completed.
*/

/*
 The return value of system() is one of the following:
 - If command is NULL, then a nonzero value if a shell is available, or 0 if no shell is available.
 - If a child process could not be created, or its status could not be retrieved, the return value is -1
 - If  a  shell  could not be executed in the child process, then the return value is as though the child shell terminated by calling _exit(2) with the status 127.
 - If all system calls succeed, then the return value is the termination status of the child shell used to execute command.
 */
</code></pre>
<p><code>system()</code>函数这里我们不太需要关注其返回值。因为根据手册显示，其调用<code>fork()</code>来创建一个子进程，子进程里调用函数<code>exel</code>来执行<code>shell</code>命令。我们通过<code>sleep(2)</code>来等待其执行完毕。</p>
<p><code>sleep()</code>函数定义:</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;

unsigned int sleep(unsigned int seconds);
/*
参数： 挂起的时间数 ，单位为秒

返回值：若进程/线程挂起到参数所指定的时间则返回0，若有信号中断则返回剩余秒数。
*/
</code></pre>
<p>注意这里<code>exit</code>函数的使用要慎重。<code>return</code>是结束当前函数的调用，而<code>exit</code>是在操作系统层面的。</p>
<h2 id="函数read和write">函数read和write</h2>
<pre><code class="language-c">#include &lt;unistd.h&gt;

ssize_t read(int fd, void *buf, size_t nbytes);
//return value: number of bytes read, 0 if end of file, -1 on error
</code></pre>
<pre><code class="language-c">#include &lt;unistd.h&gt;

ssize_t write(int fd, const void *buf, size_t nbytes);
//return value: number of bytes written if OK, -1 on error
</code></pre>
<p><code>read</code>和<code>write</code>的使用例子在文件<code>rwex.c</code>内。</p>
<pre><code class="language-c">//filename: rwex.c
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

#define COMMENT		&quot;\n/* Just another comment. */\n&quot;
#define BUFFSIZE 64
#define SOURCE &quot;./rwex.c&quot;

int main()
{
  char buffer[BUFFSIZE];
  int fd;

  if ((fd = open(SOURCE, O_RDWR | O_APPEND)) == -1) {
    fprintf(stderr, &quot;Unable to open '%s': %s\n&quot;, SOURCE, strerror(errno));
    exit(EXIT_FAILURE);
  }

  int n;
  if ((n = read(fd, buffer, BUFFSIZE)) &gt; 0) {
    if (write(STDOUT_FILENO, buffer, n) != n) {
      fprintf(stderr, &quot;Unable to write: %s\n&quot;, strerror(errno));
      exit(EXIT_FAILURE);
    }
  }

  printf(&quot;\n\nOk, we read the first %d bytes. Now let's write something.\n&quot;, BUFFSIZE);
  
  int len = sizeof(COMMENT) - 1;
  if (write(fd, COMMENT, len) != len) {
    fprintf(stderr, &quot;Unable to write: %s\n&quot;, strerror(errno));
    exit(EXIT_FAILURE);
  }
  close(fd);

  return 0;
}
</code></pre>
<pre><code class="language-shell">$ gcc -o rwex rwex.c
$ ./rwex
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#inclu

Ok, we read the first 64 bytes. Now let's write something.
</code></pre>
<p>程序33-37行的作用是在文件<code>rwex.c</code>的末尾添<code>COMMENT</code>，效果是一个空行，一行注释文字。</p>
<h2 id="函数lseek">函数lseek</h2>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

off_t lseek(int fd, off_t offset, int whence);
//return values: new file offset if OK, -1 on error
</code></pre>
<p>也可以在终端通过命令<code>man lseek</code>查看<code>lseeek</code>的更详细内容。</p>
<p>每个文件都有一个与其关联的当前文件偏移量，通常是一个非负整数，度量从一个文件开始处计算的字节数。通常读、写操作都是从当前文件偏移量开始。参数<code>offset</code>和参数<code>whence</code>有关：</p>
<ul>
<li><code>whence = SEEK_SET</code>，将文件偏移量设置为距离文件开始处<code>offset</code>个字节。</li>
<li><code>whence = SEEK_CUR</code>， 将文件偏移量设置为当前偏移量加上<code>offset</code>，<code>offset</code>数值可正可负。</li>
<li><code>whence = SEEK_END</code>，将文件偏移量设置为文件长度加上<code>offset</code>。</li>
</ul>
<p><code>SEEK_SET, SEEK_CUR, SEEK_END</code>定义在头文件<code>&lt;stdio.h&gt;</code>内，可以打印查看其值：</p>
<pre><code class="language-c">//filename: test.c
#include &lt;stdio.h&gt;

int main()
{
    printf(&quot;SEEK_SET: %d\n&quot;, SEEK_SET);
    printf(&quot;SEEK_CUR: %d\n&quot;, SEEK_CUR);
    printf(&quot;SEEK_END: %d\n&quot;, SEEK_END);
    
    return 0;
}
</code></pre>
<pre><code class="language-shell">$ gcc test.c -o test
$ ./test
SEEK_SET: 0
SEEK_CUR: 1
SEEK_END: 2
</code></pre>
<p>用法：</p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

off_t currpos = lseek(fd, 0, SEEK_CUR); //fd is the file descriptor
</code></pre>
<p>如果文件描述符是指向一个管道、FIFO或网络套接字，则<code>lseek</code>返回-1，并将<code>errno</code>设置为<code>ESPIPE</code>。</p>
<pre><code class="language-c">//filename: lseek.c
#include &lt;stdio.h&gt;                               
#include &lt;sys/types.h&gt;                           
#include &lt;unistd.h&gt;                              
                                                 
int main()                                       
{                                                
    if (lseek(STDIN_FILENO, 0, SEEK_CUR) == -1)  
      printf(&quot;cannot seek!\n&quot;);                  
    else                                         
      printf(&quot;seek OK!\n&quot;);                      
                                                 
    return 0;                                    
}                                                
</code></pre>
<pre><code class="language-shell">$ gcc lseek.c -o lseek
$ ./lseek &lt; /etc/passwd
seek OK!
$ cat &lt; /etc/passwd | ./lseek
cannot seek!
</code></pre>
<p><code>lseek</code> 将当前文件偏移量记录在内核中，并不引起I/O操作。文件偏移量可以大于文件的当前长度。对该文件的写将加长文件并在文件上形成一个空洞，文件中没有写过的字节都被读为0.</p>
<p>APUE的55页程序，在<code>apue.h</code>里<code>FILE_MODE</code>是一个宏定义的变量：这些参数在第四章会有详细说明。</p>
<pre><code class="language-c">//apue.h
#define  FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
</code></pre>
<pre><code class="language-c">//filename: hole.c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;string.h&gt;

#define BIGNUM 10240000

int main()
{
  int fd;
  if ((fd = creat(&quot;file.hole&quot;, S_IRUSR | S_IWUSR)) == -1) {
    perror(&quot;creat error&quot;);
    return EXIT_FAILURE;
  }

  char buf1[] = &quot;abcdefghij&quot;;
  if (write(fd, buf1, strlen(buf1)) != (ssize_t)(strlen(buf1))) {
    perror(&quot;error writing buf1&quot;);
    return EXIT_FAILURE;
  }
  /* offset now is 10 */ 

  if (lseek(fd, BIGNUM, SEEK_CUR) == -1) {
    perror(&quot;lseek error&quot;);
    return EXIT_FAILURE;
  }
  /* offset now is 10 + 1024000 */

  char buf2[] = &quot;ABCDEFGHIJ&quot;;
  if (write(fd, buf2, strlen(buf2)) != (ssize_t)strlen(buf2)) {
    perror(&quot;error writing buf2&quot;); 		
    return EXIT_FAILURE;
  }
  /* offset now is 10 + 1024000 + 10 */

  return 0;
}
</code></pre>
<pre><code class="language-shell">$ gcc -o hole hole.c
$ ./hole
$ ls -l file.hole
-rw------- 1 kylin kylin 10240020 Nov 24 17:05 file.hole
$ od -c file.hole
0000000   a   b   c   d   e   f   g   h   i   j  \0  \0  \0  \0  \0  \0  
0000020  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  
*                                                                        
47040000  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0   A   B   C   D   E   F 
47040020   G   H   I   J                                                 
47040024       
$ cat file.hole &gt; file.nohole
$ ls -ls file.*
10004 -rw------- 1 kylin kylin 10240020 Nov 24 17:05 file.hole
11264 -rw-rw-rw- 1 kylin kylin 10240020 Nov 24 17:12 file.nohole
</code></pre>
<p>函数<code>perror()</code>的定义：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void perror(const char *s); // print a system error message
</code></pre>
<p>用来将上一个函数发生错误的原因输出到标准设备(<code>stderr</code>)。参数 <code>s</code>所指的字符串会先打印出,后面再加上错误原因字符串。此错误原因依照全局变量<code>errno</code> 的值来决定要输出的字符串。用法例子：</p>
<pre><code class="language-c">//filename: perror.c
#include &lt;stdio.h&gt;                
                                  
int main()                        
{                                 
  FILE *p;                        
  p = fopen(&quot;./nosuchfile&quot;, &quot;r+&quot;);
  if (p == NULL) {                
    perror(&quot;./nosuchfile&quot;);       
  }                               
                                  
  return 0;                       
}                                 
</code></pre>
<pre><code class="language-shell">$ gcc -o perror perror.c
$ ./perror
./nosuchfile: No such file or directory
</code></pre>
<p>函数<code>strlen()</code>的定义：</p>
<pre><code class="language-c">#include &lt;string.h&gt;

size_t strlen(const char *s); //calculate the length of a string
</code></pre>
<p>因为<code>write()</code>函数的返回类型是<code>ssize_t</code>，所以通过<code>(ssize_t)strlen(buf1)</code>来进行显示的强制类型转换。</p>
<p>命令<code>od</code> 是以8进制打印文件的实际内容，<code>-c</code>选项是选择可以打印的字符。</p>
<h2 id="io的效率">I/O的效率</h2>
<p>当<code>BUFFSIZE</code>超过4096时，继续增加缓冲区长度对时间几乎没有影响。</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://zyq2652192993zyq.github.io/tag/uIVZQldDP/" class="tag">
                    操作系统——APUE
                  </a>
                
              </div>
            
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
