<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>最大子矩形的降维分析方法 | Kylin</title>
<meta name="description" content="Talk is cheap, show me the code.">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://zyq2652192993zyq.github.io//favicon.ico?v=1589775979401">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://zyq2652192993zyq.github.io//styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://zyq2652192993zyq.github.io/">
        <img src="https://zyq2652192993zyq.github.io//images/avatar.png?v=1589775979401" class="site-logo">
        <h1 class="site-title">Kylin</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="https://github.com/zyq2652192993zyq" class="site-nav" target="_blank">
            GitHub
          </a>
        
      
        
          <a href="https://zyq2652192993zyq.github.io/" class="site-nav">
            首页
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      Talk is cheap, show me the code.
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://zyq2652192993zyq.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">最大子矩形的降维分析方法</h2>
            <div class="post-date">2019-11-11</div>
            
              <div class="feature-container" style="background-image: url('https://zyq2652192993zyq.github.io//post-images/zui-da-zi-ju-xing-de-jiang-wei-fen-xi-fang-fa.png')">
              </div>
            
            <div class="post-content">
              <p><strong>文中提到的题目可在我GitHub的<a href="https://github.com/zyq2652192993zyq/LeetCode">LeetCode</a>, <a href="https://github.com/zyq2652192993zyq/SJTU-Online-Judge">SJTU OJ</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Algorithm%20Analysis">Algorithm Analysis</a>, <a href="https://github.com/zyq2652192993zyq/Advance-Algorithm/tree/master/Problem%20Solution">Problem Solution</a>找到解答。</strong></p>
<p>最大子矩形类问题有很多种形式：比如找最大01矩阵，比如找最大子矩形和等。这里将其限制在最大子矩形和上，通过<code>LeetCode 363.Max Sum of Rectangle No Larger Than K</code>这样一道<code>Hard</code>类型的题目来讲述降维的分析方法。</p>
<p>Given a non-empty 2D matrix <em>matrix</em> and an integer <em>k</em>, find the max sum of a rectangle in the <em>matrix</em> such that its sum is no larger than <em>k</em>.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: matrix = [[1,0,1],[0,-2,3]], k = 2
Output: 2 
Explanation: Because the sum of rectangle [[0, 1], [-2, 3]] is 2,
             and 2 is the max number no larger than k (k = 2).
</code></pre>
<p><strong>Note:</strong></p>
<ol>
<li>The rectangle inside the matrix must have an area &gt; 0.</li>
<li>What if the number of rows is much larger than the number of columns?</li>
</ol>
<hr>
<p>这道题目初看如果采用暴力搜索，时间复杂度一定很高，但是联系之前做过的一维最大连续子数组，是否可以从中去找到一些思路？总结下来主要分为四个关键步骤：</p>
<ul>
<li>一维数组下最大的连续子数组和</li>
<li>一维数组下不超过K的最大连续子数组和（变形问题：小于K等）</li>
<li>二维数组的最大子矩形的和</li>
<li>二维数组下不超过K的最大子矩形和（本题）。</li>
</ul>
<h1 id="一维数组下最大的连续子数组和">一维数组下最大的连续子数组和</h1>
<p>也就是<code>53.Maximum Subarray</code>，列出一个状态转移方程即可，当前元素加入前面序列，或者另起一个新的序列。</p>
<p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
</code></pre>
<p><strong>Follow up:</strong></p>
<p>If you have figured out the O(<em>n</em>) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<hr>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>d</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>max</mi><mo>⁡</mo><mo>{</mo><mi>d</mi><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>+</mo><mi>S</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo separator="true">,</mo><mi>S</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>}</mo><mo separator="true">,</mo><mi mathvariant="normal">其</mi><mi mathvariant="normal">中</mi><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>target</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>max</mi><mo>⁡</mo><mo>{</mo><mi>d</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>}</mo><mo separator="true">,</mo><mi mathvariant="normal">其</mi><mi mathvariant="normal">中</mi><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} 
d[j] &amp;=\max \{d[j-1]+S[j], S[j]\}, 其中1 \leq j \leq n \\
\text {target} &amp;=\max \{d[j]\},其中1 \leq j \leq n
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000000000000004em;vertical-align:-1.2500000000000002em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">target</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop">max</span><span class="mopen">{</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">n</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop">max</span><span class="mopen">{</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<pre><code class="language-c++">class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int tmpSum, maxSum;
        tmpSum = maxSum = nums[0];
        
        for (int i = 1; i &lt; nums.size(); ++i){
            tmpSum = max(tmpSum + nums[i], nums[i]);
            maxSum = max(maxSum, tmpSum);
        }
        
        return maxSum;
    }
};
</code></pre>
<h1 id="一维数组下不超过k的最大连续子数组和">一维数组下不超过K的最大连续子数组和</h1>
<p>这个问题还可以衍生出下列三种变化形式：</p>
<ul>
<li>一维数组下小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>的最大连续子数组和</li>
<li>一维数组下不小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>的最小连续子数组和</li>
<li>一维数组下大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>的最小连续子数组和</li>
</ul>
<ol>
<li>首先分析<strong>一维数组下不超过K的最大连续子数组和</strong></li>
</ol>
<p><strong>一维数组下最大的连续子数组和</strong>可以视为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo>=</mo><mo>+</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">K = +\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">∞</span></span></span></span>的特殊情形。这里采用前缀和的思路，不妨设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">S_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是数组前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>项的和，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>是数组前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>项的和，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><msub><mi>S</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_m - S_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>就是数组从位置<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>到位置<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>的和，也就是一个子数组的和。</p>
<p>原问题可以转化成：设满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><msub><mi>S</mi><mi>n</mi></msub><mo>≤</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_m -S_n \leq k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的集合为可行集<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span>，我们要找<code>max_element(Q)</code>。对于每一次查找过程，可以认为在对应次查找中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">S_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>是固定的，也就是要去寻找<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的位置，因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub><mo>≥</mo><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_n \geq S_m -k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，要使能找到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span>里面最大的值，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>应该尽可能的小，也就是寻找<strong>第一个不小于目标值的数</strong>，所以应选择<code>lower_bound</code>。时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

const int INF = 0x0ffffff;

int maxSubArray(vector&lt;int&gt; &amp; nums, int k)
{
    set&lt;int&gt; prefixSum;
    prefixSum.emplace(0);
    int sum = 0, tmpSum = -INF;

    for (auto e : nums) {
        sum += e;
        auto pos = prefixSum.lower_bound(sum - k);
        if (pos != prefixSum.end() &amp;&amp; sum - *pos &gt; tmpSum) {
            tmpSum = sum - *pos;
            if (tmpSum == k){
                return tmpSum;
            }
        }
        prefixSum.emplace(sum);
    }

    return tmpSum;
}


int main()
{
    vector&lt;int&gt; nums = {-2,1,-3,4,-1,2,1,-5,4};
    int k = 5; //6为最大
    cout &lt;&lt; maxSubArray(nums, k) &lt;&lt; endl;

    return 0;
}
//输出为5
</code></pre>
<p>这里如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>小于数组里的所有数，那么就输出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mi>I</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">-INF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span>。</p>
<ol start="2">
<li>题目变形，分析<strong>一维数组下小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>的最大连续子数组和</strong></li>
</ol>
<p>相当于找<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><msub><mi>S</mi><mi>n</mi></msub><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_m - S_n &lt; k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，转化为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub><mo>&gt;</mo><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_n &gt; S_m - k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，这里为了让<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_m - S_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>尽可能的大，那么应该让<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>尽可能的小，所以对应次查找可以认为目标值是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_m - k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，也就是<strong>找第一个大于目标值的数</strong>，也就是用函数<code>upper_bound</code>。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

const int INF = 0x0ffffff;

int maxSubArray(vector&lt;int&gt; &amp; nums, int k)
{
    set&lt;int&gt; prefixSum;
    prefixSum.emplace(0);
    int sum = 0, tmpSum = -INF;

    for (auto e : nums) {
        sum += e;
        auto pos = prefixSum.upper_bound(sum - k);
        if (pos != prefixSum.end() &amp;&amp; sum - *pos &gt; tmpSum) {
            tmpSum = sum - *pos;
            if (tmpSum == k){
                return tmpSum;
            }
        }
        prefixSum.emplace(sum);
    }

    return tmpSum;
}


int main()
{
    vector&lt;int&gt; nums = {-2,1,-3,4,-1,2,1,-5,4};
    int k = 5; //6为最大
    cout &lt;&lt; maxSubArray(nums, k) &lt;&lt; endl;

    return 0;
}
//输出为4
</code></pre>
<ol start="3">
<li><strong>一维数组下不小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>的最小连续子数组和</strong>。（类似<code>leetcode 862.Shortest Subarray with Sum at Least K</code>）</li>
</ol>
<p>这个问题其实和<code>LeetCode 862</code>只是题面类似，但是解题方法可是差别很大。题目等价于找<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><msub><mi>S</mi><mi>n</mi></msub><mo>≥</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_m - S_n \geq k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，转化为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub><mo>≤</mo><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_n \leq S_m -k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，并且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>还要尽可能的大，那么目标值就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_m - k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，相当于找最后一个不大于目标值的数，则转化为<code>upper_bound</code>的问题，因为<code>upper_bound</code>找到的是第一个大于目标值的数，那么这个数前面的就是<strong>最后一个不大于目标值的数</strong>。相较于前面的问题，只需要将迭代器位置前移一个位置即可。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

const int INF = 0x0ffffff;

int maxSubArray(vector&lt;int&gt; &amp; nums, int k)
{
    set&lt;int&gt; prefixSum;
    prefixSum.emplace(0);
    int sum = 0, tmpSum = INF;

    for (auto e : nums) {
        sum += e;
        auto pos = prefixSum.upper_bound(sum - k);
        if (pos != prefixSum.begin() &amp;&amp; sum - *prev(pos) &lt; tmpSum &amp;&amp; sum - *prev(pos) &gt;= k) {
            tmpSum = sum - *prev(pos);
            if (tmpSum == k){
                return tmpSum;
            }
        }
        prefixSum.emplace(sum);
    }

    return tmpSum;
}


int main()
{
    vector&lt;int&gt; nums = {-2,1,-3,4,-1,2,1,-5,4};
    int k = -7; //6为最大
    cout &lt;&lt; maxSubArray(nums, k) &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>这里分别令<code>k = -7, k = 0, k = 5, k = 10</code>来进行验证，依次输出<code>-5, 0, 5, INF</code>则正确。</p>
<ol start="4">
<li><strong>一维数组下大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>的最小连续子数组和</strong></li>
</ol>
<p>题目等价于找<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><msub><mi>S</mi><mi>n</mi></msub><mo>&gt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_m - S_n &gt; k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，转化为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub><mo>&lt;</mo><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_n &lt; S_m -k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，并且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>还要尽可能的大，那么目标值就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">S_m - k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，相当于找最后一个小于目标值的数，则转化为<code>lower_bound</code>的问题，因为<code>lower_bound</code>找到的是第一个不小于目标值的数，那么这个数前面的就是<strong>最后一个小于目标值的数</strong>。相较于前面的问题，只需要将迭代器位置前移一个位置即可。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

const int INF = 0x0ffffff;

int maxSubArray(vector&lt;int&gt; &amp; nums, int k)
{
    set&lt;int&gt; prefixSum;
    prefixSum.emplace(0);
    int sum = 0, tmpSum = INF;

    for (auto e : nums) {
        sum += e;
        auto pos = prefixSum.lower_bound(sum - k);
        if (pos != prefixSum.begin() &amp;&amp; sum - *prev(pos) &lt; tmpSum &amp;&amp; sum - *prev(pos) &gt; k) {
            tmpSum = sum - *prev(pos);
            if (tmpSum == k){
                return tmpSum;
            }
        }
        prefixSum.emplace(sum);
    }

    return tmpSum;
}


int main()
{
    vector&lt;int&gt; nums = {-2,1,-3,4,-1,2,1,-5,4};
    int k = 5; //6为最大
    cout &lt;&lt; maxSubArray(nums, k) &lt;&lt; endl;

    return 0;
}
</code></pre>
<h1 id="二维数组的最大子矩形的和">二维数组的最大子矩形的和</h1>
<p>一维的最大连续子数组我们已经会求了，那么二维的情况可以把他压缩成一维的情况。可以参考的题目是<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1081">HDU 1081.To The Max</a>。</p>
<pre><code class="language-c++">//HDU 1081
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

const int INF = 0x0ffffff;

int maxSubArray(vector&lt;int&gt; &amp; nums)
{
    int n = nums.size();
    if (n == 0) return INF;

    int res = -INF, tmpSum = 0;
    // for (auto e : nums) {
    //     tmpSum = max(tmpSum + e, e);
    //     res = max(res, tmpSum);
    // }
    for (int i = 0; i &lt; n; ++i) {
        tmpSum = max(tmpSum + nums[i], nums[i]);
        res = max(res, tmpSum);
    }

    return res;
}


int maxSubMatrix(vector&lt;vector&lt;int&gt; &gt; &amp; nums)
{
    int m = nums.size();
    int res = -INF;
    int n = nums[0].size();

    vector&lt;int&gt; subMax(n, 0);

    for (int i = 0; i &lt; m; ++i) {
        fill(subMax.begin(), subMax.end(), 0);
        for (int j = i; j &lt; m; ++j) {
            for (int k = 0; k &lt; n; ++k) {
                subMax[k] += nums[j][k];
            }
            res = max(res, maxSubArray(subMax));
        }
    }

    return res;
}

int main()
{
    std::ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n;
    cin &gt;&gt; n;
    vector&lt;vector&lt;int&gt; &gt; matrix(n, vector&lt;int&gt;(n, 0));
    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            cin &gt;&gt; matrix[i][j];
        }
    }

    cout &lt;&lt; maxSubMatrix(matrix) &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>这道题目如果把上面代码直接粘过去会<code>wrong answer</code>，但是放到<a href="http://poj.org/problem?id=1050">POJ 1050-To the Max</a>就会通过，注意POJ不支持C++11的许多新特性。</p>
<h1 id="二维数组下不超过k的最大子矩形和本题">二维数组下不超过K的最大子矩形和（本题）</h1>
<p>如果上面的方法掌握了，那么会发现到这里只需要去把<code>res = max(res, maxSubArray(subMax));</code>改为<code>res = max(res, maxSubArray(subMax, k));</code>即可。代码见最下方。</p>
<p>那么扩展一下，如果要找小于k的最大子矩形和呢？改动的也只有两个地方，一个是在时间复杂度选择那里，不能出现等于的情况；另一个就是传入的<code>maxSubArray</code>函数的形式应该根据第二大类的讨论来进行相应修改。</p>
<p>进一步，如果想找不小于k的最小子矩形和呢？找大于k的最小子矩形和呢？方法就同理了。</p>
<p>回到本题，会发现一个很奇怪的现象，下面几段代码均可通过，但是速度却是千差万别！</p>
<p>先看一个超时但是思路是正确的（在倒数第二个大数据量超时）</p>
<pre><code>Time Limit Exceeded.
</code></pre>
<pre><code class="language-c++">class Solution {
int maxSubArray(vector&lt;int&gt; &amp; nums, int k)
{
    set&lt;int&gt; prefixSum;
    prefixSum.emplace(0);
    int sum = 0, tmpSum = INT_MIN;

    for (auto e : nums) {
        sum += e;
        auto pos = prefixSum.lower_bound(sum - k);
        if (pos != prefixSum.end() &amp;&amp; sum - *pos &gt; tmpSum) {
            tmpSum = sum - *pos;
            if (tmpSum == k){
                return tmpSum;
            }
        }
        prefixSum.emplace(sum);
    }

    return tmpSum;
}
    
public:
    int maxSumSubmatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {
        std::ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        
        int res = INT_MIN;
        int n = matrix[0].size(), m = matrix.size();

        vector&lt;int&gt; subMax(n, 0);

        for (int i = 0; i &lt; m; ++i) {
            fill(subMax.begin(), subMax.end(), 0);
            for (int j = i; j &lt; m; ++j) {
                for (int k = 0; k &lt; n; ++k) {
                    subMax[k] += matrix[j][k];
                }
                res = max(res, maxSubArray(subMax, k));
            }
        }

        return res;
    }
};
</code></pre>
<p>下面这个仅仅是改动了通过行求子数组还是列求子数组，代码就通过了。</p>
<pre><code>Runtime: 380 ms
Memory Usage: 106.5 MB
</code></pre>
<pre><code class="language-c++">class Solution {
int maxSubArray(vector&lt;int&gt; &amp; nums, int k)
{
    set&lt;int&gt; prefixSum;
    prefixSum.emplace(0);
    int sum = 0, tmpSum = INT_MIN;

    for (auto e : nums) {
        sum += e;
        auto pos = prefixSum.lower_bound(sum - k);
        if (pos != prefixSum.end() &amp;&amp; sum - *pos &gt; tmpSum) {
            tmpSum = sum - *pos;
            if (tmpSum == k){
                return tmpSum;
            }
        }
        prefixSum.emplace(sum);
    }

    return tmpSum;
}
    
public:
    int maxSumSubmatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {
        std::ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        
        int res = INT_MIN;
        int n = matrix[0].size(), m = matrix.size();

        if (m * m * n &lt; n * n * m) {
            for (int i = 0; i &lt; m; ++i) {
                vector&lt;int&gt; subMax(n, 0);
                for (int j = i; j &lt; m; ++j) {
                    for (int k = 0; k &lt; n; ++k) {
                        subMax[k] += matrix[j][k];
                    }
                    res = max(res, maxSubArray(subMax, k));
                }
            }
        }
        else{
            for (int i = 0; i &lt; n; ++i) {
                vector&lt;int&gt; subMax(m, 0);
                for (int j = i; j &lt; n; ++j) {
                    for (int k = 0; k &lt; m; ++k) {
                        subMax[k] += matrix[k][j];
                    }
                    res = max(res, maxSubArray(subMax, k));
                }
            }
        }
        
        return res;
    }
};
</code></pre>
<p>下面这个版本增加了一步判断，如果连续子数组的最大值都小于k，那么就没必要去寻找不超过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>的子数组了，相当于节省了比较费时的一步。这里其实应该可以想到，毕竟找最大连续子数组时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，而找不超过k的连续子数组时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。效果很明显，时间降了一半多。</p>
<pre><code>Runtime: 128 ms
Memory Usage: 11.1 MB
</code></pre>
<pre><code class="language-c++">class Solution {
int maxSubArray(vector&lt;int&gt; &amp; nums, int k)
{
    set&lt;int&gt; prefixSum;
    prefixSum.emplace(0);
    int sum = 0, tmpSum = INT_MIN;

    for (auto e : nums) {
        sum += e;
        auto pos = prefixSum.lower_bound(sum - k);
        if (pos != prefixSum.end() &amp;&amp; sum - *pos &gt; tmpSum) {
            tmpSum = sum - *pos;
            if (tmpSum == k){
                return tmpSum;
            }
        }
        prefixSum.emplace(sum);
    }

    return tmpSum;
}

int maxSubArray(vector&lt;int&gt; &amp; nums)
{
    int n = nums.size();
    if (n == 0) return INT_MIN;

    int res = INT_MIN, tmpSum = 0;
    for (auto e : nums) {
        tmpSum = max(tmpSum + e, e);
        res = max(res, tmpSum);
    }

    return res;
}
    
public:
    int maxSumSubmatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {
        int res = INT_MIN;
        int n = matrix[0].size(), m = matrix.size();

        for (int i = 0; i &lt; m; ++i) {
            vector&lt;int&gt; subMax(n, 0);
            for (int j = i; j &lt; m; ++j) {
                for (int k = 0; k &lt; n; ++k) {
                    subMax[k] += matrix[j][k];
                }
                int tmp = maxSubArray(subMax);
                if (tmp &lt;= k) {
                    res = max(res, tmp);
                    continue;
                }
                res = max(res, maxSubArray(subMax, k));
            }
        }
        
        
        return res;
    }
};
auto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();
</code></pre>
<p>来看看讨论区的20ms的解法和我的差别在哪里。差别在于它只选择通过列来寻找。速度是20ms。它的<code>maxS</code>就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>。</p>
<pre><code class="language-c++">class Solution {
public:
    int maxSumSubmatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int maxS) {
        int maxA = INT32_MIN, r = matrix.size(), c = matrix[0].size();
        for(int i = 0; i &lt; c; ++i) {
            vector&lt;int&gt; sum(r, 0);
            if(maxA == maxS) return maxA; // Stop if we can reach maxS
            for(int j = i; j &lt; c; ++j) {
                for(int k = 0; k &lt; r; ++k) sum[k] += matrix[k][j];
                
                //First try Kadane's Algo and see if maxSum is less than maxS. 
                int curMax = INT32_MIN, curSum = 0;
                for(int k = 0; k &lt; r; ++k) {
                    curSum += sum[k];
                    curMax = max(curMax, curSum);
                    if(curSum &lt; 0) curSum = 0;
                }
                if(curMax &lt;= maxS) {maxA = max(maxA, curMax); continue;}
                
                // Only apply slow method when there maxSum that is greater than maxS.
                int csum = 0;
                set&lt;int&gt; s({csum});
                for(int k = 0; k &lt; r; ++k) {
                    csum += sum[k];
                    auto it = s.lower_bound(csum - maxS);
                    if(it != s.end()) maxA = max(maxA, csum - *it);
                    s.insert(csum);
                }
            }
        }
        return maxA;
    }
};

auto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();
</code></pre>
<p>于是我把刚刚运行128ms的代码改成通过按列来寻找，速度确实立刻到了16ms。</p>
<pre><code>Runtime: 16 ms
Memory Usage: 11 MB
</code></pre>
<pre><code class="language-c++">class Solution {
int maxSubArray(vector&lt;int&gt; &amp; nums, int k)
{
    set&lt;int&gt; prefixSum;
    prefixSum.emplace(0);
    int sum = 0, tmpSum = INT_MIN;

    for (auto e : nums) {
        sum += e;
        auto pos = prefixSum.lower_bound(sum - k);
        if (pos != prefixSum.end() &amp;&amp; sum - *pos &gt; tmpSum) {
            tmpSum = sum - *pos;
            if (tmpSum == k){
                return tmpSum;
            }
        }
        prefixSum.emplace(sum);
    }

    return tmpSum;
}

int maxSubArray(vector&lt;int&gt; &amp; nums)
{
    int n = nums.size();
    if (n == 0) return INT_MIN;

    int res = INT_MIN, tmpSum = 0;
    for (auto e : nums) {
        tmpSum = max(tmpSum + e, e);
        res = max(res, tmpSum);
    }

    return res;
}
    
public:
    int maxSumSubmatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {
        int res = INT_MIN;
        int n = matrix[0].size(), m = matrix.size();

        for (int i = 0; i &lt; n; ++i) {
            vector&lt;int&gt; subMax(m, 0);
            for (int j = i; j &lt; n; ++j) {
                for (int k = 0; k &lt; m; ++k) {
                    subMax[k] += matrix[k][j];
                }
                int tmp = maxSubArray(subMax);
                if (tmp &lt;= k) {
                    res = max(res, tmp);
                    continue;
                }
                res = max(res, maxSubArray(subMax, k));
            }
        }
        
        
        return res;
    }
};
auto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();
</code></pre>
<p>通过上面的一系列探索，可以发现有两个关键点：</p>
<ul>
<li>在时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的判断选择上，这个必须有才能进行加速。</li>
<li>在通过行还是列来进行搜索区别很大，也就是总体时间复杂度或者是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>m</mi><mn>2</mn></msup><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m^2nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，或者是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2mlogm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，所以比较<code>m*m*n</code>和<code>n*n*m</code>很有必要。</li>
</ul>
<p>此题只是恰好通过列来搜索较优，实际上需要在最开始就进行一次判断，可自行测试。</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://zyq2652192993zyq.github.io/tag/CjgK0KqVA/" class="tag">
                    基础算法——二分法
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://zyq2652192993zyq.github.io/post/you-huan-dan-lian-biao-wen-ti-zong-jie/">
                  <h3 class="post-title">
                    有环单链表问题总结
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
